[
    {
        "file_name": "Frame.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "private int pop(){\n  if (outputStackTop > 0) {\n    return outputStack[--outputStackTop];\n  }\n else {\n    return STACK_KIND | -(--outputStackStart);\n  }\n}\n",
        "class_name": "Frame",
        "method_name": "pop",
        "all_context": "{ \"class_level\" : \"int SAME_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\\nint CHOP_FRAME;\\nint SAME_FRAME_EXTENDED;\\nint APPEND_FRAME;\\nint FULL_FRAME;\\nint ITEM_TOP;\\nint ITEM_INTEGER;\\nint ITEM_FLOAT;\\nint ITEM_DOUBLE;\\nint ITEM_LONG;\\nint ITEM_NULL;\\nint ITEM_UNINITIALIZED_THIS;\\nint ITEM_OBJECT;\\nint ITEM_UNINITIALIZED;\\nint ITEM_ASM_BOOLEAN;\\nint ITEM_ASM_BYTE;\\nint ITEM_ASM_CHAR;\\nint ITEM_ASM_SHORT;\\nint DIM_SIZE;\\nint KIND_SIZE;\\nint FLAGS_SIZE;\\nint VALUE_SIZE;\\nint DIM_SHIFT;\\nint KIND_SHIFT;\\nint FLAGS_SHIFT;\\nint DIM_MASK;\\nint KIND_MASK;\\nint VALUE_MASK;\\nint ARRAY_OF;\\nint ELEMENT_OF;\\nint CONSTANT_KIND;\\nint REFERENCE_KIND;\\nint UNINITIALIZED_KIND;\\nint LOCAL_KIND;\\nint STACK_KIND;\\nint TOP_IF_LONG_OR_DOUBLE_FLAG;\\nint TOP;\\nint BOOLEAN;\\nint BYTE;\\nint CHAR;\\nint SHORT;\\nint INTEGER;\\nint FLOAT;\\nint LONG;\\nint DOUBLE;\\nint NULL;\\nint UNINITIALIZED_THIS;\\nLabel owner;\\nint[] inputLocals;\\nint[] inputStack;\\nint[] outputLocals;\\nint[] outputStack;\\nshort outputStackStart;\\nshort outputStackTop;\\nint initializationCount;\\nint[] initializations;\\nFrame(Label owner);\\ngetAbstractTypeFromDescriptor(SymbolTable symbolTable,String buffer,int offset);\\nsetInputFrameFromDescriptor(SymbolTable symbolTable,int access,String descriptor,int maxLocals);\\ngetLocal(int localIndex);\\nsetLocal(int localIndex,int abstractType);\\npush(SymbolTable symbolTable,String descriptor);\\npop();\\npop(int elements);\\npop(String descriptor);\\naddInitializedType(int abstractType);\\ngetInitializedType(SymbolTable symbolTable,int abstractType);\\nexecute(int opcode,int arg,Symbol argSymbol,SymbolTable symbolTable);\\ngetConcreteOutputType(int abstractOutputType,int numStack);\\nmerge(SymbolTable symbolTable,Frame dstFrame);\\nmerge(SymbolTable symbolTable,int sourceType,int[] dstTypes,int dstIndex);\\naccept(MethodWriter methodWriter);\\npush(int abstractType);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * @author Eric Bruneton\n */\nclass Frame {\n    // Constants used in the StackMapTable attribute.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.\n\n    static final int SAME_FRAME = 0;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n//    static final int RESERVED = 128;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n    static final int CHOP_FRAME = 248;\n    static final int SAME_FRAME_EXTENDED = 251;\n    static final int APPEND_FRAME = 252;\n    static final int FULL_FRAME = 255;\n\n    static final int ITEM_TOP = 0;\n    static final int ITEM_INTEGER = 1;\n    static final int ITEM_FLOAT = 2;\n    static final int ITEM_DOUBLE = 3;\n    static final int ITEM_LONG = 4;\n    static final int ITEM_NULL = 5;\n    static final int ITEM_UNINITIALIZED_THIS = 6;\n    static final int ITEM_OBJECT = 7;\n    static final int ITEM_UNINITIALIZED = 8;\n    // Additional, ASM specific constants used in abstract types below.\n    static final int ITEM_ASM_BOOLEAN = 9;\n    static final int ITEM_ASM_BYTE = 10;\n    static final int ITEM_ASM_CHAR = 11;\n    static final int ITEM_ASM_SHORT = 12;\n\n    // The size and offset in bits of each field of an abstract type.\n\n    static final int DIM_SIZE = 6;\n    static final int KIND_SIZE = 4;\n    static final int FLAGS_SIZE = 2;\n    static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;\n\n    static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;\n    static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;\n    static final int FLAGS_SHIFT = VALUE_SIZE;\n\n    // Bitmasks to get each field of an abstract type.\n\n    static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;\n    static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;\n    static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;\n\n    // Constants to manipulate the DIM field of an abstract type.\n\n    /**\n     * The constant to be added to an abstract type to get one with one more array dimension.\n     */\n    static final int ARRAY_OF = +1 << DIM_SHIFT;\n\n    /**\n     * The constant to be added to an abstract type to get one with one less array dimension.\n     */\n    static final int ELEMENT_OF = -1 << DIM_SHIFT;\n\n    // Possible values for the KIND field of an abstract type.\n\n    static final int CONSTANT_KIND = 1 << KIND_SHIFT;\n    static final int REFERENCE_KIND = 2 << KIND_SHIFT;\n    static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;\n    static final int LOCAL_KIND = 4 << KIND_SHIFT;\n    static final int STACK_KIND = 5 << KIND_SHIFT;\n\n    // Possible flags for the FLAGS field of an abstract type.\n\n    /**\n     * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,\n     * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been\n     * partially overridden with an xSTORE instruction).\n     */\n    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;\n\n    // Useful predefined abstract types (all the possible CONSTANT_KIND types).\n\n    private static final int TOP = CONSTANT_KIND | ITEM_TOP;\n    private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;\n    private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;\n    private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;\n    private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;\n    private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;\n    private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;\n    private static final int LONG = CONSTANT_KIND | ITEM_LONG;\n    private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;\n    private static final int NULL = CONSTANT_KIND | ITEM_NULL;\n    private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;\n\n    // -----------------------------------------------------------------------------------------------\n    // Instance fields\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * The basic block to which these input and output stack map frames correspond.\n     */\n    Label owner;\n\n    /**\n     * The input stack map frame locals. This is an array of abstract types.\n     */\n    private int[] inputLocals;\n\n    /**\n     * The input stack map frame stack. This is an array of abstract types.\n     */\n    int[] inputStack;\n\n    /**\n     * The output stack map frame locals. This is an array of abstract types.\n     */\n    private int[] outputLocals;\n\n    /**\n     * The output stack map frame stack. This is an array of abstract types.\n     */\n    private int[] outputStack;\n\n    /**\n     * The start of the output stack, relatively to the input stack. This offset is always negative or\n     * null. A null offset means that the output stack must be appended to the input stack. A -n\n     * offset means that the first n output stack elements must replace the top n input stack\n     * elements, and that the other elements must be appended to the input stack.\n     */\n    private short outputStackStart;\n\n    /**\n     * The index of the top stack element in {@link #outputStack}.\n     */\n    private short outputStackTop;\n\n    /**\n     * The number of types that are initialized in the basic block. See {@link #initializations}.\n     */\n    private int initializationCount;\n\n    /**\n     * The abstract types that are initialized in the basic block. A constructor invocation on an\n     * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every occurrence</i> of this\n     * type in the local variables and in the operand stack. This cannot be done during the first step\n     * of the algorithm since, during this step, the local variables and the operand stack types are\n     * still abstract. It is therefore necessary to store the abstract types of the constructors which\n     * are invoked in the basic block, in order to do this replacement during the second step of the\n     * algorithm, where the frames are fully computed. Note that this array can contain abstract types\n     * that are relative to the input locals or to the input stack.\n     */\n    private int[] initializations;\n\n    // -----------------------------------------------------------------------------------------------\n    // Constructor\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new Frame.\n     *\n     * @param owner the basic block to which these input and output stack map frames correspond.\n     */\n    Frame(final Label owner) {\n        this.owner = owner;\n    }\n//\n//    /**\n//     * Returns the abstract type corresponding to the internal name of a class.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param internalName the internal name of a class. This must <i>not</i> be an array type\n//     *                     descriptor.\n//     * @return the abstract type value corresponding to the given internal name.\n//     */\n//    static int getAbstractTypeFromInternalName(\n//            final SymbolTable symbolTable, final String internalName) {\n//        return REFERENCE_KIND | symbolTable.addType(internalName);\n//    }\n\n    /**\n     * Returns the abstract type corresponding to the given type descriptor.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param buffer      a string ending with a type descriptor.\n     * @param offset      the start offset of the type descriptor in buffer.\n     * @return the abstract type corresponding to the given type descriptor.\n     */\n    private static int getAbstractTypeFromDescriptor(\n            final SymbolTable symbolTable, final String buffer, final int offset) {\n        String internalName = null;\n        switch (buffer.charAt(offset)) {\n            case 'V':\n                return 0;\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                return INTEGER;\n            case 'F':\n                return FLOAT;\n            case 'J':\n                return LONG;\n            case 'D':\n                return DOUBLE;\n            case 'L':\n                if (offset == 0) {\n                    switch (buffer) {\n                        case \"Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        case \"Ljava/util/List;\":\n                            internalName = \"java/util/List\";\n                            break;\n                        case \"Ljava/lang/reflect/Type;\":\n                            internalName = \"java/lang/reflect/Type\";\n                            break;\n                        case \"Ljava/util/function/Supplier;\":\n                            internalName = \"java/util/function/Supplier\";\n                            break;\n                        case \"Lsun/misc/Unsafe;\":\n                            internalName = \"sun/misc/Unsafe\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONReader;\":\n                            internalName = \"com/alibaba/fastjson2/JSONReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONWriter;\":\n                            internalName = \"com/alibaba/fastjson2/JSONWriter\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                            internalName = \"com/alibaba/fastjson2/writer/FieldWriter\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 2) {\n                    switch (buffer) {\n                        case \"()Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"()Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 3) {\n                    switch (buffer) {\n                        case \"(J)Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"(I)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"(I)Ljava/lang/Integer;\":\n                            internalName = \"java/lang/Integer\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 36) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 54) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 53) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 60) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                            if (offset == 62) {\n                                internalName = \"java/lang/String\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/reflect/Type;Ljava/lang/Object;J)Ljava/lang/Object;\":\n                            if (offset == 79) {\n                                internalName = \"java/lang/Object\";\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                if (internalName == null) {\n                    internalName = buffer.substring(offset + 1, buffer.length() - 1);\n                }\n                return REFERENCE_KIND | symbolTable.addType(internalName);\n            case '[':\n                int elementDescriptorOffset = offset + 1;\n                while (buffer.charAt(elementDescriptorOffset) == '[') {\n                    ++elementDescriptorOffset;\n                }\n                int typeValue;\n                switch (buffer.charAt(elementDescriptorOffset)) {\n                    case 'Z':\n                        typeValue = BOOLEAN;\n                        break;\n                    case 'C':\n                        typeValue = CHAR;\n                        break;\n                    case 'B':\n                        typeValue = BYTE;\n                        break;\n                    case 'S':\n                        typeValue = SHORT;\n                        break;\n                    case 'I':\n                        typeValue = INTEGER;\n                        break;\n                    case 'F':\n                        typeValue = FLOAT;\n                        break;\n                    case 'J':\n                        typeValue = LONG;\n                        break;\n                    case 'D':\n                        typeValue = DOUBLE;\n                        break;\n                    case 'L':\n                        if (offset == 0) {\n                            switch (buffer) {\n                                case \"[Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                                    internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                case \"[Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                                    internalName = \"Lcom/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                        if (internalName == null) {\n                            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\n                        }\n                        typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\n                        break;\n                    default:\n                        throw new IllegalArgumentException();\n                }\n                return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the input frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Sets the input frame from the given method description. This method is used to initialize the\n     * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\n     * attribute).\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param access      the method's access flags.\n     * @param descriptor  the method descriptor.\n     * @param maxLocals   the maximum number of local variables of the method.\n     */\n    final void setInputFrameFromDescriptor(\n            final SymbolTable symbolTable,\n            final int access,\n            final String descriptor,\n            final int maxLocals) {\n        inputLocals = new int[maxLocals];\n        inputStack = new int[0];\n        int inputLocalIndex = 0;\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\n                inputLocals[inputLocalIndex++] =\n                        REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n            } else {\n                inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\n            }\n        }\n        for (Type argumentType : Type.getArgumentTypes(descriptor)) {\n            int abstractType =\n                    getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\n            inputLocals[inputLocalIndex++] = abstractType;\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                inputLocals[inputLocalIndex++] = TOP;\n            }\n        }\n        while (inputLocalIndex < maxLocals) {\n            inputLocals[inputLocalIndex++] = TOP;\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex the index of the local variable whose value must be returned.\n     * @return the abstract type stored at the given local variable index in the output frame.\n     */\n    private int getLocal(final int localIndex) {\n        if (outputLocals == null || localIndex >= outputLocals.length) {\n            // If this local has never been assigned in this basic block, it is still equal to its value\n            // in the input frame.\n            return LOCAL_KIND | localIndex;\n        } else {\n            int abstractType = outputLocals[localIndex];\n            if (abstractType == 0) {\n                // If this local has never been assigned in this basic block, so it is still equal to its\n                // value in the input frame.\n                abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\n            }\n            return abstractType;\n        }\n    }\n\n    /**\n     * Replaces the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex   the index of the output frame local variable that must be set.\n     * @param abstractType the value that must be set.\n     */\n    private void setLocal(final int localIndex, final int abstractType) {\n        // Create and/or resize the output local variables array if necessary.\n        if (outputLocals == null) {\n            outputLocals = new int[10];\n        }\n        int outputLocalsLength = outputLocals.length;\n        if (localIndex >= outputLocalsLength) {\n            int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\n            System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\n            outputLocals = newOutputLocals;\n        }\n        // Set the local variable.\n        outputLocals[localIndex] = abstractType;\n    }\n\n    /**\n     * Pushes the given abstract type on the output frame stack.\n     *\n     * @param abstractType an abstract type.\n     */\n    private void push(final int abstractType) {\n        // Create and/or resize the output stack array if necessary.\n        if (outputStack == null) {\n            outputStack = new int[10];\n        }\n        int outputStackLength = outputStack.length;\n        if (outputStackTop >= outputStackLength) {\n            int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\n            System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\n            outputStack = newOutputStack;\n        }\n        // Pushes the abstract type on the output stack.\n        outputStack[outputStackTop++] = abstractType;\n        // Updates the maximum size reached by the output stack, if needed (note that this size is\n        // relative to the input stack size, which is not known yet).\n        short outputStackSize = (short) (outputStackStart + outputStackTop);\n        if (outputStackSize > owner.outputStackMax) {\n            owner.outputStackMax = outputStackSize;\n        }\n    }\n\n    /**\n     * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param descriptor  a type or method descriptor (in which case its return type is pushed).\n     */\n    private void push(final SymbolTable symbolTable, final String descriptor) {\n        final int typeDescriptorOffset;\n        switch (descriptor) {\n            case \"()J\":\n            case \"()V\":\n            case \"()Z\":\n            case \"()I\":\n            case \"()Ljava/lang/Class;\":\n                typeDescriptorOffset = 2;\n                break;\n            case \"(I)V\":\n            case \"(J)V\":\n            case \"(J)Z\":\n            case \"(I)Ljava/lang/Object;\":\n            case \"(I)Ljava/lang/Integer;\":\n                typeDescriptorOffset = 3;\n                break;\n            case \"(Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 18;\n                break;\n            case \"(Ljava/lang/Object;)Z\":\n            case \"(Ljava/lang/String;)V\":\n            case \"(Ljava/lang/Object;)V\":\n                typeDescriptorOffset = 20;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)Z\":\n                typeDescriptorOffset = 36;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;I)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;J)V\":\n                typeDescriptorOffset = 37;\n                break;\n            case \"(Ljava/lang/Object;Ljava/lang/reflect/Type;)Z\":\n                typeDescriptorOffset = 44;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 52;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;ZLjava/util/List;)V\":\n                typeDescriptorOffset = 53;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                typeDescriptorOffset = 60;\n                break;\n            case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                typeDescriptorOffset = 62;\n                break;\n            case \"(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;JLjava/util/List;)V\":\n                typeDescriptorOffset = 72;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;J)V\":\n                typeDescriptorOffset = 97;\n                break;\n            default:\n                if (descriptor.charAt(0) == '(') {\n                    int currentOffset = 1;\n                    // Skip the argument types, one at a each loop iteration.\n                    while (descriptor.charAt(currentOffset) != ')') {\n                        while (descriptor.charAt(currentOffset) == '[') {\n                            currentOffset++;\n                        }\n                        if (descriptor.charAt(currentOffset++) == 'L') {\n                            // Skip the argument descriptor content.\n                            int semiColumnOffset = descriptor.indexOf(';', currentOffset);\n                            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n                        }\n                    }\n                    typeDescriptorOffset = currentOffset + 1;\n                } else {\n                    typeDescriptorOffset = 0;\n                }\n                break;\n        }\n\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\n        if (abstractType != 0) {\n            push(abstractType);\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                push(TOP);\n            }\n        }\n    }\n\n    /**\n     * Pops an abstract type from the output frame stack and returns its value.\n     *\n     * @return the abstract type that has been popped from the output frame stack.\n     */\n    private int pop() {\n        if (outputStackTop > 0) {\n            return outputStack[--outputStackTop];\n        } else {\n            // If the output frame stack is empty, pop from the input stack.\n            return STACK_KIND | -(--outputStackStart);\n        }\n    }\n\n    /**\n     * Pops the given number of abstract types from the output frame stack.\n     *\n     * @param elements the number of abstract types that must be popped.\n     */\n    private void pop(final int elements) {\n        if (outputStackTop >= elements) {\n            outputStackTop -= elements;\n        } else {\n            // If the number of elements to be popped is greater than the number of elements in the output\n            // stack, clear it, and pop the remaining elements from the input stack.\n            outputStackStart -= elements - outputStackTop;\n            outputStackTop = 0;\n        }\n    }\n\n    /**\n     * Pops as many abstract types from the output frame stack as described by the given descriptor.\n     *\n     * @param descriptor a type or method descriptor (in which case its argument types are popped).\n     */\n    private void pop(final String descriptor) {\n        char firstDescriptorChar = descriptor.charAt(0);\n        if (firstDescriptorChar == '(') {\n            pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n        } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n            pop(2);\n        } else {\n            pop(1);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods to handle uninitialized types\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds an abstract type to the list of types on which a constructor is invoked in the basic\n     * block.\n     *\n     * @param abstractType an abstract type on a which a constructor is invoked.\n     */\n    private void addInitializedType(final int abstractType) {\n        // Create and/or resize the initializations array if necessary.\n        if (initializations == null) {\n            initializations = new int[2];\n        }\n        int initializationsLength = initializations.length;\n        if (initializationCount >= initializationsLength) {\n            int[] newInitializations =\n                    new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\n            System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\n            initializations = newInitializations;\n        }\n        // Store the abstract type.\n        initializations[initializationCount++] = abstractType;\n    }\n\n    /**\n     * Returns the \"initialized\" abstract type corresponding to the given abstract type.\n     *\n     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n     * @param abstractType an abstract type.\n     * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\n     * UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\n     * constructor is invoked in the basic block. Otherwise returns abstractType.\n     */\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\n        if (abstractType == UNINITIALIZED_THIS\n                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n            for (int i = 0; i < initializationCount; ++i) {\n                int initializedType = initializations[i];\n                int dim = initializedType & DIM_MASK;\n                int kind = initializedType & KIND_MASK;\n                int value = initializedType & VALUE_MASK;\n                if (kind == LOCAL_KIND) {\n                    initializedType = dim + inputLocals[value];\n                } else if (kind == STACK_KIND) {\n                    initializedType = dim + inputStack[inputStack.length - value];\n                }\n                if (abstractType == initializedType) {\n                    if (abstractType == UNINITIALIZED_THIS) {\n                        return REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n                    } else {\n                        return REFERENCE_KIND\n                                | symbolTable.addType(symbolTable.typeTable[abstractType & VALUE_MASK].value);\n                    }\n                }\n            }\n        }\n        return abstractType;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Main method, to simulate the execution of each instruction on the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Simulates the action of the given instruction on the output stack frame.\n     *\n     * @param opcode      the opcode of the instruction.\n     * @param arg         the numeric operand of the instruction, if any.\n     * @param argSymbol   the Symbol operand of the instruction, if any.\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     */\n    void execute(\n            final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\n        final int CONSTANT_INTEGER_TAG = 3;\n        final int CONSTANT_FLOAT_TAG = 4;\n        final int CONSTANT_LONG_TAG = 5;\n        final int CONSTANT_DOUBLE_TAG = 6;\n        final int CONSTANT_CLASS_TAG = 7;\n        final int CONSTANT_STRING_TAG = 8;\n        final int CONSTANT_METHOD_HANDLE_TAG = 15;\n        final int CONSTANT_METHOD_TYPE_TAG = 16;\n        final int CONSTANT_DYNAMIC_TAG = 17;\n\n        // Abstract types popped from the stack or read from local variables.\n        int abstractType1;\n        int abstractType2;\n        int abstractType3;\n        int abstractType4;\n        switch (opcode) {\n            case Opcodes.NOP:\n            case Opcodes.INEG:\n            case Opcodes.LNEG:\n            case Opcodes.FNEG:\n            case Opcodes.DNEG:\n            case Opcodes.I2B:\n            case Opcodes.I2C:\n            case Opcodes.I2S:\n            case Opcodes.GOTO:\n            case Opcodes.RETURN:\n                break;\n            case Opcodes.ACONST_NULL:\n                push(NULL);\n                break;\n            case Opcodes.ICONST_M1:\n            case Opcodes.ICONST_0:\n            case Opcodes.ICONST_1:\n            case Opcodes.ICONST_2:\n            case Opcodes.ICONST_3:\n            case Opcodes.ICONST_4:\n            case Opcodes.ICONST_5:\n            case Opcodes.BIPUSH:\n            case Opcodes.SIPUSH:\n            case Opcodes.ILOAD:\n                push(INTEGER);\n                break;\n            case Opcodes.LCONST_0:\n            case Opcodes.LCONST_1:\n            case Opcodes.LLOAD:\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.FCONST_0:\n            case Opcodes.FCONST_1:\n            case Opcodes.FCONST_2:\n            case Opcodes.FLOAD:\n                push(FLOAT);\n                break;\n            case Opcodes.DCONST_0:\n            case Opcodes.DCONST_1:\n            case Opcodes.DLOAD:\n                push(DOUBLE);\n                push(TOP);\n                break;\n            case Opcodes.LDC:\n                switch (argSymbol.tag) {\n                    case CONSTANT_INTEGER_TAG:\n                        push(INTEGER);\n                        break;\n                    case CONSTANT_LONG_TAG:\n                        push(LONG);\n                        push(TOP);\n                        break;\n                    case CONSTANT_FLOAT_TAG:\n                        push(FLOAT);\n                        break;\n                    case CONSTANT_DOUBLE_TAG:\n                        push(DOUBLE);\n                        push(TOP);\n                        break;\n                    case CONSTANT_CLASS_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\n                        break;\n                    case CONSTANT_STRING_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\n                        break;\n                    case CONSTANT_METHOD_TYPE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\n                        break;\n                    case CONSTANT_METHOD_HANDLE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\n                        break;\n                    case CONSTANT_DYNAMIC_TAG:\n                        push(symbolTable, argSymbol.value);\n                        break;\n                    default:\n                        throw new AssertionError();\n                }\n                break;\n            case Opcodes.ALOAD:\n                push(getLocal(arg));\n                break;\n            case Opcodes.LALOAD:\n            case Opcodes.D2L:\n                pop(2);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.AALOAD:\n                pop(1);\n                abstractType1 = pop();\n                push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\n                break;\n            case Opcodes.ISTORE:\n            case Opcodes.FSTORE:\n            case Opcodes.ASTORE:\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.LSTORE:\n            case Opcodes.DSTORE:\n                pop(1);\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                setLocal(arg + 1, TOP);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.POP:\n            case Opcodes.IFEQ:\n            case Opcodes.IFNE:\n            case Opcodes.IFLT:\n            case Opcodes.IFGE:\n            case Opcodes.IFGT:\n            case Opcodes.IFLE:\n            case Opcodes.IRETURN:\n            case Opcodes.FRETURN:\n            case Opcodes.ARETURN:\n            case Opcodes.TABLESWITCH:\n            case Opcodes.LOOKUPSWITCH:\n            case Opcodes.ATHROW:\n            case Opcodes.MONITORENTER:\n            case Opcodes.MONITOREXIT:\n            case Opcodes.IFNULL:\n            case Opcodes.IFNONNULL:\n                pop(1);\n                break;\n            case Opcodes.POP2:\n            case Opcodes.IF_ICMPEQ:\n            case Opcodes.IF_ICMPNE:\n            case Opcodes.IF_ICMPLT:\n            case Opcodes.IF_ICMPGE:\n            case Opcodes.IF_ICMPGT:\n            case Opcodes.IF_ICMPLE:\n            case Opcodes.IF_ACMPEQ:\n            case Opcodes.IF_ACMPNE:\n            case Opcodes.LRETURN:\n            case Opcodes.DRETURN:\n                pop(2);\n                break;\n            case Opcodes.DUP:\n                abstractType1 = pop();\n                push(abstractType1);\n                push(abstractType1);\n                break;\n            case Opcodes.DUP2:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType2);\n                push(abstractType1);\n                push(abstractType2);\n                push(abstractType1);\n                break;\n            case Opcodes.SWAP:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType1);\n                push(abstractType2);\n                break;\n            case Opcodes.IALOAD:\n            case Opcodes.BALOAD:\n            case Opcodes.CALOAD:\n            case Opcodes.SALOAD:\n            case Opcodes.IADD:\n            case Opcodes.ISUB:\n            case Opcodes.IMUL:\n            case Opcodes.IDIV:\n            case Opcodes.IREM:\n            case Opcodes.IAND:\n            case Opcodes.IOR:\n            case Opcodes.IXOR:\n            case Opcodes.ISHL:\n            case Opcodes.ISHR:\n            case Opcodes.IUSHR:\n            case Opcodes.L2I:\n            case Opcodes.D2I:\n            case Opcodes.FCMPL:\n            case Opcodes.FCMPG:\n                pop(2);\n                push(INTEGER);\n                break;\n            case Opcodes.LADD:\n            case Opcodes.LSUB:\n            case Opcodes.LMUL:\n            case Opcodes.LDIV:\n            case Opcodes.LREM:\n            case Opcodes.LAND:\n            case Opcodes.LOR:\n            case Opcodes.LXOR:\n                pop(4);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.LSHL:\n            case Opcodes.LSHR:\n            case Opcodes.LUSHR:\n                pop(3);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.IINC:\n                setLocal(arg, INTEGER);\n                break;\n            case Opcodes.F2I:\n            case Opcodes.ARRAYLENGTH:\n            case Opcodes.INSTANCEOF:\n                pop(1);\n                push(INTEGER);\n                break;\n            case Opcodes.LCMP:\n            case Opcodes.DCMPL:\n            case Opcodes.DCMPG:\n                pop(4);\n                push(INTEGER);\n                break;\n            case Opcodes.GETSTATIC:\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTSTATIC:\n                pop(argSymbol.value);\n                break;\n            case Opcodes.GETFIELD:\n                pop(1);\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTFIELD:\n                pop(argSymbol.value);\n                pop();\n                break;\n            case Opcodes.INVOKEVIRTUAL:\n            case Opcodes.INVOKESPECIAL:\n            case Opcodes.INVOKESTATIC:\n            case Opcodes.INVOKEINTERFACE:\n                pop(argSymbol.value);\n                if (opcode != Opcodes.INVOKESTATIC) {\n                    abstractType1 = pop();\n                    if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\n                        addInitializedType(abstractType1);\n                    }\n                }\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.NEW:\n                push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\n                break;\n            case Opcodes.CHECKCAST:\n                String castType = argSymbol.value;\n                pop();\n                if (castType.charAt(0) == '[') {\n                    push(symbolTable, castType);\n                } else {\n                    push(REFERENCE_KIND | symbolTable.addType(castType));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame merging methods, used in the second step of the stack map frame computation algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the concrete output type corresponding to a given abstract output type.\n     *\n     * @param abstractOutputType an abstract output type.\n     * @param numStack           the size of the input stack, used to resolve abstract output types of\n     *                           STACK_KIND kind.\n     * @return the concrete output type corresponding to 'abstractOutputType'.\n     */\n    private int getConcreteOutputType(final int abstractOutputType, final int numStack) {\n        int dim = abstractOutputType & DIM_MASK;\n        int kind = abstractOutputType & KIND_MASK;\n        if (kind == LOCAL_KIND) {\n            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else if (kind == STACK_KIND) {\n            // By definition, a STACK_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else {\n            return abstractOutputType;\n        }\n    }\n\n    final boolean merge(\n            final SymbolTable symbolTable, final Frame dstFrame) {\n        boolean frameChanged = false;\n\n        // Compute the concrete types of the local variables at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the local variables in the input frame of dstFrame.\n        int numLocal = inputLocals.length;\n        int numStack = inputStack.length;\n        if (dstFrame.inputLocals == null) {\n            dstFrame.inputLocals = new int[numLocal];\n            frameChanged = true;\n        }\n        for (int i = 0; i < numLocal; ++i) {\n            int concreteOutputType;\n            if (outputLocals != null && i < outputLocals.length) {\n                int abstractOutputType = outputLocals[i];\n                if (abstractOutputType == 0) {\n                    // If the local variable has never been assigned in this basic block, it is equal to its\n                    // value at the beginning of the block.\n                    concreteOutputType = inputLocals[i];\n                } else {\n                    concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n                }\n            } else {\n                // If the local variable has never been assigned in this basic block, it is equal to its\n                // value at the beginning of the block.\n                concreteOutputType = inputLocals[i];\n            }\n            // concreteOutputType might be an uninitialized type from the input locals or from the input\n            // stack. However, if a constructor has been called for this class type in the basic block,\n            // then this type is no longer uninitialized at the end of basic block.\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\n        }\n\n        // Compute the concrete types of the stack operands at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the stack operands in the input frame of dstFrame.\n        int numInputStack = inputStack.length + outputStackStart;\n        if (dstFrame.inputStack == null) {\n            dstFrame.inputStack = new int[numInputStack + outputStackTop];\n            frameChanged = true;\n        }\n        // First, do this for the stack operands that have not been popped in the basic block\n        // corresponding to this frame, and which are therefore equal to their value in the input\n        // frame (except for uninitialized types, which may have been initialized).\n        for (int i = 0; i < numInputStack; ++i) {\n            int concreteOutputType = inputStack[i];\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\n        }\n        // Then, do this for the stack operands that have pushed in the basic block (this code is the\n        // same as the one above for local variables).\n        for (int i = 0; i < outputStackTop; ++i) {\n            int abstractOutputType = outputStack[i];\n            int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |=\n                    merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\n        }\n        return frameChanged;\n    }\n\n    /**\n     * Merges the type at the given index in the given abstract type array with the given type.\n     * Returns {@literal true} if the type array has been modified by this operation.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param sourceType  the abstract type with which the abstract type array element must be merged.\n     *                    This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link\n     *                    #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.\n     * @param dstTypes    an array of abstract types. These types should be of {@link #CONSTANT_KIND},\n     *                    {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal\n     *                    null} array dimensions.\n     * @param dstIndex    the index of the type that must be merged in dstTypes.\n     * @return {@literal true} if the type array has been modified by this operation.\n     */\n    private static boolean merge(\n            final SymbolTable symbolTable,\n            final int sourceType,\n            final int[] dstTypes,\n            final int dstIndex) {\n        int dstType = dstTypes[dstIndex];\n        if (dstType == sourceType) {\n            // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\n            return false;\n        }\n        int srcType = sourceType;\n        if ((sourceType & ~DIM_MASK) == NULL) {\n            if (dstType == NULL) {\n                return false;\n            }\n            srcType = NULL;\n        }\n        if (dstType == 0) {\n            // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\n            dstTypes[dstIndex] = srcType;\n            return true;\n        }\n        int mergedType;\n        if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\n            // If dstType is a reference type of any array dimension.\n            if (srcType == NULL) {\n                // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\n                return false;\n            } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\n                // If srcType has the same array dimension and the same kind as dstType.\n                if ((dstType & KIND_MASK) == REFERENCE_KIND) {\n                    // If srcType and dstType are reference types with the same array dimension,\n                    // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\n                    mergedType =\n                            (srcType & DIM_MASK)\n                                    | REFERENCE_KIND\n                                    | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\n                } else {\n                    // If srcType and dstType are array types of equal dimension but different element types,\n                    // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\n                    int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\n                    mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n                }\n            } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\n                // If srcType is any other reference or array type,\n                // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\n                // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\n                // with a non reference element type (and similarly for dstDim).\n                int srcDim = srcType & DIM_MASK;\n                if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\n                    srcDim = ELEMENT_OF + srcDim;\n                }\n                int dstDim = dstType & DIM_MASK;\n                if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\n                    dstDim = ELEMENT_OF + dstDim;\n                }\n                mergedType =\n                        Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n            } else {\n                // If srcType is any other type, merge(srcType, dstType) = TOP.\n                mergedType = TOP;\n            }\n        } else if (dstType == NULL) {\n            // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\n            // an array type or a reference type.\n            mergedType =\n                    (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\n        } else {\n            // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\n            mergedType = TOP;\n        }\n        if (mergedType != dstType) {\n            dstTypes[dstIndex] = mergedType;\n            return true;\n        }\n        return false;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame output methods, to generate StackMapFrame attributes\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\n     * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\n     * {@link MethodWriter#visitFrameEnd} methods.\n     *\n     * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\n     *                     Frame}.\n     */\n    final void accept(final MethodWriter methodWriter) {\n        // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\n        // all trailing TOP types.\n        int[] localTypes = inputLocals;\n        int numLocal = 0;\n        int numTrailingTop = 0;\n        int i = 0;\n        while (i < localTypes.length) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            if (localType == TOP) {\n                numTrailingTop++;\n            } else {\n                numLocal += numTrailingTop + 1;\n                numTrailingTop = 0;\n            }\n        }\n        // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\n        int[] stackTypes = inputStack;\n        int numStack = 0;\n        i = 0;\n        while (i < stackTypes.length) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            numStack++;\n        }\n        // Visit the frame and its content.\n        int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\n        i = 0;\n        while (numLocal-- > 0) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, localType);\n        }\n        i = 0;\n        while (numStack-- > 0) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, stackType);\n        }\n        methodWriter.visitFrameEnd();\n    }\n//\n//    /**\n//     * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\n//     * format used in StackMapTable attributes.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\n//     *                     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n//     * @param output       where the abstract type must be put.\n//     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n//     * 4.7.4</a>\n//     */\n//    static void putAbstractType(\n//            final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\n//        int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\n//        if (arrayDimensions == 0) {\n//            int typeValue = abstractType & VALUE_MASK;\n//            switch (abstractType & KIND_MASK) {\n//                case CONSTANT_KIND:\n//                    output.putByte(typeValue);\n//                    break;\n//                case REFERENCE_KIND:\n//                    output\n//                            .putByte(ITEM_OBJECT)\n//                            .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, symbolTable.typeTable[typeValue].value).index);\n//                    break;\n//                case UNINITIALIZED_KIND:\n//                    output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.typeTable[typeValue].data);\n//                    break;\n//                default:\n//                    throw new AssertionError();\n//            }\n//        } else {\n//            // Case of an array type, we need to build its descriptor first.\n//            StringBuilder typeDescriptor = new StringBuilder();\n//            while (arrayDimensions-- > 0) {\n//                typeDescriptor.append('[');\n//            }\n//            if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\n//                typeDescriptor\n//                        .append('L')\n//                        .append(symbolTable.typeTable[abstractType & VALUE_MASK].value)\n//                        .append(';');\n//            } else {\n//                switch (abstractType & VALUE_MASK) {\n//                    case Frame.ITEM_ASM_BOOLEAN:\n//                        typeDescriptor.append('Z');\n//                        break;\n//                    case Frame.ITEM_ASM_BYTE:\n//                        typeDescriptor.append('B');\n//                        break;\n//                    case Frame.ITEM_ASM_CHAR:\n//                        typeDescriptor.append('C');\n//                        break;\n//                    case Frame.ITEM_ASM_SHORT:\n//                        typeDescriptor.append('S');\n//                        break;\n//                    case Frame.ITEM_INTEGER:\n//                        typeDescriptor.append('I');\n//                        break;\n//                    case Frame.ITEM_FLOAT:\n//                        typeDescriptor.append('F');\n//                        break;\n//                    case Frame.ITEM_LONG:\n//                        typeDescriptor.append('J');\n//                        break;\n//                    case Frame.ITEM_DOUBLE:\n//                        typeDescriptor.append('D');\n//                        break;\n//                    default:\n//                        throw new AssertionError();\n//                }\n//            }\n//            output\n//                    .putByte(ITEM_OBJECT)\n//                    .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, typeDescriptor.toString()).index);\n//        }\n//    }\n}\n"
    },
    {
        "file_name": "MethodWriter.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n  int frameLength=3 + numLocal + numStack;\n  if (currentFrame == null || currentFrame.length < frameLength) {\n    currentFrame=new int[frameLength];\n  }\n  currentFrame[0]=offset;\n  currentFrame[1]=numLocal;\n  currentFrame[2]=numStack;\n  return 3;\n}\n",
        "class_name": "MethodWriter",
        "method_name": "visitFrameStart",
        "all_context": "{ \"class_level\" : \"import com.alibaba.fastjson2.JSONException;\\nMethodWriter mv;\\nSymbolTable symbolTable;\\nint accessFlags;\\nint nameIndex;\\nString name;\\nint descriptorIndex;\\nString descriptor;\\nint maxStack;\\nint maxLocals;\\nByteVector code;\\nint stackMapTableNumberOfEntries;\\nByteVector stackMapTableEntries;\\nLabel firstBasicBlock;\\nLabel lastBasicBlock;\\nLabel currentBasicBlock;\\nint[] previousFrame;\\nint[] currentFrame;\\nboolean hasAsmInstructions;\\nint lastBytecodeOffset;\\nMethodWriter(SymbolTable symbolTable,int access,String name,String descriptor,int codeInitCapacity);\\nvisitInsn(int opcode);\\nvisitIntInsn(int opcode,int operand);\\nvisitVarInsn(int opcode,int var);\\nvisitTypeInsn(int opcode,String type);\\nvisitFieldInsn(int opcode,String owner,String name,String descriptor);\\nvisitMethodInsn(int opcode,String owner,String name,String descriptor,boolean isInterface);\\nvisitJumpInsn(int opcode,Label label);\\nvisitLabel(Label label);\\nvisitLdcInsn(String value);\\nvisitLdcInsn(Class value);\\nvisitLdcInsn(int value);\\nvisitLdcInsn(long value);\\nvisitIincInsn(int var,int increment);\\nvisitLookupSwitchInsn(Label dflt,int[] keys,Label[] labels);\\nvisitSwitchInsn(Label dflt,Label[] labels);\\nvisitMaxs(int maxStack,int maxLocals);\\nendCurrentBasicBlockWithNoSuccessor();\\nvisitFrameStart(int offset,int numLocal,int numStack);\\nvisitAbstractType(int frameIndex,int abstractType);\\nvisitFrameEnd();\\nputFrame();\\nputAbstractTypes(int start,int end);\\ncomputeMethodInfoSize();\\nputMethodInfo(ByteVector output);\\naddSuccessorToCurrentBasicBlock(Label successor);\\n\", \"repo_level\" : \"public interface JSONException { }\\n\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\nimport com.alibaba.fastjson2.JSONException;\n\n/**\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic final class MethodWriter {\n    protected MethodWriter mv;\n\n    /**\n     * Where the constants used in this MethodWriter must be stored.\n     */\n    private final SymbolTable symbolTable;\n\n    private final int accessFlags;\n\n    /**\n     * The name_index field of the method_info JVMS structure.\n     */\n    private final int nameIndex;\n\n    /**\n     * The name of this method.\n     */\n    private final String name;\n\n    /**\n     * The descriptor_index field of the method_info JVMS structure.\n     */\n    private final int descriptorIndex;\n\n    /**\n     * The descriptor of this method.\n     */\n    private final String descriptor;\n\n    // Code attribute fields and sub attributes:\n\n    /**\n     * The max_stack field of the Code attribute.\n     */\n    private int maxStack;\n\n    /**\n     * The max_locals field of the Code attribute.\n     */\n    private int maxLocals;\n\n    /**\n     * The 'code' field of the Code attribute.\n     */\n    private final ByteVector code;\n\n    /**\n     * The number_of_entries field of the StackMapTable code attribute.\n     */\n    int stackMapTableNumberOfEntries;\n\n    /**\n     * The 'entries' array of the StackMapTable code attribute.\n     */\n    private ByteVector stackMapTableEntries;\n    /**\n     * The first basic block of the method. The next ones (in bytecode offset order) can be accessed\n     * with the {@link Label#nextBasicBlock} field.\n     */\n    private Label firstBasicBlock;\n\n    /**\n     * The last basic block of the method (in bytecode offset order). This field is updated each time\n     * a basic block is encountered, and is used to append it at the end of the basic block list.\n     */\n    private Label lastBasicBlock;\n\n    private Label currentBasicBlock;\n\n    /**\n     * The last frame that was written in {@link #stackMapTableEntries}. This field has the same\n     * format as {@link #currentFrame}.\n     */\n    private int[] previousFrame;\n    private int[] currentFrame;\n\n    boolean hasAsmInstructions;\n\n    /**\n     * The start offset of the last visited instruction. Used to set the offset field of type\n     * annotations of type 'offset_target' (see <a\n     * href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1\">JVMS\n     * 4.7.20.1</a>).\n     */\n    private int lastBytecodeOffset;\n\n    // -----------------------------------------------------------------------------------------------\n    // Constructor and accessors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new {@link MethodWriter}.\n     *\n     * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n     * @param access      the method's access flags (see {@link Opcodes}).\n     * @param name        the method's name.\n     * @param descriptor  the method's descriptor (see {@link Type}).\n     */\n    MethodWriter(\n            SymbolTable symbolTable,\n            int access,\n            String name,\n            String descriptor,\n            int codeInitCapacity\n    ) {\n        this.symbolTable = symbolTable;\n        this.accessFlags = \"<init>\".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;\n        this.nameIndex = symbolTable.addConstantUtf8(name);\n        this.name = name;\n        this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\n        this.descriptor = descriptor;\n        this.code = new ByteVector(codeInitCapacity);\n\n        // Update maxLocals and currentLocals.\n        int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n        if ((access & Opcodes.ACC_STATIC) != 0) {\n            --argumentsSize;\n        }\n        maxLocals = argumentsSize;\n        // Create and visit the label for the first basic block.\n        firstBasicBlock = new Label();\n        visitLabel(firstBasicBlock);\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Implementation of the MethodVisitor abstract class\n    // -----------------------------------------------------------------------------------------------\n\n    public void visitInsn(final int opcode) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(opcode);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, 0, null, null);\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                endCurrentBasicBlockWithNoSuccessor();\n            }\n        }\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if (opcode == Opcodes.SIPUSH) {\n            code.put12(opcode, operand);\n        } else { // BIPUSH or NEWARRAY\n            code.put11(opcode, operand);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, operand, null, null);\n        }\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if (var < 4 && opcode != Opcodes.RET) {\n            int optimizedOpcode;\n            if (opcode < Opcodes.ISTORE) {\n                optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + var;\n            } else {\n                optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + var;\n            }\n            code.putByte(optimizedOpcode);\n        } else if (var >= 256) {\n            code.putByte(Constants.WIDE).put12(opcode, var);\n        } else {\n            code.put11(opcode, var);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, var, null, null);\n        }\n\n        int currentMaxLocals;\n        if (opcode == Opcodes.LLOAD\n                || opcode == Opcodes.DLOAD\n                || opcode == Opcodes.LSTORE\n                || opcode == Opcodes.DSTORE) {\n            currentMaxLocals = var + 2;\n        } else {\n            currentMaxLocals = var + 1;\n        }\n        if (currentMaxLocals > maxLocals) {\n            maxLocals = currentMaxLocals;\n        }\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol typeSymbol = symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, type);\n        code.put12(opcode, typeSymbol.index);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);\n        }\n    }\n\n    public void visitFieldInsn(\n            final int opcode, final String owner, final String name, final String descriptor) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol fieldrefSymbol = symbolTable.addConstantMemberReference(/*CONSTANT_FIELDREF_TAG*/ 9, owner, name, descriptor);\n        code.put12(opcode, fieldrefSymbol.index);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);\n        }\n    }\n\n    public void visitMethodInsn(\n            final int opcode,\n            final String owner,\n            final String name,\n            final String descriptor,\n            final boolean isInterface) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol methodrefSymbol = symbolTable.addConstantMemberReference(\n                isInterface ? /*CONSTANT_INTERFACE_METHODREF_TAG*/ 11 : /*CONSTANT_METHODREF_TAG*/ 10,\n                owner,\n                name,\n                descriptor\n        );\n        if (opcode == Opcodes.INVOKEINTERFACE) {\n            code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index)\n                    .put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);\n        } else {\n            code.put12(opcode, methodrefSymbol.index);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);\n        }\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.\n        int baseOpcode =\n                opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;\n        boolean nextInsnIsJumpTarget = false;\n        if ((label.flags & Label.FLAG_RESOLVED) != 0\n                && label.bytecodeOffset - code.length < Short.MIN_VALUE) {\n            throw new JSONException(\"not supported\");\n        } else if (baseOpcode != opcode) {\n            // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove\n            // ASM specific instructions). In this case we keep the original instruction.\n            code.putByte(opcode);\n            label.put(code, code.length - 1, true);\n        } else {\n            // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these\n            // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->\n            // ClassWriter round trip if it turns out that 2 bytes are not sufficient).\n            code.putByte(baseOpcode);\n            label.put(code, code.length - 1, false);\n        }\n\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            Label nextBasicBlock = null;\n            currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\n            // Record the fact that 'label' is the target of a jump instruction.\n            label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n            // Add 'label' as a successor of the current basic block.\n            addSuccessorToCurrentBasicBlock(label);\n            if (baseOpcode != Opcodes.GOTO) {\n                // The next instruction starts a new basic block (except for GOTO: by default the code\n                // following a goto is unreachable - unless there is an explicit label for it - and we\n                // should not compute stack frame types for its instructions).\n                nextBasicBlock = new Label();\n            }\n\n            // If the next instruction starts a new basic block, call visitLabel to add the label of this\n            // instruction as a successor of the current block, and to start a new basic block.\n            if (nextBasicBlock != null) {\n                if (nextInsnIsJumpTarget) {\n                    nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;\n                }\n                visitLabel(nextBasicBlock);\n            }\n            if (baseOpcode == Opcodes.GOTO) {\n                endCurrentBasicBlockWithNoSuccessor();\n            }\n        }\n    }\n\n    public void visitLabel(final Label label) {\n        // Resolve the forward references to this label, if any.\n        hasAsmInstructions |= label.resolve(code.data, code.length);\n        // visitLabel starts a new basic block (except for debug only labels), so we need to update the\n        // previous and current block references and list of successors.\n        if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {\n            return;\n        }\n\n        if (currentBasicBlock != null) {\n            if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {\n                // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only\n                // one place, but this does not work for labels which have not been visited yet.\n                // Therefore, when we detect here two labels having the same bytecode offset, we need to\n                // - consolidate the state scattered in these two instances into the canonical instance:\n                currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n                // - make sure the two instances share the same Frame instance (the implementation of\n                // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be\n                // null):\n                label.frame = currentBasicBlock.frame;\n                // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so\n                // that they still refer to the canonical instance for this bytecode offset.\n                return;\n            }\n            // End the current basic block (with one new successor).\n            addSuccessorToCurrentBasicBlock(label);\n        }\n        // Append 'label' at the end of the basic block list.\n        if (lastBasicBlock != null) {\n            if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {\n                // Same comment as above.\n                lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n                // Here label.frame should be null.\n                label.frame = lastBasicBlock.frame;\n                currentBasicBlock = lastBasicBlock;\n                return;\n            }\n            lastBasicBlock.nextBasicBlock = label;\n        }\n        lastBasicBlock = label;\n        // Make it the new current basic block.\n        currentBasicBlock = label;\n        // Here label.frame should be null.\n        label.frame = new Frame(label);\n    }\n//\n//  public void visitLdcInsn(final Object value) {\n//    lastBytecodeOffset = code.length;\n//    // Add the instruction to the bytecode of the method.\n//    Symbol constantSymbol = symbolTable.addConstant(value);\n//    int constantIndex = constantSymbol.index;\n//    char firstDescriptorChar;\n//    boolean isLongOrDouble =\n//            constantSymbol.tag == Symbol.CONSTANT_LONG_TAG\n//                    || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG\n//                    || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG\n//                    && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J'\n//                    || firstDescriptorChar == 'D'));\n//    if (isLongOrDouble) {\n//      code.put12(Constants.LDC2_W, constantIndex);\n//    } else if (constantIndex >= 256) {\n//      code.put12(Constants.LDC_W, constantIndex);\n//    } else {\n//      code.put11(Opcodes.LDC, constantIndex);\n//    }\n//    // If needed, update the maximum stack size and number of locals, and stack map frames.\n//    if (currentBasicBlock != null) {\n//      currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n//    }\n//  }\n\n    public void visitLdcInsn(final String value) {\n        final int CONSTANT_STRING_TAG = 8;\n\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstantUtf8Reference(CONSTANT_STRING_TAG, value);\n        int constantIndex = constantSymbol.index;\n        if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitLdcInsn(Class value) {\n        // getTypeInternal(typeDescriptor, 0, typeDescriptor.length())\n        String desc = ASMUtils.desc(value);\n        Type type = Type.getTypeInternal(desc, 0, desc.length());\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol;\n//        int typeSort = type.getSort();\n        int typeSort = type.sort == Type.INTERNAL ? Type.OBJECT : type.sort;\n        if (typeSort == Type.OBJECT) {\n            // type.valueBuffer.substring(type.valueBegin, type.valueEnd)\n            constantSymbol = symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, type.valueBuffer.substring(type.valueBegin, type.valueEnd));\n        } else { // type is a primitive or array type.\n            constantSymbol = symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, type.getDescriptor());\n        }\n        int constantIndex = constantSymbol.index;\n        if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitLdcInsn(final int value) {\n        final int CONSTANT_INTEGER_TAG = 3;\n\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstantIntegerOrFloat(CONSTANT_INTEGER_TAG, value);\n        int constantIndex = constantSymbol.index;\n        if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitLdcInsn(final long value) {\n        final int CONSTANT_LONG_TAG = 5;\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstantLongOrDouble(CONSTANT_LONG_TAG, value);\n        int constantIndex = constantSymbol.index;\n        code.put12(Constants.LDC2_W, constantIndex);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n        }\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if ((var > 255) || (increment > 127) || (increment < -128)) {\n            code.putByte(Constants.WIDE).put12(Opcodes.IINC, var).putShort(increment);\n        } else {\n            code.putByte(Opcodes.IINC).put11(var, increment);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.IINC, var, null, null);\n        }\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(code, lastBytecodeOffset, true);\n        code.putInt(labels.length);\n        for (int i = 0; i < labels.length; ++i) {\n            code.putInt(keys[i]);\n            labels[i].put(code, lastBytecodeOffset, true);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        visitSwitchInsn(dflt, labels);\n    }\n\n    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n        if (currentBasicBlock != null) {\n            currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n            // Add all the labels as successors of the current basic block.\n            addSuccessorToCurrentBasicBlock(dflt);\n            dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n            for (Label label : labels) {\n                addSuccessorToCurrentBasicBlock(label);\n                label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n            }\n            // End the current basic block.\n            endCurrentBasicBlockWithNoSuccessor();\n        }\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        /**\n         * Computes all the stack map frames of the method, from scratch.\n         */\n        // computeAllFrames();\n        // Create and visit the first (implicit) frame.\n        Frame firstFrame = firstBasicBlock.frame;\n        firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\n        firstFrame.accept(this);\n\n        // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks\n        // whose stack map frame has changed) and, while there are blocks to process, remove one from\n        // the list and update the stack map frames of its successor blocks in the control flow graph\n        // (which might change them, in which case these blocks must be processed too, and are thus\n        // added to the list of blocks to process). Also compute the maximum stack size of the method,\n        // as a by-product.\n        Label listOfBlocksToProcess = firstBasicBlock;\n        listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n        int maxStackSize = 0;\n        while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n            // Remove a basic block from the list of blocks to process.\n            Label basicBlock = listOfBlocksToProcess;\n            listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n            basicBlock.nextListElement = null;\n            // By definition, basicBlock is reachable.\n            basicBlock.flags |= Label.FLAG_REACHABLE;\n            // Update the (absolute) maximum stack size.\n            int maxBlockStackSize = basicBlock.frame.inputStack.length + basicBlock.outputStackMax;\n            if (maxBlockStackSize > maxStackSize) {\n                maxStackSize = maxBlockStackSize;\n            }\n            // Update the successor blocks of basicBlock in the control flow graph.\n            Edge outgoingEdge = basicBlock.outgoingEdges;\n            while (outgoingEdge != null) {\n                Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\n                boolean successorBlockChanged =\n                        basicBlock.frame.merge(symbolTable, successorBlock.frame);\n                if (successorBlockChanged && successorBlock.nextListElement == null) {\n                    // If successorBlock has changed it must be processed. Thus, if it is not already in the\n                    // list of blocks to process, add it to this list.\n                    successorBlock.nextListElement = listOfBlocksToProcess;\n                    listOfBlocksToProcess = successorBlock;\n                }\n                outgoingEdge = outgoingEdge.nextEdge;\n            }\n        }\n\n        // Loop over all the basic blocks and visit the stack map frames that must be stored in the\n        // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from\n        // exception handler ranges.\n        Label basicBlock = firstBasicBlock;\n        while (basicBlock != null) {\n            if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE))\n                    == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\n                basicBlock.frame.accept(this);\n            }\n            if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\n                // Find the start and end bytecode offsets of this unreachable block.\n                Label nextBasicBlock = basicBlock.nextBasicBlock;\n                int startOffset = basicBlock.bytecodeOffset;\n                int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\n                if (endOffset >= startOffset) {\n                    // Replace its instructions with NOP ... NOP ATHROW.\n                    for (int i = startOffset; i < endOffset; ++i) {\n                        code.data[i] = Opcodes.NOP;\n                    }\n                    code.data[endOffset] = (byte) Opcodes.ATHROW;\n                    // Emit a frame for this unreachable block, with no local and a Throwable on the stack\n                    // (so that the ATHROW could consume this Throwable if it were reachable).\n                    int frameIndex = visitFrameStart(startOffset, /* numLocal = */ 0, /* numStack = */ 1);\n                    currentFrame[frameIndex] = Frame.REFERENCE_KIND | symbolTable.addType(\"java/lang/Throwable\");\n                    visitFrameEnd();\n                    // The maximum stack size is now at least one, because of the Throwable declared above.\n                    maxStackSize = Math.max(maxStackSize, 1);\n                }\n            }\n            basicBlock = basicBlock.nextBasicBlock;\n        }\n\n        this.maxStack = maxStackSize;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: control flow analysis algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\n     *\n     * @param successor the successor block to be added to the current basic block.\n     */\n    private void addSuccessorToCurrentBasicBlock(final Label successor) {\n        currentBasicBlock.outgoingEdges = new Edge(successor, currentBasicBlock.outgoingEdges);\n    }\n\n    /**\n     * Ends the current basic block. This method must be used in the case where the current basic\n     * block does not have any successor.\n     *\n     * <p>WARNING: this method must be called after the currently visited instruction has been put in\n     * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\n     * block after the current instruction).\n     */\n    private void endCurrentBasicBlockWithNoSuccessor() {\n        Label nextBasicBlock = new Label();\n        nextBasicBlock.frame = new Frame(nextBasicBlock);\n        nextBasicBlock.resolve(code.data, code.length);\n        lastBasicBlock.nextBasicBlock = nextBasicBlock;\n        lastBasicBlock = nextBasicBlock;\n        currentBasicBlock = null;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: stack map frames\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\n     *\n     * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n     * @param numLocal the number of local variables in the frame.\n     * @param numStack the number of stack elements in the frame.\n     * @return the index of the next element to be written in this frame.\n     */\n    int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n        int frameLength = 3 + numLocal + numStack;\n        if (currentFrame == null || currentFrame.length < frameLength) {\n            currentFrame = new int[frameLength];\n        }\n        currentFrame[0] = offset;\n        currentFrame[1] = numLocal;\n        currentFrame[2] = numStack;\n        return 3;\n    }\n\n    /**\n     * Sets an abstract type in {@link #currentFrame}.\n     *\n     * @param frameIndex   the index of the element to be set in {@link #currentFrame}.\n     * @param abstractType an abstract type.\n     */\n    void visitAbstractType(final int frameIndex, final int abstractType) {\n        currentFrame[frameIndex] = abstractType;\n    }\n\n    /**\n     * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\n     * updating the StackMapTable number_of_entries (except if the current frame is the first one,\n     * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\n     */\n    void visitFrameEnd() {\n        if (previousFrame != null) {\n            if (stackMapTableEntries == null) {\n                stackMapTableEntries = new ByteVector(2048);\n            }\n            putFrame();\n            ++stackMapTableNumberOfEntries;\n        }\n        previousFrame = currentFrame;\n        currentFrame = null;\n    }\n\n    /**\n     * Compresses and writes {@link #currentFrame} in a new StackMapTable entry.\n     */\n    private void putFrame() {\n        final int numLocal = currentFrame[1];\n        final int numStack = currentFrame[2];\n        final int offsetDelta =\n                stackMapTableNumberOfEntries == 0\n                        ? currentFrame[0]\n                        : currentFrame[0] - previousFrame[0] - 1;\n        final int previousNumlocal = previousFrame[1];\n        final int numLocalDelta = numLocal - previousNumlocal;\n        int type = Frame.FULL_FRAME;\n        if (numStack == 0) {\n            switch (numLocalDelta) {\n                case -3:\n                case -2:\n                case -1:\n                    type = Frame.CHOP_FRAME;\n                    break;\n                case 0:\n                    type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    type = Frame.APPEND_FRAME;\n                    break;\n                default:\n                    // Keep the FULL_FRAME type.\n                    break;\n            }\n        } else if (numLocalDelta == 0 && numStack == 1) {\n            type =\n                    offsetDelta < 63\n                            ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME\n                            : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n        }\n        if (type != Frame.FULL_FRAME) {\n            // Verify if locals are the same as in the previous frame.\n            int frameIndex = 3;\n            for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\n                if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\n                    type = Frame.FULL_FRAME;\n                    break;\n                }\n                frameIndex++;\n            }\n        }\n        switch (type) {\n            case Frame.SAME_FRAME:\n                stackMapTableEntries.putByte(offsetDelta);\n                break;\n            case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\n                stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\n                putAbstractTypes(3 + numLocal, 4 + numLocal);\n                break;\n            case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                stackMapTableEntries\n                        .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n                        .putShort(offsetDelta);\n                putAbstractTypes(3 + numLocal, 4 + numLocal);\n                break;\n            case Frame.SAME_FRAME_EXTENDED:\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\n                break;\n            case Frame.CHOP_FRAME:\n                stackMapTableEntries\n                        .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)\n                        .putShort(offsetDelta);\n                break;\n            case Frame.APPEND_FRAME:\n                stackMapTableEntries\n                        .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)\n                        .putShort(offsetDelta);\n                putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\n                break;\n            case Frame.FULL_FRAME:\n            default:\n                stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\n                putAbstractTypes(3, 3 + numLocal);\n                stackMapTableEntries.putShort(numStack);\n                putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\n                break;\n        }\n    }\n\n    /**\n     * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\n     * JVMS verification_type_info format used in StackMapTable attributes.\n     *\n     * @param start index of the first type in {@link #currentFrame} to write.\n     * @param end   index of last type in {@link #currentFrame} to write (exclusive).\n     */\n    private void putAbstractTypes(final int start, final int end) {\n        for (int i = start; i < end; ++i) {\n            final int abstractType = currentFrame[i];\n            final ByteVector output = stackMapTableEntries;\n\n            int arrayDimensions = (abstractType & Frame.DIM_MASK) >> Frame.DIM_SHIFT;\n            if (arrayDimensions == 0) {\n                int typeValue = abstractType & Frame.VALUE_MASK;\n                switch (abstractType & Frame.KIND_MASK) {\n                    case Frame.CONSTANT_KIND:\n                        output.putByte(typeValue);\n                        break;\n                    case Frame.REFERENCE_KIND:\n                        output\n                                .putByte(Frame.ITEM_OBJECT)\n                                .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, symbolTable.typeTable[typeValue].value).index);\n                        break;\n                    case Frame.UNINITIALIZED_KIND:\n                        output.putByte(Frame.ITEM_UNINITIALIZED).putShort((int) symbolTable.typeTable[typeValue].data);\n                        break;\n                    default:\n                        throw new AssertionError();\n                }\n            } else {\n                // Case of an array type, we need to build its descriptor first.\n                StringBuilder typeDescriptor = new StringBuilder();\n                while (arrayDimensions-- > 0) {\n                    typeDescriptor.append('[');\n                }\n                if ((abstractType & Frame.KIND_MASK) == Frame.REFERENCE_KIND) {\n                    typeDescriptor\n                            .append('L')\n                            .append(symbolTable.typeTable[abstractType & Frame.VALUE_MASK].value)\n                            .append(';');\n                } else {\n                    switch (abstractType & Frame.VALUE_MASK) {\n                        case Frame.ITEM_ASM_BOOLEAN:\n                            typeDescriptor.append('Z');\n                            break;\n                        case Frame.ITEM_ASM_BYTE:\n                            typeDescriptor.append('B');\n                            break;\n                        case Frame.ITEM_ASM_CHAR:\n                            typeDescriptor.append('C');\n                            break;\n                        case Frame.ITEM_ASM_SHORT:\n                            typeDescriptor.append('S');\n                            break;\n                        case Frame.ITEM_INTEGER:\n                            typeDescriptor.append('I');\n                            break;\n                        case Frame.ITEM_FLOAT:\n                            typeDescriptor.append('F');\n                            break;\n                        case Frame.ITEM_LONG:\n                            typeDescriptor.append('J');\n                            break;\n                        case Frame.ITEM_DOUBLE:\n                            typeDescriptor.append('D');\n                            break;\n                        default:\n                            throw new AssertionError();\n                    }\n                }\n                output\n                        .putByte(Frame.ITEM_OBJECT)\n                        .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, typeDescriptor.toString()).index);\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\n     * names of the attributes of this method in the constant pool.\n     *\n     * @return the size in bytes of the method_info JVMS structure.\n     */\n    int computeMethodInfoSize() {\n        // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\n        int size = 8;\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        if (code.length > 0) {\n            if (code.length > 65535) {\n                throw new JSONException(\"Method too large: \" + symbolTable.className + \".\" + name + \" \" + descriptor + \", length \" + code.length);\n            }\n            symbolTable.addConstantUtf8(Constants.CODE);\n            // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\n            // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\n            size += 16 + code.length + 2;\n            if (stackMapTableEntries != null) {\n                boolean useStackMapTable = true;\n                symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\n                // 6 header bytes and 2 bytes for number_of_entries.\n                size += 8 + stackMapTableEntries.length;\n            }\n        }\n        return size;\n    }\n\n    /**\n     * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\n     * given ByteVector.\n     *\n     * @param output where the method_info structure must be put.\n     */\n    void putMethodInfo(final ByteVector output) {\n        int mask = 0;\n        output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        int attributeCount = 0;\n        if (code.length > 0) {\n            ++attributeCount;\n        }\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        output.putShort(attributeCount);\n        if (code.length > 0) {\n            // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\n            // attributes_count, plus the bytecode and the exception table.\n            int size = 10 + code.length + 2;\n            int codeAttributeCount = 0;\n            if (stackMapTableEntries != null) {\n                // 6 header bytes and 2 bytes for number_of_entries.\n                size += 8 + stackMapTableEntries.length;\n                ++codeAttributeCount;\n            }\n            output\n                    .putShort(symbolTable.addConstantUtf8(Constants.CODE))\n                    .putInt(size)\n                    .putShort(maxStack)\n                    .putShort(maxLocals)\n                    .putInt(code.length)\n                    .putByteArray(code.data, 0, code.length);\n            output.putShort(0); // putExceptionTable\n            output.putShort(codeAttributeCount);\n            if (stackMapTableEntries != null) {\n                boolean useStackMapTable = true;\n                output\n                        .putShort(\n                                symbolTable.addConstantUtf8(\n                                        useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\"))\n                        .putInt(2 + stackMapTableEntries.length)\n                        .putShort(stackMapTableNumberOfEntries)\n                        .putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\n            }\n        }\n    }\n}\n"
    },
    {
        "file_name": "ByteVector.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "private void enlarge(final int size){\n  int doubleCapacity=2 * data.length;\n  int minimalCapacity=length + size;\n  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n  System.arraycopy(data,0,newData,0,length);\n  data=newData;\n}\n",
        "class_name": "ByteVector",
        "method_name": "enlarge",
        "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n"
    },
    {
        "file_name": "JSONArray.java",
        "package": "com.alibaba.fastjson2",
        "code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n  try (JSONWriter writer=JSONWriter.of(features)){\n    if ((writer.context.features & NONE_DIRECT_FEATURES) == 0) {\n      writer.write(this);\n    }\n else {\n      writer.setRootObject(this);\n      if (arrayWriter == null) {\n        arrayWriter=writer.getObjectWriter(JSONArray.class,JSONArray.class);\n      }\n      arrayWriter.write(writer,this,null,null,0);\n    }\n    return writer.toString();\n  }\n }\n",
        "class_name": "JSONArray",
        "method_name": "toString",
        "all_context": "{ \"class_level\" : \"import com.alibaba.fastjson2.reader.ObjectReader;\\nimport com.alibaba.fastjson2.reader.ObjectReaderImplEnum;\\nimport com.alibaba.fastjson2.reader.ObjectReaderProvider;\\nimport com.alibaba.fastjson2.schema.JSONSchema;\\nimport com.alibaba.fastjson2.util.DateUtils;\\nimport com.alibaba.fastjson2.util.Fnv;\\nimport com.alibaba.fastjson2.util.IOUtils;\\nimport com.alibaba.fastjson2.util.TypeUtils;\\nimport com.alibaba.fastjson2.writer.ObjectWriter;\\nimport com.alibaba.fastjson2.writer.ObjectWriterAdapter;\\nimport java.lang.reflect.Array;\\nimport java.lang.reflect.Type;\\nimport java.math.BigDecimal;\\nimport java.math.BigInteger;\\nimport java.time.Instant;\\nimport java.util.*;\\nimport java.util.function.Function;\\nimport static com.alibaba.fastjson2.JSONObject.NONE_DIRECT_FEATURES;\\nimport static com.alibaba.fastjson2.JSONWriter.Feature.*;\\nlong serialVersionUID;\\nObjectWriter<JSONArray> arrayWriter;\\nJSONArray();\\nJSONArray(int initialCapacity);\\nJSONArray(Collection collection);\\nJSONArray(Object items);\\nset(int index,Object element);\\ngetJSONArray(int index);\\ngetJSONObject(int index);\\ngetString(int index);\\ngetDouble(int index);\\ngetDoubleValue(int index);\\ngetFloat(int index);\\ngetFloatValue(int index);\\ngetLong(int index);\\ngetLongValue(int index);\\ngetInteger(int index);\\ngetIntValue(int index);\\ngetShort(int index);\\ngetShortValue(int index);\\ngetByte(int index);\\ngetByteValue(int index);\\ngetBoolean(int index);\\ngetBooleanValue(int index);\\ngetBigInteger(int index);\\ngetBigDecimal(int index);\\ngetDate(int index);\\ngetInstant(int index);\\ntoString(Feature features);\\ntoJSONString(Feature features);\\ntoJSONString(Object object,Feature features);\\ntoJSONBBytes(Feature features);\\nto(Type type);\\nto(Class type);\\ntoJavaObject(Type type);\\ntoList(Class itemClass,Feature features);\\ntoArray(Class itemClass,Feature features);\\ntoJavaList(Class clazz,Feature features);\\ngetObject(int index,Type type,Feature features);\\ngetObject(int index,Class type,Feature features);\\ngetObject(int index,Function creator);\\nfluentAdd(Object element);\\nfluentClear();\\nfluentRemove(int index);\\nfluentSet(int index,Object element);\\nfluentRemove(Object o);\\nfluentRemoveAll(Collection c);\\nfluentAddAll(Collection c);\\nisValid(JSONSchema schema);\\nclone();\\nof(Object items);\\nof(Object item);\\nof(Object first,Object second);\\nof(Object first,Object second,Object third);\\nparseArray(String text,Feature features);\\nparse(String text,Feature features);\\ntoString();\\n\", \"repo_level\" : \"public interface ObjectReader {default T createInstance();\\ndefault T createInstance(long features);\\ndefault T createInstance(Collection collection);\\ndefault T createInstance(Map map,Feature features);\\ndefault T createInstance(Map map,long features);\\ndefault T createInstanceNoneDefaultConstructor(Map values);\\ndefault long getFeatures();\\ndefault String getTypeKey();\\ndefault long getTypeKeyHash();\\ndefault Class<T> getObjectClass();\\ndefault FieldReader getFieldReader(long hashCode);\\ndefault FieldReader getFieldReaderLCase(long hashCode);\\ndefault boolean setFieldValue(Object object,String fieldName,long fieldNameHashCode,int value);\\ndefault boolean setFieldValue(Object object,String fieldName,long fieldNameHashCode,long value);\\ndefault FieldReader getFieldReader(String fieldName);\\ndefault Function getBuildFunction();\\ndefault ObjectReader autoType(Context context,long typeHash);\\ndefault ObjectReader autoType(ObjectReaderProvider provider,long typeHash);\\ndefault T readJSONBObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\ndefault T readArrayMappingJSONBObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\ndefault T readArrayMappingObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\ndefault T readObject(JSONReader jsonReader);\\ndefault T readObject(JSONReader jsonReader,long features);\\n T readObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\n }\\npublic interface ObjectReaderImplEnum {public Class getObjectClass();\\npublic Enum getEnumByHashCode(long hashCode);\\npublic Enum getEnumByOrdinal(int ordinal);\\npublic Object readJSONBObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\npublic Object readObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\n }\\npublic interface ObjectReaderProvider {public void registerIfAbsent(long hashCode,ObjectReader objectReader);\\npublic void addAutoTypeAccept(String name);\\npublic Consumer<Class> getAutoTypeHandler();\\npublic void setAutoTypeHandler(Consumer autoTypeHandler);\\npublic Class getMixIn(Class target);\\npublic void mixIn(Class target,Class mixinSource);\\npublic ObjectReader register(Type type,ObjectReader objectReader);\\npublic ObjectReader registerIfAbsent(Type type,ObjectReader objectReader);\\npublic ObjectReader unregisterObjectReader(Type type);\\npublic boolean unregisterObjectReader(Type type,ObjectReader reader);\\npublic boolean register(ObjectReaderModule module);\\npublic boolean unregister(ObjectReaderModule module);\\npublic void cleanup(Class objectClass);\\npublic void cleanup(ClassLoader classLoader);\\npublic ObjectReaderCreator getCreator();\\n void init();\\npublic Function getTypeConvert(Type from,Type to);\\npublic Function registerTypeConvert(Type from,Type to,Function typeConvert);\\npublic ObjectReader getObjectReader(long hashCode);\\npublic ObjectReader getObjectReader(String typeName,Class expectClass,long features);\\nfinal void afterAutoType(String typeName,Class type);\\npublic Class<?> checkAutoType(String typeName,Class expectClass,long features);\\npublic List<ObjectReaderModule> getModules();\\npublic ObjectReader getObjectReader(Type objectType);\\npublic ObjectReader getObjectReader(Type objectType,boolean fieldBased);\\npublic AutoTypeBeforeHandler getAutoTypeBeforeHandler();\\npublic Map<String,Date> getAutoTypeList();\\npublic void setAutoTypeBeforeHandler(AutoTypeBeforeHandler autoTypeBeforeHandler);\\nprotected boolean removeEldestEntry(Map.Entry eldest);\\n }\\npublic interface JSONSchema {static JSONSchema of(JSONObject input,Class objectClass);\\nstatic Not ofNot(JSONObject input,Class objectClass);\\nstatic JSONSchema parseSchema(String schema);\\nstatic JSONSchema of(JSONObject input);\\nstatic JSONSchema of(JSONObject input,JSONSchema parent);\\nstatic AnyOf anyOf(JSONObject input,Class type);\\nstatic AnyOf anyOf(JSONArray array,Class type);\\nstatic AllOf allOf(JSONObject input,Class type);\\nstatic OneOf oneOf(JSONObject input,Class type);\\nstatic OneOf oneOf(JSONArray array,Class type);\\npublic String getTitle();\\npublic String getDescription();\\nabstract Type getType();\\nabstract ValidateResult validate(Object value);\\npublic boolean isValid(Object value);\\npublic boolean isValid(long value);\\npublic boolean isValid(double value);\\npublic boolean isValid(Double value);\\npublic boolean isValid(float value);\\npublic boolean isValid(Float value);\\npublic boolean isValid(Integer value);\\npublic boolean isValid(Long value);\\npublic ValidateResult validate(long value);\\npublic ValidateResult validate(double value);\\npublic ValidateResult validate(Float value);\\npublic ValidateResult validate(Double value);\\npublic ValidateResult validate(Integer value);\\npublic ValidateResult validate(Long value);\\npublic void assertValidate(Object value);\\npublic void assertValidate(Integer value);\\npublic void assertValidate(Long value);\\npublic void assertValidate(Double value);\\npublic void assertValidate(Float value);\\npublic void assertValidate(long value);\\npublic void assertValidate(double value);\\nstatic Type of(String typeStr);\\n }\\npublic interface DateUtils {static Date parseDate(String str);\\nstatic LocalDateTime parseLocalDateTime(String str);\\nstatic LocalDateTime parseLocalDateTime(String str,int off,int len);\\nstatic LocalDate parseLocalDate(String str);\\nstatic LocalDate parseLocalDate(String str,int off,int len);\\nstatic LocalDate parseLocalDate8(String str,int off);\\nstatic LocalDate parseLocalDate9(String str,int off);\\nstatic LocalDate parseLocalDate10(String str,int off);\\nstatic LocalDate parseLocalDate11(String str,int off);\\nstatic LocalDateTime parseLocalDateTime12(String str,int off);\\nstatic LocalDateTime parseLocalDateTime14(String str,int off);\\nstatic LocalDateTime parseLocalDateTime16(String str,int off);\\nstatic LocalDateTime parseLocalDateTime17(String str,int off);\\nstatic LocalDateTime parseLocalDateTime18(String str,int off);\\nstatic LocalDateTime parseLocalDateTime19(String str,int off);\\nstatic LocalDateTime parseLocalDateTimeX(String str,int offset,int len);\\nstatic ZonedDateTime parseZonedDateTime(String str);\\nstatic ZonedDateTime parseZonedDateTime(String str,int offset,int len);\\nstatic ZonedDateTime parseZonedDateTime(String str,int offset,int len,ZoneId defaultZoneId);\\nstatic ZoneId getZoneId(String zoneIdStr,ZoneId defaultZoneId);\\nstatic long toMillis19(String str,int off,ZoneId zoneId);\\nstatic LocalDateTime localDateTime(char y0,char y1,char y2,char y3,char m0,char m1,char d0,char d1,char h0,char h1,char i0,char i1,char s0,char s1,char S0,char S1,char S2,char S3,char S4,char S5,char S6,char S7,char S8);\\nstatic long millis(ZoneId zoneId,int year,int month,int dom,int hour,int minute,int second,int nanoOfSecond);\\nstatic long utcSeconds(int year,int month,int dom,int hour,int minute,int second);\\nstatic String toString(Date date);\\nstatic String toString(long timeMillis,boolean timeZone,ZoneId zoneId);\\n }\\npublic interface Fnv {static long hashCode64LCase(String name);\\nstatic long hashCode64(String name);\\nstatic long hashCode64(byte name);\\n }\\npublic interface IOUtils {static int stringSize(int x);\\nstatic int stringSize(long x);\\nstatic void getChars(int i,int index,byte[] buf);\\nstatic void getChars(int i,int index,char[] buf);\\nstatic void getChars(long i,int index,byte[] buf);\\nstatic void getChars(long i,int index,char[] buf);\\nstatic int encodeUTF8(byte[] src,int offset,int len,byte[] dst,int dp);\\nstatic int encodeUTF8(char[] src,int offset,int len,byte[] dst,int dp);\\nstatic boolean isNumber(String str);\\nstatic void close(Closeable x);\\nstatic int decodeUTF8(byte[] src,int off,int len,byte[] dst);\\nstatic int decodeUTF8(byte[] src,int off,int len,char[] dst);\\nstatic int getShanghaiZoneOffsetTotalSeconds(long seconds);\\n }\\npublic interface TypeUtils {static Class<?> getMapping(Type type);\\nstatic Date toDate(Object obj);\\nstatic Instant toInstant(Object obj);\\nstatic T cast(Object obj,Type type);\\nstatic T cast(Object obj,Class targetClass);\\nstatic T cast(Object obj,Class targetClass,ObjectReaderProvider provider);\\nstatic String getTypeName(Class type);\\nstatic Class getMapping(String typeName);\\nstatic BigDecimal toBigDecimal(Object value);\\nstatic BigInteger toBigInteger(Object value);\\nstatic Long toLong(Object value);\\nstatic long toLongValue(Object value);\\nstatic Integer toInteger(Object value);\\nstatic Byte toByte(Object value);\\nstatic byte toByteValue(Object value);\\nstatic Short toShort(Object value);\\nstatic short toShortValue(Object value);\\nstatic int toIntValue(Object value);\\nstatic boolean toBooleanValue(Object value);\\nstatic Boolean toBoolean(Object value);\\nstatic float toFloatValue(Object value);\\nstatic Float toFloat(Object value);\\nstatic double toDoubleValue(Object value);\\nstatic Double toDouble(Object value);\\nstatic int compare(Object a,Object b);\\nstatic Object getDefaultValue(Type paramType);\\nstatic Class loadClass(String className);\\nstatic Class<?> getArrayClass(Class componentClass);\\nstatic Class<?> getClass(Type type);\\nstatic boolean isProxy(Class clazz);\\nstatic Map getInnerMap(Map object);\\n }\\npublic interface ObjectWriter {default long getFeatures();\\ndefault List<FieldWriter> getFieldWriters();\\ndefault FieldWriter getFieldWriter(long hashCode);\\ndefault FieldWriter getFieldWriter(String name);\\ndefault boolean writeTypeInfo(JSONWriter jsonWriter);\\ndefault void writeJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault void writeArrayMappingJSONB(JSONWriter jsonWriter,Object object);\\ndefault void writeArrayMappingJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault void writeArrayMapping(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault boolean hasFilter(JSONWriter jsonWriter);\\ndefault void write(JSONWriter jsonWriter,Object object);\\n void write(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault void writeWithFilter(JSONWriter jsonWriter,Object object);\\ndefault void writeWithFilter(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\n }\\npublic interface ObjectWriterAdapter {public long getFeatures();\\npublic FieldWriter getFieldWriter(long hashCode);\\nfinal boolean hasFilter(JSONWriter jsonWriter);\\npublic void setPropertyFilter(PropertyFilter propertyFilter);\\npublic void setValueFilter(ValueFilter valueFilter);\\npublic void setNameFilter(NameFilter nameFilter);\\npublic void setPropertyPreFilter(PropertyPreFilter propertyPreFilter);\\npublic void writeArrayMappingJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\npublic void writeJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\nprotected void writeClassInfo(JSONWriter jsonWriter);\\npublic void write(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\npublic Map<String,Object> toMap(Object object);\\npublic List<FieldWriter> getFieldWriters();\\npublic boolean writeTypeInfo(JSONWriter jsonWriter);\\npublic void writeWithFilter(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\npublic JSONObject toJSONObject(T object);\\npublic String toString();\\nprotected void errorOnNoneSerializable();\\n }\\n\" }",
        "file_content": "package com.alibaba.fastjson2;\n\nimport com.alibaba.fastjson2.reader.ObjectReader;\nimport com.alibaba.fastjson2.reader.ObjectReaderImplEnum;\nimport com.alibaba.fastjson2.reader.ObjectReaderProvider;\nimport com.alibaba.fastjson2.schema.JSONSchema;\nimport com.alibaba.fastjson2.util.DateUtils;\nimport com.alibaba.fastjson2.util.Fnv;\nimport com.alibaba.fastjson2.util.IOUtils;\nimport com.alibaba.fastjson2.util.TypeUtils;\nimport com.alibaba.fastjson2.writer.ObjectWriter;\nimport com.alibaba.fastjson2.writer.ObjectWriterAdapter;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.function.Function;\n\nimport static com.alibaba.fastjson2.JSONObject.NONE_DIRECT_FEATURES;\nimport static com.alibaba.fastjson2.JSONWriter.Feature.*;\n\npublic class JSONArray\n        extends ArrayList<Object> {\n    private static final long serialVersionUID = 1L;\n\n    static ObjectWriter<JSONArray> arrayWriter;\n\n    /**\n     * default\n     */\n    public JSONArray() {\n        super();\n    }\n\n    /**\n     * @param initialCapacity the initial capacity of the {@link JSONArray}\n     * @throws IllegalArgumentException If the specified initial capacity is negative\n     */\n    public JSONArray(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * @param collection the collection whose elements are to be placed into this {@link JSONArray}\n     * @throws NullPointerException If the specified collection is null\n     */\n    public JSONArray(Collection<?> collection) {\n        super(collection);\n    }\n\n    /**\n     * @param items the array whose elements are to be placed into this {@link JSONArray}\n     * @throws NullPointerException If the specified items is null\n     */\n    public JSONArray(Object... items) {\n        super(items.length);\n        for (Object item : items) {\n            super.add(item);\n        }\n    }\n\n    /**\n     * Replaces the element at the specified position with the specified element\n     *\n     * <pre>{@code\n     *    JSONArray array = new JSONArray();\n     *    array.add(-1); // [-1]\n     *    array.add(2); // [-1,2]\n     *    array.set(0, 1); // [1,2]\n     *    array.set(4, 3); // [1,2,null,null,3]\n     *    array.set(-1, -1); // [1,2,null,null,-1]\n     *    array.set(-2, -2); // [1,2,null,-2,-1]\n     *    array.set(-6, -6); // [-6,1,2,null,-2,-1]\n     * }</pre>\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @since 2.0.3\n     */\n    @Override\n    public Object set(int index, Object element) {\n        int size = super.size();\n        if (index < 0) {\n            index += size;\n            if (index < 0) {\n                // left join elem\n                super.add(0, element);\n                return null;\n            }\n            return super.set(\n                    index, element\n            );\n        }\n\n        if (index < size) {\n            return super.set(\n                    index, element\n            );\n        }\n\n        // max expansion (size + 4096)\n        if (index < size + 4096) {\n            while (index-- != size) {\n                super.add(null);\n            }\n            super.add(element);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the {@link JSONArray} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link JSONArray} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public JSONArray getJSONArray(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof JSONArray) {\n            return (JSONArray) value;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            JSONReader reader = JSONReader.of(str);\n            return JSONFactory.ARRAY_READER.readObject(reader, null, null, 0);\n        }\n\n        if (value instanceof Collection) {\n            return new JSONArray((Collection<?>) value);\n        }\n\n        if (value instanceof Object[]) {\n            return JSONArray.of((Object[]) value);\n        }\n\n        Class<?> valueClass = value.getClass();\n        if (valueClass.isArray()) {\n            int length = Array.getLength(value);\n            JSONArray jsonArray = new JSONArray(length);\n            for (int i = 0; i < length; i++) {\n                Object item = Array.get(value, i);\n                jsonArray.add(item);\n            }\n            return jsonArray;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the {@link JSONObject} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link JSONObject} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public JSONObject getJSONObject(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof JSONObject) {\n            return (JSONObject) value;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            JSONReader reader = JSONReader.of(str);\n            return JSONFactory.OBJECT_READER.readObject(reader, null, null, 0);\n        }\n\n        if (value instanceof Map) {\n            return new JSONObject((Map) value);\n        }\n\n        Class valueClass = value.getClass();\n        ObjectWriter objectWriter = JSONFactory.getDefaultObjectWriterProvider().getObjectWriter(valueClass);\n        if (objectWriter instanceof ObjectWriterAdapter) {\n            ObjectWriterAdapter writerAdapter = (ObjectWriterAdapter) objectWriter;\n            return writerAdapter.toJSONObject(value);\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the {@link String} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link String} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public String getString(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof String) {\n            return (String) value;\n        }\n\n        if (value instanceof Date) {\n            long timeMillis = ((Date) value).getTime();\n            return DateUtils.toString(timeMillis, false, IOUtils.DEFAULT_ZONE_ID);\n        }\n\n        if (value instanceof Boolean\n                || value instanceof Character\n                || value instanceof Number\n                || value instanceof UUID\n                || value instanceof Enum) {\n            return value.toString();\n        }\n\n        return JSON.toJSONString(value);\n    }\n\n    /**\n     * Returns the {@link Double} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Double} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable double\n     * @throws JSONException Unsupported type conversion to {@link Double}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Double getDouble(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Double) {\n            return (Double) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).doubleValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Double.parseDouble(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Double\");\n    }\n\n    /**\n     * Returns a double value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return double\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable double\n     * @throws JSONException Unsupported type conversion to double value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public double getDoubleValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0D;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).doubleValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0D;\n            }\n\n            return Double.parseDouble(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to double value\");\n    }\n\n    /**\n     * Returns the {@link Float} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Float} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable float\n     * @throws JSONException Unsupported type conversion to {@link Float}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Float getFloat(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Float) {\n            return (Float) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).floatValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Float.parseFloat(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Float\");\n    }\n\n    /**\n     * Returns a float value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return float\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable float\n     * @throws JSONException Unsupported type conversion to float value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public float getFloatValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0F;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).floatValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0F;\n            }\n\n            return Float.parseFloat(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to float value\");\n    }\n\n    /**\n     * Returns the {@link Long} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Long} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable long\n     * @throws JSONException Unsupported type conversion to {@link Long}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Long getLong(int index) {\n        Object value = get(index);\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Long) {\n            return ((Long) value);\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).longValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Long.parseLong(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Long\");\n    }\n\n    /**\n     * Returns a long value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return long\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable long\n     * @throws JSONException Unsupported type conversion to long value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public long getLongValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).longValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Long.parseLong(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to long value\");\n    }\n\n    /**\n     * Returns the {@link Integer} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Integer} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable int\n     * @throws JSONException Unsupported type conversion to {@link Integer}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Integer getInteger(int index) {\n        Object value = get(index);\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Integer) {\n            return ((Integer) value);\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Integer.parseInt(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Integer\");\n    }\n\n    /**\n     * Returns an int value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return int\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable int\n     * @throws JSONException Unsupported type conversion to int value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public int getIntValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Integer.parseInt(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to int value\");\n    }\n\n    /**\n     * Returns the {@link Short} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Short} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable short\n     * @throws JSONException Unsupported type conversion to {@link Short}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Short getShort(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Short) {\n            return (Short) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Short.parseShort(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Short\");\n    }\n\n    /**\n     * Returns a short value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return short\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable short\n     * @throws JSONException Unsupported type conversion to short value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public short getShortValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Short.parseShort(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to short value\");\n    }\n\n    /**\n     * Returns the {@link Byte} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Byte} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable byte\n     * @throws JSONException Unsupported type conversion to {@link Byte}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Byte getByte(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).byteValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Byte.parseByte(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Byte\");\n    }\n\n    /**\n     * Returns a byte value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return byte\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable byte\n     * @throws JSONException Unsupported type conversion to byte value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public byte getByteValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).byteValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Byte.parseByte(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to byte value\");\n    }\n\n    /**\n     * Returns the {@link Boolean} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Boolean} or null\n     * @throws JSONException Unsupported type conversion to {@link Boolean}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Boolean getBoolean(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue() == 1;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return \"true\".equalsIgnoreCase(str) || \"1\".equals(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Boolean\");\n    }\n\n    /**\n     * Returns a boolean value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return boolean\n     * @throws JSONException Unsupported type conversion to boolean value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public boolean getBooleanValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return false;\n        }\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue() == 1;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n            return \"true\".equalsIgnoreCase(str) || \"1\".equals(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to boolean value\");\n    }\n\n    /**\n     * Returns the {@link BigInteger} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link BigInteger} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     * @throws JSONException Unsupported type conversion to {@link BigInteger}\n     * @throws NumberFormatException If the value of get is {@link String} and it is not a valid representation of {@link BigInteger}\n     */\n    public BigInteger getBigInteger(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Number) {\n            if (value instanceof BigInteger) {\n                return (BigInteger) value;\n            }\n\n            if (value instanceof BigDecimal) {\n                return ((BigDecimal) value).toBigInteger();\n            }\n\n            long longValue = ((Number) value).longValue();\n            return BigInteger.valueOf(longValue);\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return new BigInteger(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to BigInteger\");\n    }\n\n    /**\n     * Returns the {@link BigDecimal} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link BigDecimal} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     * @throws JSONException Unsupported type conversion to {@link BigDecimal}\n     * @throws NumberFormatException If the value of get is {@link String} and it is not a valid representation of {@link BigDecimal}\n     */\n    public BigDecimal getBigDecimal(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Number) {\n            if (value instanceof BigDecimal) {\n                return (BigDecimal) value;\n            }\n\n            if (value instanceof BigInteger) {\n                return new BigDecimal((BigInteger) value);\n            }\n\n            if (value instanceof Float\n                    || value instanceof Double) {\n                // Floating point number have no cached BigDecimal\n                return new BigDecimal(value.toString());\n            }\n\n            long longValue = ((Number) value).longValue();\n            return BigDecimal.valueOf(longValue);\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return new BigDecimal(str);\n        }\n\n        if (value instanceof Boolean) {\n            return (boolean) value ? BigDecimal.ONE : BigDecimal.ZERO;\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to BigDecimal\");\n    }\n\n    /**\n     * Returns the {@link Date} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Date} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Date getDate(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Date) {\n            return (Date) value;\n        }\n\n        if (value instanceof Number) {\n            long millis = ((Number) value).longValue();\n            if (millis == 0) {\n                return null;\n            }\n            return new Date(millis);\n        }\n\n        return TypeUtils.toDate(value);\n    }\n\n    /**\n     * Returns the {@link Instant} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Instant} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Instant getInstant(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Instant) {\n            return (Instant) value;\n        }\n\n        if (value instanceof Number) {\n            long millis = ((Number) value).longValue();\n            if (millis == 0) {\n                return null;\n            }\n            return Instant.ofEpochMilli(millis);\n        }\n\n        return TypeUtils.toInstant(value);\n    }\n\n    /**\n     * Serialize to JSON {@link String}\n     *\n     * @return JSON {@link String}\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public String toString() {\n        try (JSONWriter writer = JSONWriter.of()) {\n            writer.setRootObject(this);\n            writer.write(this);\n            return writer.toString();\n        }\n    }\n\n    /**\n     * Serialize to JSON {@link String}\n     *\n     * @param features features to be enabled in serialization\n     * @return JSON {@link String}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public String toString(JSONWriter.Feature... features) {\n        try (JSONWriter writer = JSONWriter.of(features)) {\n            if ((writer.context.features & NONE_DIRECT_FEATURES) == 0) {\n                writer.write(this);\n            } else {\n                writer.setRootObject(this);\n                if (arrayWriter == null) {\n                    arrayWriter = writer.getObjectWriter(JSONArray.class, JSONArray.class);\n                }\n                arrayWriter.write(writer, this, null, null, 0);\n            }\n            return writer.toString();\n        }\n    }\n\n    /**\n     * Serialize to JSON {@link String}\n     *\n     * @param features features to be enabled in serialization\n     * @return JSON {@link String}\n     */\n    public String toJSONString(JSONWriter.Feature... features) {\n        return toString(features);\n    }\n\n    /**\n     * Serialize Java Object to JSON {@link String} with specified {@link JSONReader.Feature}s enabled\n     *\n     * @param object Java Object to be serialized into JSON {@link String}\n     * @param features features to be enabled in serialization\n     * @since 2.0.15\n     */\n    public static String toJSONString(Object object, JSONWriter.Feature... features) {\n        return JSON.toJSONString(object, features);\n    }\n\n    /**\n     * Serialize to JSONB bytes\n     *\n     * @param features features to be enabled in serialization\n     * @return JSONB bytes\n     */\n    @SuppressWarnings(\"unchecked\")\n    public byte[] toJSONBBytes(JSONWriter.Feature... features) {\n        try (JSONWriter writer = JSONWriter.ofJSONB(features)) {\n            writer.setRootObject(this);\n            writer.write(this);\n            return writer.getBytes();\n        }\n    }\n\n    /**\n     * Convert this {@link JSONArray} to the specified Object\n     *\n     * <pre>{@code\n     * JSONArray array = ...\n     * List<User> users = array.to(new TypeReference<ArrayList<User>>(){}.getType());\n     * }</pre>\n     *\n     * @param type specify the {@link Type} to be converted\n     * @since 2.0.4\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T to(Type type) {\n        if (type == String.class) {\n            return (T) toString();\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<T> objectReader = provider.getObjectReader(type);\n        return objectReader.createInstance(this);\n    }\n\n    /**\n     * @since 2.0.9\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T to(Class<T> type) {\n        if (type == String.class) {\n            return (T) toString();\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<T> objectReader = provider.getObjectReader(type);\n        return objectReader.createInstance(this);\n    }\n\n    /**\n     * Convert this {@link JSONArray} to the specified Object\n     *\n     * @param type specify the {@link Type} to be converted\n     * @deprecated since 2.0.4, please use {@link #to(Type)}\n     */\n    @Deprecated\n    public <T> T toJavaObject(Type type) {\n        return to(type);\n    }\n\n    /**\n     * Convert all the members of this {@link JSONArray} into the specified Object.\n     *\n     * <pre>{@code\n     * String json = \"[{\\\"id\\\": 1, \\\"name\\\": \\\"fastjson\\\"}, {\\\"id\\\": 2, \\\"name\\\": \\\"fastjson2\\\"}]\";\n     * JSONArray array = JSON.parseArray(json);\n     * List<User> users = array.toList(User.class);\n     * }</pre>\n     *\n     * @param itemClass specify the {@code Class<T>} to be converted\n     * @param features features to be enabled in parsing\n     * @since 2.0.4\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> List<T> toList(Class<T> itemClass, JSONReader.Feature... features) {\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<?> objectReader = provider.getObjectReader(itemClass, fieldBased);\n\n        List<T> list = new ArrayList<>(size());\n        for (int i = 0; i < this.size(); i++) {\n            Object item = this.get(i);\n\n            T classItem;\n            if (item instanceof JSONObject) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item instanceof Map) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item == null || itemClass.isInstance(item)) {\n                classItem = (T) item;\n            } else {\n                Class<?> currentItemClass = item.getClass();\n                Function typeConvert = provider.getTypeConvert(currentItemClass, itemClass);\n                if (typeConvert != null) {\n                    Object converted = typeConvert.apply(item);\n                    list.add((T) converted);\n                    continue;\n                }\n\n                throw new JSONException(\n                        currentItemClass + \" cannot be converted to \" + itemClass\n                );\n            }\n            list.add(classItem);\n        }\n\n        return list;\n    }\n\n    /**\n     * Convert all the members of this {@link JSONArray} into the specified Object.\n     *\n     * <pre>{@code\n     * String json = \"[{\\\"id\\\": 1, \\\"name\\\": \\\"fastjson\\\"}, {\\\"id\\\": 2, \\\"name\\\": \\\"fastjson2\\\"}]\";\n     * JSONArray array = JSON.parseArray(json);\n     * List<User> users = array.toList(User.class);\n     * }</pre>\n     *\n     * @param itemClass specify the {@code Class<T>} to be converted\n     * @param features features to be enabled in parsing\n     * @since 2.0.4\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T[] toArray(Class<T> itemClass, JSONReader.Feature... features) {\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<?> objectReader = provider.getObjectReader(itemClass, fieldBased);\n\n        T[] list = (T[]) Array.newInstance(itemClass, size());\n        for (int i = 0; i < this.size(); i++) {\n            Object item = this.get(i);\n\n            T classItem;\n            if (item instanceof JSONObject) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item instanceof Map) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item == null || itemClass.isInstance(item)) {\n                classItem = (T) item;\n            } else {\n                Class<?> currentItemClass = item.getClass();\n                Function typeConvert = provider.getTypeConvert(currentItemClass, itemClass);\n                if (typeConvert != null) {\n                    Object converted = typeConvert.apply(item);\n                    list[i] = (T) converted;\n                    continue;\n                }\n\n                throw new JSONException(\n                        currentItemClass + \" cannot be converted to \" + itemClass\n                );\n            }\n            list[i] = classItem;\n        }\n\n        return list;\n    }\n\n    /**\n     * Convert all the members of this {@link JSONArray} into the specified Object.\n     *\n     * @param clazz specify the {@code Class<T>} to be converted\n     * @param features features to be enabled in parsing\n     * please use {@link #toList(Class, JSONReader.Feature...)}\n     */\n    public <T> List<T> toJavaList(Class<T> clazz, JSONReader.Feature... features) {\n        return toList(clazz, features);\n    }\n\n    /**\n     * Returns the result of the {@link Type} converter conversion of the element at the specified position in this {@link JSONArray}.\n     *\n     * <pre>{@code\n     * JSONArray array = ...\n     * User user = array.getObject(0, TypeReference<HashMap<String ,User>>(){}.getType());\n     * }</pre>\n     *\n     * @param index index of the element to return\n     * @param type specify the {@link Type} to be converted\n     * @return {@code <T>} or null\n     * @throws JSONException If no suitable conversion method is found\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T getObject(int index, Type type, JSONReader.Feature... features) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        Class<?> valueClass = value.getClass();\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        Function typeConvert = provider.getTypeConvert(valueClass, type);\n\n        if (typeConvert != null) {\n            return (T) typeConvert.apply(value);\n        }\n\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        if (value instanceof Map) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Map) value, featuresValue);\n        }\n\n        if (value instanceof Collection) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Collection) value);\n        }\n\n        Class clazz = TypeUtils.getMapping(type);\n        if (clazz.isInstance(value)) {\n            return (T) value;\n        }\n\n        String json = JSON.toJSONString(value);\n        JSONReader jsonReader = JSONReader.of(json);\n        jsonReader.context.config(features);\n\n        ObjectReader objectReader = provider.getObjectReader(clazz, fieldBased);\n        return (T) objectReader.readObject(jsonReader, null, null, 0);\n    }\n\n    /**\n     * Returns the result of the {@link Type} converter conversion of the element at the specified position in this {@link JSONArray}.\n     * <p>\n     * {@code User user = jsonArray.getObject(0, User.class);}\n     *\n     * @param index index of the element to return\n     * @param type specify the {@link Class} to be converted\n     * @return {@code <T>} or null\n     * @throws JSONException If no suitable conversion method is found\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T getObject(int index, Class<T> type, JSONReader.Feature... features) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        Class<?> valueClass = value.getClass();\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        Function typeConvert = provider.getTypeConvert(valueClass, type);\n\n        if (typeConvert != null) {\n            return (T) typeConvert.apply(value);\n        }\n\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        if (value instanceof Map) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Map) value, featuresValue);\n        }\n\n        if (value instanceof Collection) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Collection) value);\n        }\n\n        Class clazz = TypeUtils.getMapping(type);\n        if (clazz.isInstance(value)) {\n            return (T) value;\n        }\n\n        ObjectReader objectReader = null;\n\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.isEmpty() || \"null\".equals(str)) {\n                return null;\n            }\n\n            if (clazz.isEnum()) {\n                objectReader = provider.getObjectReader(clazz, fieldBased);\n                if (objectReader instanceof ObjectReaderImplEnum) {\n                    long hashCode64 = Fnv.hashCode64(str);\n                    ObjectReaderImplEnum enumReader = (ObjectReaderImplEnum) objectReader;\n                    return (T) enumReader.getEnumByHashCode(hashCode64);\n                }\n            }\n        }\n\n        String json = JSON.toJSONString(value);\n        JSONReader jsonReader = JSONReader.of(json);\n        jsonReader.context.config(features);\n\n        if (objectReader == null) {\n            objectReader = provider.getObjectReader(clazz, fieldBased);\n        }\n\n        T object = (T) objectReader.readObject(jsonReader, null, null, 0L);\n        if (!jsonReader.isEnd()) {\n            throw new JSONException(\"not support input \" + json);\n        }\n        return object;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public <T> T getObject(int index, Function<JSONObject, T> creator) {\n        JSONObject object = getJSONObject(index);\n\n        if (object == null) {\n            return null;\n        }\n\n        return creator.apply(object);\n    }\n\n    /**\n     * Chained addition of elements\n     *\n     * <pre>\n     * JSONArray array = new JSONArray().fluentAdd(1).fluentAdd(2).fluentAdd(3);\n     * </pre>\n     *\n     * @param element element to be appended to this list\n     */\n    public JSONArray fluentAdd(Object element) {\n        add(element);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentClear() {\n        clear();\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentRemove(int index) {\n        remove(index);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentSet(int index, Object element) {\n        set(index, element);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentRemove(Object o) {\n        remove(o);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentRemoveAll(Collection<?> c) {\n        removeAll(c);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentAddAll(Collection<?> c) {\n        addAll(c);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public boolean isValid(JSONSchema schema) {\n        return schema\n                .validate(this)\n                .isSuccess();\n    }\n\n    @Override\n    public Object clone() {\n        return new JSONArray(this);\n    }\n\n    /**\n     * Pack multiple elements as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(1, 2, \"3\", 4F, 5L, 6D, true);\n     * </pre>\n     *\n     * @param items element set\n     */\n    public static JSONArray of(Object... items) {\n        return new JSONArray(items);\n    }\n\n    /**\n     * Pack an element as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(\"fastjson\");\n     * </pre>\n     *\n     * @param item target element\n     */\n    public static JSONArray of(Object item) {\n        JSONArray array = new JSONArray(1);\n        array.add(item);\n        return array;\n    }\n\n    /**\n     * Pack two elements as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(\"fastjson\", 2);\n     * </pre>\n     *\n     * @param first first element\n     * @param second second element\n     */\n    public static JSONArray of(Object first, Object second) {\n        JSONArray array = new JSONArray(2);\n        array.add(first);\n        array.add(second);\n        return array;\n    }\n\n    /**\n     * Pack three elements as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(\"fastjson\", 2, true);\n     * </pre>\n     *\n     * @param first first element\n     * @param second second element\n     * @param third third element\n     */\n    public static JSONArray of(Object first, Object second, Object third) {\n        JSONArray array = new JSONArray(3);\n        array.add(first);\n        array.add(second);\n        array.add(third);\n        return array;\n    }\n\n    /**\n     * Parse JSON {@link String} into {@link JSONArray}\n     *\n     * @param text the JSON {@link String} to be parsed\n     * @param features features to be enabled in parsing\n     */\n    public static JSONArray parseArray(String text, JSONReader.Feature... features) {\n        return JSON.parseArray(text, features);\n    }\n\n    /**\n     * Parse JSON {@link String} into {@link JSONArray}\n     *\n     * @param text the JSON {@link String} to be parsed\n     * @param features features to be enabled in parsing\n     * @since 2.0.13\n     */\n    public static JSONArray parse(String text, JSONReader.Feature... features) {\n        return JSON.parseArray(text, features);\n    }\n}\n"
    },
    {
        "file_name": "PrimeFinder.java",
        "package": "com.alibaba.fastjson2.internal.trove.impl",
        "code": "public static int nextPrime(int desiredCapacity){\n  if (desiredCapacity >= largestPrime) {\n    return largestPrime;\n  }\n  int i=Arrays.binarySearch(primeCapacities,desiredCapacity);\n  if (i < 0) {\n    i=-i - 1;\n  }\n  return primeCapacities[i];\n}\n",
        "class_name": "PrimeFinder",
        "method_name": "nextPrime",
        "all_context": "{ \"class_level\" : \"import java.util.Arrays;\\nint largestPrime;\\nint[] primeCapacities;\\n\", \"repo_level\" : \"\" }",
        "file_content": "//   Copyright (c) 1999 CERN - European Organization for Nuclear Research.\n\n//   Permission to use, copy, modify, distribute and sell this software\n//   and its documentation for any purpose is hereby granted without fee,\n//   provided that the above copyright notice appear in all copies and\n//   that both that copyright notice and this permission notice appear in\n//   supporting documentation. CERN makes no representations about the\n//   suitability of this software for any purpose. It is provided \"as is\"\n//   without expressed or implied warranty.\npackage com.alibaba.fastjson2.internal.trove.impl;\n\nimport java.util.Arrays;\n\n/*\n * Modified for Trove to use the java.util.Arrays sort/search\n * algorithms instead of those provided with colt.\n */\n\n/**\n * Used to keep hash table capacities prime numbers.\n * Not of interest for users; only for implementors of hashtables.\n *\n * <p>Choosing prime numbers as hash table capacities is a good idea\n * to keep them working fast, particularly under hash table\n * expansions.\n *\n * <p>However, JDK 1.2, JGL 3.1 and many other toolkits do nothing to\n * keep capacities prime.  This class provides efficient means to\n * choose prime capacities.\n *\n * <p>Choosing a prime is <tt>O(log 300)</tt> (binary search in a list\n * of 300 ints).  Memory requirements: 1 KB static memory.\n *\n * @author wolfgang.hoschek@cern.ch\n * @version 1.0, 09/24/99\n */\npublic final class PrimeFinder {\n    /**\n     * The largest prime this class can generate; currently equal to\n     * <tt>2,004,663,929</tt>.\n     * <p>\n     * While Integer.MAX_VALUE is in fact the largest representable\n     * prime in the integer space, consumers of this class are\n     * intended to create arrays of size returned from\n     * {@link #nextPrime}. Since the VM needs to reserve a few bytes\n     * for internal overhead, new int[Integer.MAX_VALUE] fails with\n     * an \"exceeds VM limits\" exception. So, we pick the second-largest\n     * prime as the practical largest.\n     */\n    public static final int largestPrime;\n\n    /**\n     * The prime number list consists of 11 chunks.\n     * <p>\n     * Each chunk contains prime numbers.\n     * <p>\n     * A chunk starts with a prime P1. The next element is a prime\n     * P2. P2 is the smallest prime for which holds: P2 >= 2*P1.\n     * <p>\n     * The next element is P3, for which the same holds with respect\n     * to P2, and so on.\n     * <p>\n     * Chunks are chosen such that for any desired capacity >= 1000\n     * the list includes a prime number <= desired capacity * 1.11.\n     * <p>\n     * Therefore, primes can be retrieved which are quite close to any\n     * desired capacity, which in turn avoids wasting memory.\n     * <p>\n     * For example, the list includes\n     * 1039,1117,1201,1277,1361,1439,1523,1597,1759,1907,2081.\n     * <p>\n     * So if you need a prime >= 1040, you will find a prime <=\n     * 1040*1.11=1154.\n     * <p>\n     * Chunks are chosen such that they are optimized for a hashtable\n     * growthfactor of 2.0;\n     * <p>\n     * If your hashtable has such a growthfactor then, after initially\n     * \"rounding to a prime\" upon hashtable construction, it will\n     * later expand to prime capacities such that there exist no\n     * better primes.\n     * <p>\n     * In total these are about 32*10=320 numbers -> 1 KB of static\n     * memory needed.\n     * <p>\n     * If you are stingy, then delete every second or fourth chunk.\n     */\n\n    private static final int[] primeCapacities = {\n            //chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759,\n            411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939,\n            210719881, 421439783, 842879579, 1685759167,\n\n            //chunk #2\n            433, 877, 1759, 3527, 7057, 14143, 28289, 56591, 113189, 226379, 452759, 905551, 1811107,\n            3622219, 7244441, 14488931, 28977863, 57955739, 115911563, 231823147, 463646329, 927292699,\n            1854585413,\n\n            //chunk #3\n            953, 1907, 3821, 7643, 15287, 30577, 61169, 122347, 244703, 489407, 978821, 1957651, 3915341,\n            7830701, 15661423, 31322867, 62645741, 125291483, 250582987, 501165979, 1002331963,\n            2004663929,\n\n            //chunk #4\n            1039, 2081, 4177, 8363, 16729, 33461, 66923, 133853, 267713, 535481, 1070981, 2141977, 4283963,\n            8567929, 17135863, 34271747, 68543509, 137087021, 274174111, 548348231, 1096696463,\n\n            //chunk #5\n            31, 67, 137, 277, 557, 1117, 2237, 4481, 8963, 17929, 35863, 71741, 143483, 286973, 573953,\n            1147921, 2295859, 4591721, 9183457, 18366923, 36733847, 73467739, 146935499, 293871013,\n            587742049, 1175484103,\n\n            //chunk #6\n            599, 1201, 2411, 4831, 9677, 19373, 38747, 77509, 155027, 310081, 620171, 1240361, 2480729,\n            4961459, 9922933, 19845871, 39691759, 79383533, 158767069, 317534141, 635068283, 1270136683,\n\n            //chunk #7\n            311, 631, 1277, 2557, 5119, 10243, 20507, 41017, 82037, 164089, 328213, 656429, 1312867,\n            2625761, 5251529, 10503061, 21006137, 42012281, 84024581, 168049163, 336098327, 672196673,\n            1344393353,\n\n            //chunk #8\n            3, 7, 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,\n            701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,\n            359339171, 718678369, 1437356741,\n\n            //chunk #9\n            43, 89, 179, 359, 719, 1439, 2879, 5779, 11579, 23159, 46327, 92657, 185323, 370661, 741337,\n            1482707, 2965421, 5930887, 11861791, 23723597, 47447201, 94894427, 189788857, 379577741,\n            759155483, 1518310967,\n\n            //chunk #10\n            379, 761, 1523, 3049, 6101, 12203, 24407, 48817, 97649, 195311, 390647, 781301, 1562611,\n            3125257, 6250537, 12501169, 25002389, 50004791, 100009607, 200019221, 400038451, 800076929,\n            1600153859\n    };\n\n    static { //initializer\n        // The above prime numbers are formatted for human readability.\n        // To find numbers fast, we sort them once and for all.\n\n        Arrays.sort(primeCapacities);\n        largestPrime = primeCapacities[primeCapacities.length - 1];\n    }\n\n    /**\n     * Returns a prime number which is <code>&gt;= desiredCapacity</code>\n     * and very close to <code>desiredCapacity</code> (within 11% if\n     * <code>desiredCapacity &gt;= 1000</code>).\n     *\n     * @param desiredCapacity the capacity desired by the user.\n     * @return the capacity which should be used for a hashtable.\n     */\n    public static int nextPrime(int desiredCapacity) {\n        if (desiredCapacity >= largestPrime) {\n            return largestPrime;\n        }\n        int i = Arrays.binarySearch(primeCapacities, desiredCapacity);\n        if (i < 0) {\n            // desired capacity not found, choose next prime greater\n            // than desired capacity\n            i = -i - 1; // remember the semantics of binarySearch...\n        }\n        return primeCapacities[i];\n    }\n}\n"
    },
    {
        "file_name": "ByteVector.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n  if (length + byteLength > data.length) {\n    enlarge(byteLength);\n  }\n  if (byteArrayValue != null) {\n    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);\n  }\n  length+=byteLength;\n  return this;\n}\n",
        "class_name": "ByteVector",
        "method_name": "putByteArray",
        "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n"
    },
    {
        "file_name": "Frame.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "private void pop(final int elements){\n  if (outputStackTop >= elements) {\n    outputStackTop-=elements;\n  }\n else {\n    outputStackStart-=elements - outputStackTop;\n    outputStackTop=0;\n  }\n}\n",
        "class_name": "Frame",
        "method_name": "pop",
        "all_context": "{ \"class_level\" : \"int SAME_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\\nint CHOP_FRAME;\\nint SAME_FRAME_EXTENDED;\\nint APPEND_FRAME;\\nint FULL_FRAME;\\nint ITEM_TOP;\\nint ITEM_INTEGER;\\nint ITEM_FLOAT;\\nint ITEM_DOUBLE;\\nint ITEM_LONG;\\nint ITEM_NULL;\\nint ITEM_UNINITIALIZED_THIS;\\nint ITEM_OBJECT;\\nint ITEM_UNINITIALIZED;\\nint ITEM_ASM_BOOLEAN;\\nint ITEM_ASM_BYTE;\\nint ITEM_ASM_CHAR;\\nint ITEM_ASM_SHORT;\\nint DIM_SIZE;\\nint KIND_SIZE;\\nint FLAGS_SIZE;\\nint VALUE_SIZE;\\nint DIM_SHIFT;\\nint KIND_SHIFT;\\nint FLAGS_SHIFT;\\nint DIM_MASK;\\nint KIND_MASK;\\nint VALUE_MASK;\\nint ARRAY_OF;\\nint ELEMENT_OF;\\nint CONSTANT_KIND;\\nint REFERENCE_KIND;\\nint UNINITIALIZED_KIND;\\nint LOCAL_KIND;\\nint STACK_KIND;\\nint TOP_IF_LONG_OR_DOUBLE_FLAG;\\nint TOP;\\nint BOOLEAN;\\nint BYTE;\\nint CHAR;\\nint SHORT;\\nint INTEGER;\\nint FLOAT;\\nint LONG;\\nint DOUBLE;\\nint NULL;\\nint UNINITIALIZED_THIS;\\nLabel owner;\\nint[] inputLocals;\\nint[] inputStack;\\nint[] outputLocals;\\nint[] outputStack;\\nshort outputStackStart;\\nshort outputStackTop;\\nint initializationCount;\\nint[] initializations;\\nFrame(Label owner);\\ngetAbstractTypeFromDescriptor(SymbolTable symbolTable,String buffer,int offset);\\nsetInputFrameFromDescriptor(SymbolTable symbolTable,int access,String descriptor,int maxLocals);\\ngetLocal(int localIndex);\\nsetLocal(int localIndex,int abstractType);\\npush(SymbolTable symbolTable,String descriptor);\\npop();\\npop(int elements);\\npop(String descriptor);\\naddInitializedType(int abstractType);\\ngetInitializedType(SymbolTable symbolTable,int abstractType);\\nexecute(int opcode,int arg,Symbol argSymbol,SymbolTable symbolTable);\\ngetConcreteOutputType(int abstractOutputType,int numStack);\\nmerge(SymbolTable symbolTable,Frame dstFrame);\\nmerge(SymbolTable symbolTable,int sourceType,int[] dstTypes,int dstIndex);\\naccept(MethodWriter methodWriter);\\npush(int abstractType);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * @author Eric Bruneton\n */\nclass Frame {\n    // Constants used in the StackMapTable attribute.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.\n\n    static final int SAME_FRAME = 0;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n//    static final int RESERVED = 128;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n    static final int CHOP_FRAME = 248;\n    static final int SAME_FRAME_EXTENDED = 251;\n    static final int APPEND_FRAME = 252;\n    static final int FULL_FRAME = 255;\n\n    static final int ITEM_TOP = 0;\n    static final int ITEM_INTEGER = 1;\n    static final int ITEM_FLOAT = 2;\n    static final int ITEM_DOUBLE = 3;\n    static final int ITEM_LONG = 4;\n    static final int ITEM_NULL = 5;\n    static final int ITEM_UNINITIALIZED_THIS = 6;\n    static final int ITEM_OBJECT = 7;\n    static final int ITEM_UNINITIALIZED = 8;\n    // Additional, ASM specific constants used in abstract types below.\n    static final int ITEM_ASM_BOOLEAN = 9;\n    static final int ITEM_ASM_BYTE = 10;\n    static final int ITEM_ASM_CHAR = 11;\n    static final int ITEM_ASM_SHORT = 12;\n\n    // The size and offset in bits of each field of an abstract type.\n\n    static final int DIM_SIZE = 6;\n    static final int KIND_SIZE = 4;\n    static final int FLAGS_SIZE = 2;\n    static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;\n\n    static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;\n    static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;\n    static final int FLAGS_SHIFT = VALUE_SIZE;\n\n    // Bitmasks to get each field of an abstract type.\n\n    static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;\n    static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;\n    static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;\n\n    // Constants to manipulate the DIM field of an abstract type.\n\n    /**\n     * The constant to be added to an abstract type to get one with one more array dimension.\n     */\n    static final int ARRAY_OF = +1 << DIM_SHIFT;\n\n    /**\n     * The constant to be added to an abstract type to get one with one less array dimension.\n     */\n    static final int ELEMENT_OF = -1 << DIM_SHIFT;\n\n    // Possible values for the KIND field of an abstract type.\n\n    static final int CONSTANT_KIND = 1 << KIND_SHIFT;\n    static final int REFERENCE_KIND = 2 << KIND_SHIFT;\n    static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;\n    static final int LOCAL_KIND = 4 << KIND_SHIFT;\n    static final int STACK_KIND = 5 << KIND_SHIFT;\n\n    // Possible flags for the FLAGS field of an abstract type.\n\n    /**\n     * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,\n     * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been\n     * partially overridden with an xSTORE instruction).\n     */\n    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;\n\n    // Useful predefined abstract types (all the possible CONSTANT_KIND types).\n\n    private static final int TOP = CONSTANT_KIND | ITEM_TOP;\n    private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;\n    private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;\n    private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;\n    private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;\n    private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;\n    private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;\n    private static final int LONG = CONSTANT_KIND | ITEM_LONG;\n    private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;\n    private static final int NULL = CONSTANT_KIND | ITEM_NULL;\n    private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;\n\n    // -----------------------------------------------------------------------------------------------\n    // Instance fields\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * The basic block to which these input and output stack map frames correspond.\n     */\n    Label owner;\n\n    /**\n     * The input stack map frame locals. This is an array of abstract types.\n     */\n    private int[] inputLocals;\n\n    /**\n     * The input stack map frame stack. This is an array of abstract types.\n     */\n    int[] inputStack;\n\n    /**\n     * The output stack map frame locals. This is an array of abstract types.\n     */\n    private int[] outputLocals;\n\n    /**\n     * The output stack map frame stack. This is an array of abstract types.\n     */\n    private int[] outputStack;\n\n    /**\n     * The start of the output stack, relatively to the input stack. This offset is always negative or\n     * null. A null offset means that the output stack must be appended to the input stack. A -n\n     * offset means that the first n output stack elements must replace the top n input stack\n     * elements, and that the other elements must be appended to the input stack.\n     */\n    private short outputStackStart;\n\n    /**\n     * The index of the top stack element in {@link #outputStack}.\n     */\n    private short outputStackTop;\n\n    /**\n     * The number of types that are initialized in the basic block. See {@link #initializations}.\n     */\n    private int initializationCount;\n\n    /**\n     * The abstract types that are initialized in the basic block. A constructor invocation on an\n     * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every occurrence</i> of this\n     * type in the local variables and in the operand stack. This cannot be done during the first step\n     * of the algorithm since, during this step, the local variables and the operand stack types are\n     * still abstract. It is therefore necessary to store the abstract types of the constructors which\n     * are invoked in the basic block, in order to do this replacement during the second step of the\n     * algorithm, where the frames are fully computed. Note that this array can contain abstract types\n     * that are relative to the input locals or to the input stack.\n     */\n    private int[] initializations;\n\n    // -----------------------------------------------------------------------------------------------\n    // Constructor\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new Frame.\n     *\n     * @param owner the basic block to which these input and output stack map frames correspond.\n     */\n    Frame(final Label owner) {\n        this.owner = owner;\n    }\n//\n//    /**\n//     * Returns the abstract type corresponding to the internal name of a class.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param internalName the internal name of a class. This must <i>not</i> be an array type\n//     *                     descriptor.\n//     * @return the abstract type value corresponding to the given internal name.\n//     */\n//    static int getAbstractTypeFromInternalName(\n//            final SymbolTable symbolTable, final String internalName) {\n//        return REFERENCE_KIND | symbolTable.addType(internalName);\n//    }\n\n    /**\n     * Returns the abstract type corresponding to the given type descriptor.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param buffer      a string ending with a type descriptor.\n     * @param offset      the start offset of the type descriptor in buffer.\n     * @return the abstract type corresponding to the given type descriptor.\n     */\n    private static int getAbstractTypeFromDescriptor(\n            final SymbolTable symbolTable, final String buffer, final int offset) {\n        String internalName = null;\n        switch (buffer.charAt(offset)) {\n            case 'V':\n                return 0;\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                return INTEGER;\n            case 'F':\n                return FLOAT;\n            case 'J':\n                return LONG;\n            case 'D':\n                return DOUBLE;\n            case 'L':\n                if (offset == 0) {\n                    switch (buffer) {\n                        case \"Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        case \"Ljava/util/List;\":\n                            internalName = \"java/util/List\";\n                            break;\n                        case \"Ljava/lang/reflect/Type;\":\n                            internalName = \"java/lang/reflect/Type\";\n                            break;\n                        case \"Ljava/util/function/Supplier;\":\n                            internalName = \"java/util/function/Supplier\";\n                            break;\n                        case \"Lsun/misc/Unsafe;\":\n                            internalName = \"sun/misc/Unsafe\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONReader;\":\n                            internalName = \"com/alibaba/fastjson2/JSONReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONWriter;\":\n                            internalName = \"com/alibaba/fastjson2/JSONWriter\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                            internalName = \"com/alibaba/fastjson2/writer/FieldWriter\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 2) {\n                    switch (buffer) {\n                        case \"()Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"()Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 3) {\n                    switch (buffer) {\n                        case \"(J)Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"(I)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"(I)Ljava/lang/Integer;\":\n                            internalName = \"java/lang/Integer\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 36) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 54) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 53) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 60) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                            if (offset == 62) {\n                                internalName = \"java/lang/String\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/reflect/Type;Ljava/lang/Object;J)Ljava/lang/Object;\":\n                            if (offset == 79) {\n                                internalName = \"java/lang/Object\";\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                if (internalName == null) {\n                    internalName = buffer.substring(offset + 1, buffer.length() - 1);\n                }\n                return REFERENCE_KIND | symbolTable.addType(internalName);\n            case '[':\n                int elementDescriptorOffset = offset + 1;\n                while (buffer.charAt(elementDescriptorOffset) == '[') {\n                    ++elementDescriptorOffset;\n                }\n                int typeValue;\n                switch (buffer.charAt(elementDescriptorOffset)) {\n                    case 'Z':\n                        typeValue = BOOLEAN;\n                        break;\n                    case 'C':\n                        typeValue = CHAR;\n                        break;\n                    case 'B':\n                        typeValue = BYTE;\n                        break;\n                    case 'S':\n                        typeValue = SHORT;\n                        break;\n                    case 'I':\n                        typeValue = INTEGER;\n                        break;\n                    case 'F':\n                        typeValue = FLOAT;\n                        break;\n                    case 'J':\n                        typeValue = LONG;\n                        break;\n                    case 'D':\n                        typeValue = DOUBLE;\n                        break;\n                    case 'L':\n                        if (offset == 0) {\n                            switch (buffer) {\n                                case \"[Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                                    internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                case \"[Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                                    internalName = \"Lcom/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                        if (internalName == null) {\n                            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\n                        }\n                        typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\n                        break;\n                    default:\n                        throw new IllegalArgumentException();\n                }\n                return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the input frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Sets the input frame from the given method description. This method is used to initialize the\n     * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\n     * attribute).\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param access      the method's access flags.\n     * @param descriptor  the method descriptor.\n     * @param maxLocals   the maximum number of local variables of the method.\n     */\n    final void setInputFrameFromDescriptor(\n            final SymbolTable symbolTable,\n            final int access,\n            final String descriptor,\n            final int maxLocals) {\n        inputLocals = new int[maxLocals];\n        inputStack = new int[0];\n        int inputLocalIndex = 0;\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\n                inputLocals[inputLocalIndex++] =\n                        REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n            } else {\n                inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\n            }\n        }\n        for (Type argumentType : Type.getArgumentTypes(descriptor)) {\n            int abstractType =\n                    getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\n            inputLocals[inputLocalIndex++] = abstractType;\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                inputLocals[inputLocalIndex++] = TOP;\n            }\n        }\n        while (inputLocalIndex < maxLocals) {\n            inputLocals[inputLocalIndex++] = TOP;\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex the index of the local variable whose value must be returned.\n     * @return the abstract type stored at the given local variable index in the output frame.\n     */\n    private int getLocal(final int localIndex) {\n        if (outputLocals == null || localIndex >= outputLocals.length) {\n            // If this local has never been assigned in this basic block, it is still equal to its value\n            // in the input frame.\n            return LOCAL_KIND | localIndex;\n        } else {\n            int abstractType = outputLocals[localIndex];\n            if (abstractType == 0) {\n                // If this local has never been assigned in this basic block, so it is still equal to its\n                // value in the input frame.\n                abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\n            }\n            return abstractType;\n        }\n    }\n\n    /**\n     * Replaces the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex   the index of the output frame local variable that must be set.\n     * @param abstractType the value that must be set.\n     */\n    private void setLocal(final int localIndex, final int abstractType) {\n        // Create and/or resize the output local variables array if necessary.\n        if (outputLocals == null) {\n            outputLocals = new int[10];\n        }\n        int outputLocalsLength = outputLocals.length;\n        if (localIndex >= outputLocalsLength) {\n            int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\n            System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\n            outputLocals = newOutputLocals;\n        }\n        // Set the local variable.\n        outputLocals[localIndex] = abstractType;\n    }\n\n    /**\n     * Pushes the given abstract type on the output frame stack.\n     *\n     * @param abstractType an abstract type.\n     */\n    private void push(final int abstractType) {\n        // Create and/or resize the output stack array if necessary.\n        if (outputStack == null) {\n            outputStack = new int[10];\n        }\n        int outputStackLength = outputStack.length;\n        if (outputStackTop >= outputStackLength) {\n            int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\n            System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\n            outputStack = newOutputStack;\n        }\n        // Pushes the abstract type on the output stack.\n        outputStack[outputStackTop++] = abstractType;\n        // Updates the maximum size reached by the output stack, if needed (note that this size is\n        // relative to the input stack size, which is not known yet).\n        short outputStackSize = (short) (outputStackStart + outputStackTop);\n        if (outputStackSize > owner.outputStackMax) {\n            owner.outputStackMax = outputStackSize;\n        }\n    }\n\n    /**\n     * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param descriptor  a type or method descriptor (in which case its return type is pushed).\n     */\n    private void push(final SymbolTable symbolTable, final String descriptor) {\n        final int typeDescriptorOffset;\n        switch (descriptor) {\n            case \"()J\":\n            case \"()V\":\n            case \"()Z\":\n            case \"()I\":\n            case \"()Ljava/lang/Class;\":\n                typeDescriptorOffset = 2;\n                break;\n            case \"(I)V\":\n            case \"(J)V\":\n            case \"(J)Z\":\n            case \"(I)Ljava/lang/Object;\":\n            case \"(I)Ljava/lang/Integer;\":\n                typeDescriptorOffset = 3;\n                break;\n            case \"(Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 18;\n                break;\n            case \"(Ljava/lang/Object;)Z\":\n            case \"(Ljava/lang/String;)V\":\n            case \"(Ljava/lang/Object;)V\":\n                typeDescriptorOffset = 20;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)Z\":\n                typeDescriptorOffset = 36;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;I)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;J)V\":\n                typeDescriptorOffset = 37;\n                break;\n            case \"(Ljava/lang/Object;Ljava/lang/reflect/Type;)Z\":\n                typeDescriptorOffset = 44;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 52;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;ZLjava/util/List;)V\":\n                typeDescriptorOffset = 53;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                typeDescriptorOffset = 60;\n                break;\n            case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                typeDescriptorOffset = 62;\n                break;\n            case \"(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;JLjava/util/List;)V\":\n                typeDescriptorOffset = 72;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;J)V\":\n                typeDescriptorOffset = 97;\n                break;\n            default:\n                if (descriptor.charAt(0) == '(') {\n                    int currentOffset = 1;\n                    // Skip the argument types, one at a each loop iteration.\n                    while (descriptor.charAt(currentOffset) != ')') {\n                        while (descriptor.charAt(currentOffset) == '[') {\n                            currentOffset++;\n                        }\n                        if (descriptor.charAt(currentOffset++) == 'L') {\n                            // Skip the argument descriptor content.\n                            int semiColumnOffset = descriptor.indexOf(';', currentOffset);\n                            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n                        }\n                    }\n                    typeDescriptorOffset = currentOffset + 1;\n                } else {\n                    typeDescriptorOffset = 0;\n                }\n                break;\n        }\n\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\n        if (abstractType != 0) {\n            push(abstractType);\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                push(TOP);\n            }\n        }\n    }\n\n    /**\n     * Pops an abstract type from the output frame stack and returns its value.\n     *\n     * @return the abstract type that has been popped from the output frame stack.\n     */\n    private int pop() {\n        if (outputStackTop > 0) {\n            return outputStack[--outputStackTop];\n        } else {\n            // If the output frame stack is empty, pop from the input stack.\n            return STACK_KIND | -(--outputStackStart);\n        }\n    }\n\n    /**\n     * Pops the given number of abstract types from the output frame stack.\n     *\n     * @param elements the number of abstract types that must be popped.\n     */\n    private void pop(final int elements) {\n        if (outputStackTop >= elements) {\n            outputStackTop -= elements;\n        } else {\n            // If the number of elements to be popped is greater than the number of elements in the output\n            // stack, clear it, and pop the remaining elements from the input stack.\n            outputStackStart -= elements - outputStackTop;\n            outputStackTop = 0;\n        }\n    }\n\n    /**\n     * Pops as many abstract types from the output frame stack as described by the given descriptor.\n     *\n     * @param descriptor a type or method descriptor (in which case its argument types are popped).\n     */\n    private void pop(final String descriptor) {\n        char firstDescriptorChar = descriptor.charAt(0);\n        if (firstDescriptorChar == '(') {\n            pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n        } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n            pop(2);\n        } else {\n            pop(1);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods to handle uninitialized types\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds an abstract type to the list of types on which a constructor is invoked in the basic\n     * block.\n     *\n     * @param abstractType an abstract type on a which a constructor is invoked.\n     */\n    private void addInitializedType(final int abstractType) {\n        // Create and/or resize the initializations array if necessary.\n        if (initializations == null) {\n            initializations = new int[2];\n        }\n        int initializationsLength = initializations.length;\n        if (initializationCount >= initializationsLength) {\n            int[] newInitializations =\n                    new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\n            System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\n            initializations = newInitializations;\n        }\n        // Store the abstract type.\n        initializations[initializationCount++] = abstractType;\n    }\n\n    /**\n     * Returns the \"initialized\" abstract type corresponding to the given abstract type.\n     *\n     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n     * @param abstractType an abstract type.\n     * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\n     * UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\n     * constructor is invoked in the basic block. Otherwise returns abstractType.\n     */\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\n        if (abstractType == UNINITIALIZED_THIS\n                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n            for (int i = 0; i < initializationCount; ++i) {\n                int initializedType = initializations[i];\n                int dim = initializedType & DIM_MASK;\n                int kind = initializedType & KIND_MASK;\n                int value = initializedType & VALUE_MASK;\n                if (kind == LOCAL_KIND) {\n                    initializedType = dim + inputLocals[value];\n                } else if (kind == STACK_KIND) {\n                    initializedType = dim + inputStack[inputStack.length - value];\n                }\n                if (abstractType == initializedType) {\n                    if (abstractType == UNINITIALIZED_THIS) {\n                        return REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n                    } else {\n                        return REFERENCE_KIND\n                                | symbolTable.addType(symbolTable.typeTable[abstractType & VALUE_MASK].value);\n                    }\n                }\n            }\n        }\n        return abstractType;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Main method, to simulate the execution of each instruction on the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Simulates the action of the given instruction on the output stack frame.\n     *\n     * @param opcode      the opcode of the instruction.\n     * @param arg         the numeric operand of the instruction, if any.\n     * @param argSymbol   the Symbol operand of the instruction, if any.\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     */\n    void execute(\n            final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\n        final int CONSTANT_INTEGER_TAG = 3;\n        final int CONSTANT_FLOAT_TAG = 4;\n        final int CONSTANT_LONG_TAG = 5;\n        final int CONSTANT_DOUBLE_TAG = 6;\n        final int CONSTANT_CLASS_TAG = 7;\n        final int CONSTANT_STRING_TAG = 8;\n        final int CONSTANT_METHOD_HANDLE_TAG = 15;\n        final int CONSTANT_METHOD_TYPE_TAG = 16;\n        final int CONSTANT_DYNAMIC_TAG = 17;\n\n        // Abstract types popped from the stack or read from local variables.\n        int abstractType1;\n        int abstractType2;\n        int abstractType3;\n        int abstractType4;\n        switch (opcode) {\n            case Opcodes.NOP:\n            case Opcodes.INEG:\n            case Opcodes.LNEG:\n            case Opcodes.FNEG:\n            case Opcodes.DNEG:\n            case Opcodes.I2B:\n            case Opcodes.I2C:\n            case Opcodes.I2S:\n            case Opcodes.GOTO:\n            case Opcodes.RETURN:\n                break;\n            case Opcodes.ACONST_NULL:\n                push(NULL);\n                break;\n            case Opcodes.ICONST_M1:\n            case Opcodes.ICONST_0:\n            case Opcodes.ICONST_1:\n            case Opcodes.ICONST_2:\n            case Opcodes.ICONST_3:\n            case Opcodes.ICONST_4:\n            case Opcodes.ICONST_5:\n            case Opcodes.BIPUSH:\n            case Opcodes.SIPUSH:\n            case Opcodes.ILOAD:\n                push(INTEGER);\n                break;\n            case Opcodes.LCONST_0:\n            case Opcodes.LCONST_1:\n            case Opcodes.LLOAD:\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.FCONST_0:\n            case Opcodes.FCONST_1:\n            case Opcodes.FCONST_2:\n            case Opcodes.FLOAD:\n                push(FLOAT);\n                break;\n            case Opcodes.DCONST_0:\n            case Opcodes.DCONST_1:\n            case Opcodes.DLOAD:\n                push(DOUBLE);\n                push(TOP);\n                break;\n            case Opcodes.LDC:\n                switch (argSymbol.tag) {\n                    case CONSTANT_INTEGER_TAG:\n                        push(INTEGER);\n                        break;\n                    case CONSTANT_LONG_TAG:\n                        push(LONG);\n                        push(TOP);\n                        break;\n                    case CONSTANT_FLOAT_TAG:\n                        push(FLOAT);\n                        break;\n                    case CONSTANT_DOUBLE_TAG:\n                        push(DOUBLE);\n                        push(TOP);\n                        break;\n                    case CONSTANT_CLASS_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\n                        break;\n                    case CONSTANT_STRING_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\n                        break;\n                    case CONSTANT_METHOD_TYPE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\n                        break;\n                    case CONSTANT_METHOD_HANDLE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\n                        break;\n                    case CONSTANT_DYNAMIC_TAG:\n                        push(symbolTable, argSymbol.value);\n                        break;\n                    default:\n                        throw new AssertionError();\n                }\n                break;\n            case Opcodes.ALOAD:\n                push(getLocal(arg));\n                break;\n            case Opcodes.LALOAD:\n            case Opcodes.D2L:\n                pop(2);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.AALOAD:\n                pop(1);\n                abstractType1 = pop();\n                push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\n                break;\n            case Opcodes.ISTORE:\n            case Opcodes.FSTORE:\n            case Opcodes.ASTORE:\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.LSTORE:\n            case Opcodes.DSTORE:\n                pop(1);\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                setLocal(arg + 1, TOP);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.POP:\n            case Opcodes.IFEQ:\n            case Opcodes.IFNE:\n            case Opcodes.IFLT:\n            case Opcodes.IFGE:\n            case Opcodes.IFGT:\n            case Opcodes.IFLE:\n            case Opcodes.IRETURN:\n            case Opcodes.FRETURN:\n            case Opcodes.ARETURN:\n            case Opcodes.TABLESWITCH:\n            case Opcodes.LOOKUPSWITCH:\n            case Opcodes.ATHROW:\n            case Opcodes.MONITORENTER:\n            case Opcodes.MONITOREXIT:\n            case Opcodes.IFNULL:\n            case Opcodes.IFNONNULL:\n                pop(1);\n                break;\n            case Opcodes.POP2:\n            case Opcodes.IF_ICMPEQ:\n            case Opcodes.IF_ICMPNE:\n            case Opcodes.IF_ICMPLT:\n            case Opcodes.IF_ICMPGE:\n            case Opcodes.IF_ICMPGT:\n            case Opcodes.IF_ICMPLE:\n            case Opcodes.IF_ACMPEQ:\n            case Opcodes.IF_ACMPNE:\n            case Opcodes.LRETURN:\n            case Opcodes.DRETURN:\n                pop(2);\n                break;\n            case Opcodes.DUP:\n                abstractType1 = pop();\n                push(abstractType1);\n                push(abstractType1);\n                break;\n            case Opcodes.DUP2:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType2);\n                push(abstractType1);\n                push(abstractType2);\n                push(abstractType1);\n                break;\n            case Opcodes.SWAP:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType1);\n                push(abstractType2);\n                break;\n            case Opcodes.IALOAD:\n            case Opcodes.BALOAD:\n            case Opcodes.CALOAD:\n            case Opcodes.SALOAD:\n            case Opcodes.IADD:\n            case Opcodes.ISUB:\n            case Opcodes.IMUL:\n            case Opcodes.IDIV:\n            case Opcodes.IREM:\n            case Opcodes.IAND:\n            case Opcodes.IOR:\n            case Opcodes.IXOR:\n            case Opcodes.ISHL:\n            case Opcodes.ISHR:\n            case Opcodes.IUSHR:\n            case Opcodes.L2I:\n            case Opcodes.D2I:\n            case Opcodes.FCMPL:\n            case Opcodes.FCMPG:\n                pop(2);\n                push(INTEGER);\n                break;\n            case Opcodes.LADD:\n            case Opcodes.LSUB:\n            case Opcodes.LMUL:\n            case Opcodes.LDIV:\n            case Opcodes.LREM:\n            case Opcodes.LAND:\n            case Opcodes.LOR:\n            case Opcodes.LXOR:\n                pop(4);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.LSHL:\n            case Opcodes.LSHR:\n            case Opcodes.LUSHR:\n                pop(3);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.IINC:\n                setLocal(arg, INTEGER);\n                break;\n            case Opcodes.F2I:\n            case Opcodes.ARRAYLENGTH:\n            case Opcodes.INSTANCEOF:\n                pop(1);\n                push(INTEGER);\n                break;\n            case Opcodes.LCMP:\n            case Opcodes.DCMPL:\n            case Opcodes.DCMPG:\n                pop(4);\n                push(INTEGER);\n                break;\n            case Opcodes.GETSTATIC:\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTSTATIC:\n                pop(argSymbol.value);\n                break;\n            case Opcodes.GETFIELD:\n                pop(1);\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTFIELD:\n                pop(argSymbol.value);\n                pop();\n                break;\n            case Opcodes.INVOKEVIRTUAL:\n            case Opcodes.INVOKESPECIAL:\n            case Opcodes.INVOKESTATIC:\n            case Opcodes.INVOKEINTERFACE:\n                pop(argSymbol.value);\n                if (opcode != Opcodes.INVOKESTATIC) {\n                    abstractType1 = pop();\n                    if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\n                        addInitializedType(abstractType1);\n                    }\n                }\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.NEW:\n                push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\n                break;\n            case Opcodes.CHECKCAST:\n                String castType = argSymbol.value;\n                pop();\n                if (castType.charAt(0) == '[') {\n                    push(symbolTable, castType);\n                } else {\n                    push(REFERENCE_KIND | symbolTable.addType(castType));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame merging methods, used in the second step of the stack map frame computation algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the concrete output type corresponding to a given abstract output type.\n     *\n     * @param abstractOutputType an abstract output type.\n     * @param numStack           the size of the input stack, used to resolve abstract output types of\n     *                           STACK_KIND kind.\n     * @return the concrete output type corresponding to 'abstractOutputType'.\n     */\n    private int getConcreteOutputType(final int abstractOutputType, final int numStack) {\n        int dim = abstractOutputType & DIM_MASK;\n        int kind = abstractOutputType & KIND_MASK;\n        if (kind == LOCAL_KIND) {\n            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else if (kind == STACK_KIND) {\n            // By definition, a STACK_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else {\n            return abstractOutputType;\n        }\n    }\n\n    final boolean merge(\n            final SymbolTable symbolTable, final Frame dstFrame) {\n        boolean frameChanged = false;\n\n        // Compute the concrete types of the local variables at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the local variables in the input frame of dstFrame.\n        int numLocal = inputLocals.length;\n        int numStack = inputStack.length;\n        if (dstFrame.inputLocals == null) {\n            dstFrame.inputLocals = new int[numLocal];\n            frameChanged = true;\n        }\n        for (int i = 0; i < numLocal; ++i) {\n            int concreteOutputType;\n            if (outputLocals != null && i < outputLocals.length) {\n                int abstractOutputType = outputLocals[i];\n                if (abstractOutputType == 0) {\n                    // If the local variable has never been assigned in this basic block, it is equal to its\n                    // value at the beginning of the block.\n                    concreteOutputType = inputLocals[i];\n                } else {\n                    concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n                }\n            } else {\n                // If the local variable has never been assigned in this basic block, it is equal to its\n                // value at the beginning of the block.\n                concreteOutputType = inputLocals[i];\n            }\n            // concreteOutputType might be an uninitialized type from the input locals or from the input\n            // stack. However, if a constructor has been called for this class type in the basic block,\n            // then this type is no longer uninitialized at the end of basic block.\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\n        }\n\n        // Compute the concrete types of the stack operands at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the stack operands in the input frame of dstFrame.\n        int numInputStack = inputStack.length + outputStackStart;\n        if (dstFrame.inputStack == null) {\n            dstFrame.inputStack = new int[numInputStack + outputStackTop];\n            frameChanged = true;\n        }\n        // First, do this for the stack operands that have not been popped in the basic block\n        // corresponding to this frame, and which are therefore equal to their value in the input\n        // frame (except for uninitialized types, which may have been initialized).\n        for (int i = 0; i < numInputStack; ++i) {\n            int concreteOutputType = inputStack[i];\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\n        }\n        // Then, do this for the stack operands that have pushed in the basic block (this code is the\n        // same as the one above for local variables).\n        for (int i = 0; i < outputStackTop; ++i) {\n            int abstractOutputType = outputStack[i];\n            int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |=\n                    merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\n        }\n        return frameChanged;\n    }\n\n    /**\n     * Merges the type at the given index in the given abstract type array with the given type.\n     * Returns {@literal true} if the type array has been modified by this operation.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param sourceType  the abstract type with which the abstract type array element must be merged.\n     *                    This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link\n     *                    #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.\n     * @param dstTypes    an array of abstract types. These types should be of {@link #CONSTANT_KIND},\n     *                    {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal\n     *                    null} array dimensions.\n     * @param dstIndex    the index of the type that must be merged in dstTypes.\n     * @return {@literal true} if the type array has been modified by this operation.\n     */\n    private static boolean merge(\n            final SymbolTable symbolTable,\n            final int sourceType,\n            final int[] dstTypes,\n            final int dstIndex) {\n        int dstType = dstTypes[dstIndex];\n        if (dstType == sourceType) {\n            // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\n            return false;\n        }\n        int srcType = sourceType;\n        if ((sourceType & ~DIM_MASK) == NULL) {\n            if (dstType == NULL) {\n                return false;\n            }\n            srcType = NULL;\n        }\n        if (dstType == 0) {\n            // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\n            dstTypes[dstIndex] = srcType;\n            return true;\n        }\n        int mergedType;\n        if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\n            // If dstType is a reference type of any array dimension.\n            if (srcType == NULL) {\n                // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\n                return false;\n            } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\n                // If srcType has the same array dimension and the same kind as dstType.\n                if ((dstType & KIND_MASK) == REFERENCE_KIND) {\n                    // If srcType and dstType are reference types with the same array dimension,\n                    // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\n                    mergedType =\n                            (srcType & DIM_MASK)\n                                    | REFERENCE_KIND\n                                    | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\n                } else {\n                    // If srcType and dstType are array types of equal dimension but different element types,\n                    // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\n                    int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\n                    mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n                }\n            } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\n                // If srcType is any other reference or array type,\n                // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\n                // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\n                // with a non reference element type (and similarly for dstDim).\n                int srcDim = srcType & DIM_MASK;\n                if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\n                    srcDim = ELEMENT_OF + srcDim;\n                }\n                int dstDim = dstType & DIM_MASK;\n                if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\n                    dstDim = ELEMENT_OF + dstDim;\n                }\n                mergedType =\n                        Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n            } else {\n                // If srcType is any other type, merge(srcType, dstType) = TOP.\n                mergedType = TOP;\n            }\n        } else if (dstType == NULL) {\n            // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\n            // an array type or a reference type.\n            mergedType =\n                    (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\n        } else {\n            // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\n            mergedType = TOP;\n        }\n        if (mergedType != dstType) {\n            dstTypes[dstIndex] = mergedType;\n            return true;\n        }\n        return false;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame output methods, to generate StackMapFrame attributes\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\n     * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\n     * {@link MethodWriter#visitFrameEnd} methods.\n     *\n     * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\n     *                     Frame}.\n     */\n    final void accept(final MethodWriter methodWriter) {\n        // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\n        // all trailing TOP types.\n        int[] localTypes = inputLocals;\n        int numLocal = 0;\n        int numTrailingTop = 0;\n        int i = 0;\n        while (i < localTypes.length) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            if (localType == TOP) {\n                numTrailingTop++;\n            } else {\n                numLocal += numTrailingTop + 1;\n                numTrailingTop = 0;\n            }\n        }\n        // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\n        int[] stackTypes = inputStack;\n        int numStack = 0;\n        i = 0;\n        while (i < stackTypes.length) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            numStack++;\n        }\n        // Visit the frame and its content.\n        int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\n        i = 0;\n        while (numLocal-- > 0) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, localType);\n        }\n        i = 0;\n        while (numStack-- > 0) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, stackType);\n        }\n        methodWriter.visitFrameEnd();\n    }\n//\n//    /**\n//     * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\n//     * format used in StackMapTable attributes.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\n//     *                     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n//     * @param output       where the abstract type must be put.\n//     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n//     * 4.7.4</a>\n//     */\n//    static void putAbstractType(\n//            final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\n//        int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\n//        if (arrayDimensions == 0) {\n//            int typeValue = abstractType & VALUE_MASK;\n//            switch (abstractType & KIND_MASK) {\n//                case CONSTANT_KIND:\n//                    output.putByte(typeValue);\n//                    break;\n//                case REFERENCE_KIND:\n//                    output\n//                            .putByte(ITEM_OBJECT)\n//                            .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, symbolTable.typeTable[typeValue].value).index);\n//                    break;\n//                case UNINITIALIZED_KIND:\n//                    output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.typeTable[typeValue].data);\n//                    break;\n//                default:\n//                    throw new AssertionError();\n//            }\n//        } else {\n//            // Case of an array type, we need to build its descriptor first.\n//            StringBuilder typeDescriptor = new StringBuilder();\n//            while (arrayDimensions-- > 0) {\n//                typeDescriptor.append('[');\n//            }\n//            if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\n//                typeDescriptor\n//                        .append('L')\n//                        .append(symbolTable.typeTable[abstractType & VALUE_MASK].value)\n//                        .append(';');\n//            } else {\n//                switch (abstractType & VALUE_MASK) {\n//                    case Frame.ITEM_ASM_BOOLEAN:\n//                        typeDescriptor.append('Z');\n//                        break;\n//                    case Frame.ITEM_ASM_BYTE:\n//                        typeDescriptor.append('B');\n//                        break;\n//                    case Frame.ITEM_ASM_CHAR:\n//                        typeDescriptor.append('C');\n//                        break;\n//                    case Frame.ITEM_ASM_SHORT:\n//                        typeDescriptor.append('S');\n//                        break;\n//                    case Frame.ITEM_INTEGER:\n//                        typeDescriptor.append('I');\n//                        break;\n//                    case Frame.ITEM_FLOAT:\n//                        typeDescriptor.append('F');\n//                        break;\n//                    case Frame.ITEM_LONG:\n//                        typeDescriptor.append('J');\n//                        break;\n//                    case Frame.ITEM_DOUBLE:\n//                        typeDescriptor.append('D');\n//                        break;\n//                    default:\n//                        throw new AssertionError();\n//                }\n//            }\n//            output\n//                    .putByte(ITEM_OBJECT)\n//                    .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, typeDescriptor.toString()).index);\n//        }\n//    }\n}\n"
    },
    {
        "file_name": "ByteVector.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "public ByteVector putInt(final int intValue){\n  int currentLength=length;\n  if (currentLength + 4 > data.length) {\n    enlarge(4);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)(intValue >>> 24);\n  currentData[currentLength++]=(byte)(intValue >>> 16);\n  currentData[currentLength++]=(byte)(intValue >>> 8);\n  currentData[currentLength++]=(byte)intValue;\n  length=currentLength;\n  return this;\n}\n",
        "class_name": "ByteVector",
        "method_name": "putInt",
        "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n"
    },
    {
        "file_name": "Frame.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "private void pop(final String descriptor){\n  char firstDescriptorChar=descriptor.charAt(0);\n  if (firstDescriptorChar == '(') {\n    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n  }\n else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n    pop(2);\n  }\n else {\n    pop(1);\n  }\n}\n",
        "class_name": "Frame",
        "method_name": "pop",
        "all_context": "{ \"class_level\" : \"int SAME_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME;\\nint SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\\nint CHOP_FRAME;\\nint SAME_FRAME_EXTENDED;\\nint APPEND_FRAME;\\nint FULL_FRAME;\\nint ITEM_TOP;\\nint ITEM_INTEGER;\\nint ITEM_FLOAT;\\nint ITEM_DOUBLE;\\nint ITEM_LONG;\\nint ITEM_NULL;\\nint ITEM_UNINITIALIZED_THIS;\\nint ITEM_OBJECT;\\nint ITEM_UNINITIALIZED;\\nint ITEM_ASM_BOOLEAN;\\nint ITEM_ASM_BYTE;\\nint ITEM_ASM_CHAR;\\nint ITEM_ASM_SHORT;\\nint DIM_SIZE;\\nint KIND_SIZE;\\nint FLAGS_SIZE;\\nint VALUE_SIZE;\\nint DIM_SHIFT;\\nint KIND_SHIFT;\\nint FLAGS_SHIFT;\\nint DIM_MASK;\\nint KIND_MASK;\\nint VALUE_MASK;\\nint ARRAY_OF;\\nint ELEMENT_OF;\\nint CONSTANT_KIND;\\nint REFERENCE_KIND;\\nint UNINITIALIZED_KIND;\\nint LOCAL_KIND;\\nint STACK_KIND;\\nint TOP_IF_LONG_OR_DOUBLE_FLAG;\\nint TOP;\\nint BOOLEAN;\\nint BYTE;\\nint CHAR;\\nint SHORT;\\nint INTEGER;\\nint FLOAT;\\nint LONG;\\nint DOUBLE;\\nint NULL;\\nint UNINITIALIZED_THIS;\\nLabel owner;\\nint[] inputLocals;\\nint[] inputStack;\\nint[] outputLocals;\\nint[] outputStack;\\nshort outputStackStart;\\nshort outputStackTop;\\nint initializationCount;\\nint[] initializations;\\nFrame(Label owner);\\ngetAbstractTypeFromDescriptor(SymbolTable symbolTable,String buffer,int offset);\\nsetInputFrameFromDescriptor(SymbolTable symbolTable,int access,String descriptor,int maxLocals);\\ngetLocal(int localIndex);\\nsetLocal(int localIndex,int abstractType);\\npush(SymbolTable symbolTable,String descriptor);\\npop();\\npop(int elements);\\npop(String descriptor);\\naddInitializedType(int abstractType);\\ngetInitializedType(SymbolTable symbolTable,int abstractType);\\nexecute(int opcode,int arg,Symbol argSymbol,SymbolTable symbolTable);\\ngetConcreteOutputType(int abstractOutputType,int numStack);\\nmerge(SymbolTable symbolTable,Frame dstFrame);\\nmerge(SymbolTable symbolTable,int sourceType,int[] dstTypes,int dstIndex);\\naccept(MethodWriter methodWriter);\\npush(int abstractType);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * @author Eric Bruneton\n */\nclass Frame {\n    // Constants used in the StackMapTable attribute.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.\n\n    static final int SAME_FRAME = 0;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n//    static final int RESERVED = 128;\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n    static final int CHOP_FRAME = 248;\n    static final int SAME_FRAME_EXTENDED = 251;\n    static final int APPEND_FRAME = 252;\n    static final int FULL_FRAME = 255;\n\n    static final int ITEM_TOP = 0;\n    static final int ITEM_INTEGER = 1;\n    static final int ITEM_FLOAT = 2;\n    static final int ITEM_DOUBLE = 3;\n    static final int ITEM_LONG = 4;\n    static final int ITEM_NULL = 5;\n    static final int ITEM_UNINITIALIZED_THIS = 6;\n    static final int ITEM_OBJECT = 7;\n    static final int ITEM_UNINITIALIZED = 8;\n    // Additional, ASM specific constants used in abstract types below.\n    static final int ITEM_ASM_BOOLEAN = 9;\n    static final int ITEM_ASM_BYTE = 10;\n    static final int ITEM_ASM_CHAR = 11;\n    static final int ITEM_ASM_SHORT = 12;\n\n    // The size and offset in bits of each field of an abstract type.\n\n    static final int DIM_SIZE = 6;\n    static final int KIND_SIZE = 4;\n    static final int FLAGS_SIZE = 2;\n    static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;\n\n    static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;\n    static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;\n    static final int FLAGS_SHIFT = VALUE_SIZE;\n\n    // Bitmasks to get each field of an abstract type.\n\n    static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;\n    static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;\n    static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;\n\n    // Constants to manipulate the DIM field of an abstract type.\n\n    /**\n     * The constant to be added to an abstract type to get one with one more array dimension.\n     */\n    static final int ARRAY_OF = +1 << DIM_SHIFT;\n\n    /**\n     * The constant to be added to an abstract type to get one with one less array dimension.\n     */\n    static final int ELEMENT_OF = -1 << DIM_SHIFT;\n\n    // Possible values for the KIND field of an abstract type.\n\n    static final int CONSTANT_KIND = 1 << KIND_SHIFT;\n    static final int REFERENCE_KIND = 2 << KIND_SHIFT;\n    static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;\n    static final int LOCAL_KIND = 4 << KIND_SHIFT;\n    static final int STACK_KIND = 5 << KIND_SHIFT;\n\n    // Possible flags for the FLAGS field of an abstract type.\n\n    /**\n     * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,\n     * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been\n     * partially overridden with an xSTORE instruction).\n     */\n    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;\n\n    // Useful predefined abstract types (all the possible CONSTANT_KIND types).\n\n    private static final int TOP = CONSTANT_KIND | ITEM_TOP;\n    private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;\n    private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;\n    private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;\n    private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;\n    private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;\n    private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;\n    private static final int LONG = CONSTANT_KIND | ITEM_LONG;\n    private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;\n    private static final int NULL = CONSTANT_KIND | ITEM_NULL;\n    private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;\n\n    // -----------------------------------------------------------------------------------------------\n    // Instance fields\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * The basic block to which these input and output stack map frames correspond.\n     */\n    Label owner;\n\n    /**\n     * The input stack map frame locals. This is an array of abstract types.\n     */\n    private int[] inputLocals;\n\n    /**\n     * The input stack map frame stack. This is an array of abstract types.\n     */\n    int[] inputStack;\n\n    /**\n     * The output stack map frame locals. This is an array of abstract types.\n     */\n    private int[] outputLocals;\n\n    /**\n     * The output stack map frame stack. This is an array of abstract types.\n     */\n    private int[] outputStack;\n\n    /**\n     * The start of the output stack, relatively to the input stack. This offset is always negative or\n     * null. A null offset means that the output stack must be appended to the input stack. A -n\n     * offset means that the first n output stack elements must replace the top n input stack\n     * elements, and that the other elements must be appended to the input stack.\n     */\n    private short outputStackStart;\n\n    /**\n     * The index of the top stack element in {@link #outputStack}.\n     */\n    private short outputStackTop;\n\n    /**\n     * The number of types that are initialized in the basic block. See {@link #initializations}.\n     */\n    private int initializationCount;\n\n    /**\n     * The abstract types that are initialized in the basic block. A constructor invocation on an\n     * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every occurrence</i> of this\n     * type in the local variables and in the operand stack. This cannot be done during the first step\n     * of the algorithm since, during this step, the local variables and the operand stack types are\n     * still abstract. It is therefore necessary to store the abstract types of the constructors which\n     * are invoked in the basic block, in order to do this replacement during the second step of the\n     * algorithm, where the frames are fully computed. Note that this array can contain abstract types\n     * that are relative to the input locals or to the input stack.\n     */\n    private int[] initializations;\n\n    // -----------------------------------------------------------------------------------------------\n    // Constructor\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new Frame.\n     *\n     * @param owner the basic block to which these input and output stack map frames correspond.\n     */\n    Frame(final Label owner) {\n        this.owner = owner;\n    }\n//\n//    /**\n//     * Returns the abstract type corresponding to the internal name of a class.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param internalName the internal name of a class. This must <i>not</i> be an array type\n//     *                     descriptor.\n//     * @return the abstract type value corresponding to the given internal name.\n//     */\n//    static int getAbstractTypeFromInternalName(\n//            final SymbolTable symbolTable, final String internalName) {\n//        return REFERENCE_KIND | symbolTable.addType(internalName);\n//    }\n\n    /**\n     * Returns the abstract type corresponding to the given type descriptor.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param buffer      a string ending with a type descriptor.\n     * @param offset      the start offset of the type descriptor in buffer.\n     * @return the abstract type corresponding to the given type descriptor.\n     */\n    private static int getAbstractTypeFromDescriptor(\n            final SymbolTable symbolTable, final String buffer, final int offset) {\n        String internalName = null;\n        switch (buffer.charAt(offset)) {\n            case 'V':\n                return 0;\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                return INTEGER;\n            case 'F':\n                return FLOAT;\n            case 'J':\n                return LONG;\n            case 'D':\n                return DOUBLE;\n            case 'L':\n                if (offset == 0) {\n                    switch (buffer) {\n                        case \"Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        case \"Ljava/util/List;\":\n                            internalName = \"java/util/List\";\n                            break;\n                        case \"Ljava/lang/reflect/Type;\":\n                            internalName = \"java/lang/reflect/Type\";\n                            break;\n                        case \"Ljava/util/function/Supplier;\":\n                            internalName = \"java/util/function/Supplier\";\n                            break;\n                        case \"Lsun/misc/Unsafe;\":\n                            internalName = \"sun/misc/Unsafe\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONReader;\":\n                            internalName = \"com/alibaba/fastjson2/JSONReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/JSONWriter;\":\n                            internalName = \"com/alibaba/fastjson2/JSONWriter\";\n                            break;\n                        case \"Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                            internalName = \"com/alibaba/fastjson2/writer/FieldWriter\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 2) {\n                    switch (buffer) {\n                        case \"()Ljava/lang/Class;\":\n                            internalName = \"java/lang/Class\";\n                            break;\n                        case \"()Ljava/lang/String;\":\n                            internalName = \"java/lang/String\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 3) {\n                    switch (buffer) {\n                        case \"(J)Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                            break;\n                        case \"(I)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        case \"(I)Ljava/lang/Integer;\":\n                            internalName = \"java/lang/Integer\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 36) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else if (offset == 54) {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Lcom/alibaba/fastjson2/reader/ObjectReader;\":\n                            internalName = \"com/alibaba/fastjson2/reader/ObjectReader\";\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/Class;J)Ljava/lang/Object;\":\n                            internalName = \"java/lang/Object\";\n                            break;\n                        default:\n                            break;\n                    }\n                } else {\n                    switch (buffer) {\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 53) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                            if (offset == 60) {\n                                internalName = \"com/alibaba/fastjson2/writer/ObjectWriter\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                            if (offset == 62) {\n                                internalName = \"java/lang/String\";\n                            }\n                            break;\n                        case \"(Lcom/alibaba/fastjson2/JSONReader;Ljava/lang/reflect/Type;Ljava/lang/Object;J)Ljava/lang/Object;\":\n                            if (offset == 79) {\n                                internalName = \"java/lang/Object\";\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                if (internalName == null) {\n                    internalName = buffer.substring(offset + 1, buffer.length() - 1);\n                }\n                return REFERENCE_KIND | symbolTable.addType(internalName);\n            case '[':\n                int elementDescriptorOffset = offset + 1;\n                while (buffer.charAt(elementDescriptorOffset) == '[') {\n                    ++elementDescriptorOffset;\n                }\n                int typeValue;\n                switch (buffer.charAt(elementDescriptorOffset)) {\n                    case 'Z':\n                        typeValue = BOOLEAN;\n                        break;\n                    case 'C':\n                        typeValue = CHAR;\n                        break;\n                    case 'B':\n                        typeValue = BYTE;\n                        break;\n                    case 'S':\n                        typeValue = SHORT;\n                        break;\n                    case 'I':\n                        typeValue = INTEGER;\n                        break;\n                    case 'F':\n                        typeValue = FLOAT;\n                        break;\n                    case 'J':\n                        typeValue = LONG;\n                        break;\n                    case 'D':\n                        typeValue = DOUBLE;\n                        break;\n                    case 'L':\n                        if (offset == 0) {\n                            switch (buffer) {\n                                case \"[Lcom/alibaba/fastjson2/writer/FieldWriter;\":\n                                    internalName = \"com/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                case \"[Lcom/alibaba/fastjson2/reader/FieldReader;\":\n                                    internalName = \"Lcom/alibaba/fastjson2/reader/FieldReader\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                        if (internalName == null) {\n                            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\n                        }\n                        typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\n                        break;\n                    default:\n                        throw new IllegalArgumentException();\n                }\n                return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the input frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Sets the input frame from the given method description. This method is used to initialize the\n     * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\n     * attribute).\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param access      the method's access flags.\n     * @param descriptor  the method descriptor.\n     * @param maxLocals   the maximum number of local variables of the method.\n     */\n    final void setInputFrameFromDescriptor(\n            final SymbolTable symbolTable,\n            final int access,\n            final String descriptor,\n            final int maxLocals) {\n        inputLocals = new int[maxLocals];\n        inputStack = new int[0];\n        int inputLocalIndex = 0;\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\n                inputLocals[inputLocalIndex++] =\n                        REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n            } else {\n                inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\n            }\n        }\n        for (Type argumentType : Type.getArgumentTypes(descriptor)) {\n            int abstractType =\n                    getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\n            inputLocals[inputLocalIndex++] = abstractType;\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                inputLocals[inputLocalIndex++] = TOP;\n            }\n        }\n        while (inputLocalIndex < maxLocals) {\n            inputLocals[inputLocalIndex++] = TOP;\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods related to the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex the index of the local variable whose value must be returned.\n     * @return the abstract type stored at the given local variable index in the output frame.\n     */\n    private int getLocal(final int localIndex) {\n        if (outputLocals == null || localIndex >= outputLocals.length) {\n            // If this local has never been assigned in this basic block, it is still equal to its value\n            // in the input frame.\n            return LOCAL_KIND | localIndex;\n        } else {\n            int abstractType = outputLocals[localIndex];\n            if (abstractType == 0) {\n                // If this local has never been assigned in this basic block, so it is still equal to its\n                // value in the input frame.\n                abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\n            }\n            return abstractType;\n        }\n    }\n\n    /**\n     * Replaces the abstract type stored at the given local variable index in the output frame.\n     *\n     * @param localIndex   the index of the output frame local variable that must be set.\n     * @param abstractType the value that must be set.\n     */\n    private void setLocal(final int localIndex, final int abstractType) {\n        // Create and/or resize the output local variables array if necessary.\n        if (outputLocals == null) {\n            outputLocals = new int[10];\n        }\n        int outputLocalsLength = outputLocals.length;\n        if (localIndex >= outputLocalsLength) {\n            int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\n            System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\n            outputLocals = newOutputLocals;\n        }\n        // Set the local variable.\n        outputLocals[localIndex] = abstractType;\n    }\n\n    /**\n     * Pushes the given abstract type on the output frame stack.\n     *\n     * @param abstractType an abstract type.\n     */\n    private void push(final int abstractType) {\n        // Create and/or resize the output stack array if necessary.\n        if (outputStack == null) {\n            outputStack = new int[10];\n        }\n        int outputStackLength = outputStack.length;\n        if (outputStackTop >= outputStackLength) {\n            int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\n            System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\n            outputStack = newOutputStack;\n        }\n        // Pushes the abstract type on the output stack.\n        outputStack[outputStackTop++] = abstractType;\n        // Updates the maximum size reached by the output stack, if needed (note that this size is\n        // relative to the input stack size, which is not known yet).\n        short outputStackSize = (short) (outputStackStart + outputStackTop);\n        if (outputStackSize > owner.outputStackMax) {\n            owner.outputStackMax = outputStackSize;\n        }\n    }\n\n    /**\n     * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param descriptor  a type or method descriptor (in which case its return type is pushed).\n     */\n    private void push(final SymbolTable symbolTable, final String descriptor) {\n        final int typeDescriptorOffset;\n        switch (descriptor) {\n            case \"()J\":\n            case \"()V\":\n            case \"()Z\":\n            case \"()I\":\n            case \"()Ljava/lang/Class;\":\n                typeDescriptorOffset = 2;\n                break;\n            case \"(I)V\":\n            case \"(J)V\":\n            case \"(J)Z\":\n            case \"(I)Ljava/lang/Object;\":\n            case \"(I)Ljava/lang/Integer;\":\n                typeDescriptorOffset = 3;\n                break;\n            case \"(Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 18;\n                break;\n            case \"(Ljava/lang/Object;)Z\":\n            case \"(Ljava/lang/String;)V\":\n            case \"(Ljava/lang/Object;)V\":\n                typeDescriptorOffset = 20;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;)Z\":\n                typeDescriptorOffset = 36;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;I)V\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;J)V\":\n                typeDescriptorOffset = 37;\n                break;\n            case \"(Ljava/lang/Object;Ljava/lang/reflect/Type;)Z\":\n                typeDescriptorOffset = 44;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Enum;)V\":\n                typeDescriptorOffset = 52;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Class;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;ZLjava/util/List;)V\":\n                typeDescriptorOffset = 53;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/reflect/Type;)Lcom/alibaba/fastjson2/writer/ObjectWriter;\":\n                typeDescriptorOffset = 60;\n                break;\n            case \"(Lcom/alibaba/fastjson2/writer/FieldWriter;Ljava/lang/Object;)Ljava/lang/String;\":\n                typeDescriptorOffset = 62;\n                break;\n            case \"(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;JLjava/util/List;)V\":\n                typeDescriptorOffset = 72;\n                break;\n            case \"(Lcom/alibaba/fastjson2/JSONWriter;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;J)V\":\n                typeDescriptorOffset = 97;\n                break;\n            default:\n                if (descriptor.charAt(0) == '(') {\n                    int currentOffset = 1;\n                    // Skip the argument types, one at a each loop iteration.\n                    while (descriptor.charAt(currentOffset) != ')') {\n                        while (descriptor.charAt(currentOffset) == '[') {\n                            currentOffset++;\n                        }\n                        if (descriptor.charAt(currentOffset++) == 'L') {\n                            // Skip the argument descriptor content.\n                            int semiColumnOffset = descriptor.indexOf(';', currentOffset);\n                            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n                        }\n                    }\n                    typeDescriptorOffset = currentOffset + 1;\n                } else {\n                    typeDescriptorOffset = 0;\n                }\n                break;\n        }\n\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\n        if (abstractType != 0) {\n            push(abstractType);\n            if (abstractType == LONG || abstractType == DOUBLE) {\n                push(TOP);\n            }\n        }\n    }\n\n    /**\n     * Pops an abstract type from the output frame stack and returns its value.\n     *\n     * @return the abstract type that has been popped from the output frame stack.\n     */\n    private int pop() {\n        if (outputStackTop > 0) {\n            return outputStack[--outputStackTop];\n        } else {\n            // If the output frame stack is empty, pop from the input stack.\n            return STACK_KIND | -(--outputStackStart);\n        }\n    }\n\n    /**\n     * Pops the given number of abstract types from the output frame stack.\n     *\n     * @param elements the number of abstract types that must be popped.\n     */\n    private void pop(final int elements) {\n        if (outputStackTop >= elements) {\n            outputStackTop -= elements;\n        } else {\n            // If the number of elements to be popped is greater than the number of elements in the output\n            // stack, clear it, and pop the remaining elements from the input stack.\n            outputStackStart -= elements - outputStackTop;\n            outputStackTop = 0;\n        }\n    }\n\n    /**\n     * Pops as many abstract types from the output frame stack as described by the given descriptor.\n     *\n     * @param descriptor a type or method descriptor (in which case its argument types are popped).\n     */\n    private void pop(final String descriptor) {\n        char firstDescriptorChar = descriptor.charAt(0);\n        if (firstDescriptorChar == '(') {\n            pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n        } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n            pop(2);\n        } else {\n            pop(1);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Methods to handle uninitialized types\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds an abstract type to the list of types on which a constructor is invoked in the basic\n     * block.\n     *\n     * @param abstractType an abstract type on a which a constructor is invoked.\n     */\n    private void addInitializedType(final int abstractType) {\n        // Create and/or resize the initializations array if necessary.\n        if (initializations == null) {\n            initializations = new int[2];\n        }\n        int initializationsLength = initializations.length;\n        if (initializationCount >= initializationsLength) {\n            int[] newInitializations =\n                    new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\n            System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\n            initializations = newInitializations;\n        }\n        // Store the abstract type.\n        initializations[initializationCount++] = abstractType;\n    }\n\n    /**\n     * Returns the \"initialized\" abstract type corresponding to the given abstract type.\n     *\n     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n     * @param abstractType an abstract type.\n     * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\n     * UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\n     * constructor is invoked in the basic block. Otherwise returns abstractType.\n     */\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\n        if (abstractType == UNINITIALIZED_THIS\n                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n            for (int i = 0; i < initializationCount; ++i) {\n                int initializedType = initializations[i];\n                int dim = initializedType & DIM_MASK;\n                int kind = initializedType & KIND_MASK;\n                int value = initializedType & VALUE_MASK;\n                if (kind == LOCAL_KIND) {\n                    initializedType = dim + inputLocals[value];\n                } else if (kind == STACK_KIND) {\n                    initializedType = dim + inputStack[inputStack.length - value];\n                }\n                if (abstractType == initializedType) {\n                    if (abstractType == UNINITIALIZED_THIS) {\n                        return REFERENCE_KIND | symbolTable.addType(symbolTable.className);\n                    } else {\n                        return REFERENCE_KIND\n                                | symbolTable.addType(symbolTable.typeTable[abstractType & VALUE_MASK].value);\n                    }\n                }\n            }\n        }\n        return abstractType;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Main method, to simulate the execution of each instruction on the output frame\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Simulates the action of the given instruction on the output stack frame.\n     *\n     * @param opcode      the opcode of the instruction.\n     * @param arg         the numeric operand of the instruction, if any.\n     * @param argSymbol   the Symbol operand of the instruction, if any.\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     */\n    void execute(\n            final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\n        final int CONSTANT_INTEGER_TAG = 3;\n        final int CONSTANT_FLOAT_TAG = 4;\n        final int CONSTANT_LONG_TAG = 5;\n        final int CONSTANT_DOUBLE_TAG = 6;\n        final int CONSTANT_CLASS_TAG = 7;\n        final int CONSTANT_STRING_TAG = 8;\n        final int CONSTANT_METHOD_HANDLE_TAG = 15;\n        final int CONSTANT_METHOD_TYPE_TAG = 16;\n        final int CONSTANT_DYNAMIC_TAG = 17;\n\n        // Abstract types popped from the stack or read from local variables.\n        int abstractType1;\n        int abstractType2;\n        int abstractType3;\n        int abstractType4;\n        switch (opcode) {\n            case Opcodes.NOP:\n            case Opcodes.INEG:\n            case Opcodes.LNEG:\n            case Opcodes.FNEG:\n            case Opcodes.DNEG:\n            case Opcodes.I2B:\n            case Opcodes.I2C:\n            case Opcodes.I2S:\n            case Opcodes.GOTO:\n            case Opcodes.RETURN:\n                break;\n            case Opcodes.ACONST_NULL:\n                push(NULL);\n                break;\n            case Opcodes.ICONST_M1:\n            case Opcodes.ICONST_0:\n            case Opcodes.ICONST_1:\n            case Opcodes.ICONST_2:\n            case Opcodes.ICONST_3:\n            case Opcodes.ICONST_4:\n            case Opcodes.ICONST_5:\n            case Opcodes.BIPUSH:\n            case Opcodes.SIPUSH:\n            case Opcodes.ILOAD:\n                push(INTEGER);\n                break;\n            case Opcodes.LCONST_0:\n            case Opcodes.LCONST_1:\n            case Opcodes.LLOAD:\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.FCONST_0:\n            case Opcodes.FCONST_1:\n            case Opcodes.FCONST_2:\n            case Opcodes.FLOAD:\n                push(FLOAT);\n                break;\n            case Opcodes.DCONST_0:\n            case Opcodes.DCONST_1:\n            case Opcodes.DLOAD:\n                push(DOUBLE);\n                push(TOP);\n                break;\n            case Opcodes.LDC:\n                switch (argSymbol.tag) {\n                    case CONSTANT_INTEGER_TAG:\n                        push(INTEGER);\n                        break;\n                    case CONSTANT_LONG_TAG:\n                        push(LONG);\n                        push(TOP);\n                        break;\n                    case CONSTANT_FLOAT_TAG:\n                        push(FLOAT);\n                        break;\n                    case CONSTANT_DOUBLE_TAG:\n                        push(DOUBLE);\n                        push(TOP);\n                        break;\n                    case CONSTANT_CLASS_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\n                        break;\n                    case CONSTANT_STRING_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\n                        break;\n                    case CONSTANT_METHOD_TYPE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\n                        break;\n                    case CONSTANT_METHOD_HANDLE_TAG:\n                        push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\n                        break;\n                    case CONSTANT_DYNAMIC_TAG:\n                        push(symbolTable, argSymbol.value);\n                        break;\n                    default:\n                        throw new AssertionError();\n                }\n                break;\n            case Opcodes.ALOAD:\n                push(getLocal(arg));\n                break;\n            case Opcodes.LALOAD:\n            case Opcodes.D2L:\n                pop(2);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.AALOAD:\n                pop(1);\n                abstractType1 = pop();\n                push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\n                break;\n            case Opcodes.ISTORE:\n            case Opcodes.FSTORE:\n            case Opcodes.ASTORE:\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.LSTORE:\n            case Opcodes.DSTORE:\n                pop(1);\n                abstractType1 = pop();\n                setLocal(arg, abstractType1);\n                setLocal(arg + 1, TOP);\n                if (arg > 0) {\n                    int previousLocalType = getLocal(arg - 1);\n                    if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n                        setLocal(arg - 1, TOP);\n                    } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n                            || (previousLocalType & KIND_MASK) == STACK_KIND) {\n                        // The type of the previous local variable is not known yet, but if it later appears\n                        // to be LONG or DOUBLE, we should then use TOP instead.\n                        setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n                    }\n                }\n                break;\n            case Opcodes.POP:\n            case Opcodes.IFEQ:\n            case Opcodes.IFNE:\n            case Opcodes.IFLT:\n            case Opcodes.IFGE:\n            case Opcodes.IFGT:\n            case Opcodes.IFLE:\n            case Opcodes.IRETURN:\n            case Opcodes.FRETURN:\n            case Opcodes.ARETURN:\n            case Opcodes.TABLESWITCH:\n            case Opcodes.LOOKUPSWITCH:\n            case Opcodes.ATHROW:\n            case Opcodes.MONITORENTER:\n            case Opcodes.MONITOREXIT:\n            case Opcodes.IFNULL:\n            case Opcodes.IFNONNULL:\n                pop(1);\n                break;\n            case Opcodes.POP2:\n            case Opcodes.IF_ICMPEQ:\n            case Opcodes.IF_ICMPNE:\n            case Opcodes.IF_ICMPLT:\n            case Opcodes.IF_ICMPGE:\n            case Opcodes.IF_ICMPGT:\n            case Opcodes.IF_ICMPLE:\n            case Opcodes.IF_ACMPEQ:\n            case Opcodes.IF_ACMPNE:\n            case Opcodes.LRETURN:\n            case Opcodes.DRETURN:\n                pop(2);\n                break;\n            case Opcodes.DUP:\n                abstractType1 = pop();\n                push(abstractType1);\n                push(abstractType1);\n                break;\n            case Opcodes.DUP2:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType2);\n                push(abstractType1);\n                push(abstractType2);\n                push(abstractType1);\n                break;\n            case Opcodes.SWAP:\n                abstractType1 = pop();\n                abstractType2 = pop();\n                push(abstractType1);\n                push(abstractType2);\n                break;\n            case Opcodes.IALOAD:\n            case Opcodes.BALOAD:\n            case Opcodes.CALOAD:\n            case Opcodes.SALOAD:\n            case Opcodes.IADD:\n            case Opcodes.ISUB:\n            case Opcodes.IMUL:\n            case Opcodes.IDIV:\n            case Opcodes.IREM:\n            case Opcodes.IAND:\n            case Opcodes.IOR:\n            case Opcodes.IXOR:\n            case Opcodes.ISHL:\n            case Opcodes.ISHR:\n            case Opcodes.IUSHR:\n            case Opcodes.L2I:\n            case Opcodes.D2I:\n            case Opcodes.FCMPL:\n            case Opcodes.FCMPG:\n                pop(2);\n                push(INTEGER);\n                break;\n            case Opcodes.LADD:\n            case Opcodes.LSUB:\n            case Opcodes.LMUL:\n            case Opcodes.LDIV:\n            case Opcodes.LREM:\n            case Opcodes.LAND:\n            case Opcodes.LOR:\n            case Opcodes.LXOR:\n                pop(4);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.LSHL:\n            case Opcodes.LSHR:\n            case Opcodes.LUSHR:\n                pop(3);\n                push(LONG);\n                push(TOP);\n                break;\n            case Opcodes.IINC:\n                setLocal(arg, INTEGER);\n                break;\n            case Opcodes.F2I:\n            case Opcodes.ARRAYLENGTH:\n            case Opcodes.INSTANCEOF:\n                pop(1);\n                push(INTEGER);\n                break;\n            case Opcodes.LCMP:\n            case Opcodes.DCMPL:\n            case Opcodes.DCMPG:\n                pop(4);\n                push(INTEGER);\n                break;\n            case Opcodes.GETSTATIC:\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTSTATIC:\n                pop(argSymbol.value);\n                break;\n            case Opcodes.GETFIELD:\n                pop(1);\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.PUTFIELD:\n                pop(argSymbol.value);\n                pop();\n                break;\n            case Opcodes.INVOKEVIRTUAL:\n            case Opcodes.INVOKESPECIAL:\n            case Opcodes.INVOKESTATIC:\n            case Opcodes.INVOKEINTERFACE:\n                pop(argSymbol.value);\n                if (opcode != Opcodes.INVOKESTATIC) {\n                    abstractType1 = pop();\n                    if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\n                        addInitializedType(abstractType1);\n                    }\n                }\n                push(symbolTable, argSymbol.value);\n                break;\n            case Opcodes.NEW:\n                push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\n                break;\n            case Opcodes.CHECKCAST:\n                String castType = argSymbol.value;\n                pop();\n                if (castType.charAt(0) == '[') {\n                    push(symbolTable, castType);\n                } else {\n                    push(REFERENCE_KIND | symbolTable.addType(castType));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame merging methods, used in the second step of the stack map frame computation algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the concrete output type corresponding to a given abstract output type.\n     *\n     * @param abstractOutputType an abstract output type.\n     * @param numStack           the size of the input stack, used to resolve abstract output types of\n     *                           STACK_KIND kind.\n     * @return the concrete output type corresponding to 'abstractOutputType'.\n     */\n    private int getConcreteOutputType(final int abstractOutputType, final int numStack) {\n        int dim = abstractOutputType & DIM_MASK;\n        int kind = abstractOutputType & KIND_MASK;\n        if (kind == LOCAL_KIND) {\n            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else if (kind == STACK_KIND) {\n            // By definition, a STACK_KIND type designates the concrete type of a local variable at\n            // the beginning of the basic block corresponding to this frame (which is known when\n            // this method is called, but was not when the abstract type was computed).\n            int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\n            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n                concreteOutputType = TOP;\n            }\n            return concreteOutputType;\n        } else {\n            return abstractOutputType;\n        }\n    }\n\n    final boolean merge(\n            final SymbolTable symbolTable, final Frame dstFrame) {\n        boolean frameChanged = false;\n\n        // Compute the concrete types of the local variables at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the local variables in the input frame of dstFrame.\n        int numLocal = inputLocals.length;\n        int numStack = inputStack.length;\n        if (dstFrame.inputLocals == null) {\n            dstFrame.inputLocals = new int[numLocal];\n            frameChanged = true;\n        }\n        for (int i = 0; i < numLocal; ++i) {\n            int concreteOutputType;\n            if (outputLocals != null && i < outputLocals.length) {\n                int abstractOutputType = outputLocals[i];\n                if (abstractOutputType == 0) {\n                    // If the local variable has never been assigned in this basic block, it is equal to its\n                    // value at the beginning of the block.\n                    concreteOutputType = inputLocals[i];\n                } else {\n                    concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n                }\n            } else {\n                // If the local variable has never been assigned in this basic block, it is equal to its\n                // value at the beginning of the block.\n                concreteOutputType = inputLocals[i];\n            }\n            // concreteOutputType might be an uninitialized type from the input locals or from the input\n            // stack. However, if a constructor has been called for this class type in the basic block,\n            // then this type is no longer uninitialized at the end of basic block.\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\n        }\n\n        // Compute the concrete types of the stack operands at the end of the basic block corresponding\n        // to this frame, by resolving its abstract output types, and merge these concrete types with\n        // those of the stack operands in the input frame of dstFrame.\n        int numInputStack = inputStack.length + outputStackStart;\n        if (dstFrame.inputStack == null) {\n            dstFrame.inputStack = new int[numInputStack + outputStackTop];\n            frameChanged = true;\n        }\n        // First, do this for the stack operands that have not been popped in the basic block\n        // corresponding to this frame, and which are therefore equal to their value in the input\n        // frame (except for uninitialized types, which may have been initialized).\n        for (int i = 0; i < numInputStack; ++i) {\n            int concreteOutputType = inputStack[i];\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\n        }\n        // Then, do this for the stack operands that have pushed in the basic block (this code is the\n        // same as the one above for local variables).\n        for (int i = 0; i < outputStackTop; ++i) {\n            int abstractOutputType = outputStack[i];\n            int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n            if (initializations != null) {\n                concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n            }\n            frameChanged |=\n                    merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\n        }\n        return frameChanged;\n    }\n\n    /**\n     * Merges the type at the given index in the given abstract type array with the given type.\n     * Returns {@literal true} if the type array has been modified by this operation.\n     *\n     * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n     * @param sourceType  the abstract type with which the abstract type array element must be merged.\n     *                    This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link\n     *                    #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.\n     * @param dstTypes    an array of abstract types. These types should be of {@link #CONSTANT_KIND},\n     *                    {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal\n     *                    null} array dimensions.\n     * @param dstIndex    the index of the type that must be merged in dstTypes.\n     * @return {@literal true} if the type array has been modified by this operation.\n     */\n    private static boolean merge(\n            final SymbolTable symbolTable,\n            final int sourceType,\n            final int[] dstTypes,\n            final int dstIndex) {\n        int dstType = dstTypes[dstIndex];\n        if (dstType == sourceType) {\n            // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\n            return false;\n        }\n        int srcType = sourceType;\n        if ((sourceType & ~DIM_MASK) == NULL) {\n            if (dstType == NULL) {\n                return false;\n            }\n            srcType = NULL;\n        }\n        if (dstType == 0) {\n            // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\n            dstTypes[dstIndex] = srcType;\n            return true;\n        }\n        int mergedType;\n        if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\n            // If dstType is a reference type of any array dimension.\n            if (srcType == NULL) {\n                // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\n                return false;\n            } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\n                // If srcType has the same array dimension and the same kind as dstType.\n                if ((dstType & KIND_MASK) == REFERENCE_KIND) {\n                    // If srcType and dstType are reference types with the same array dimension,\n                    // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\n                    mergedType =\n                            (srcType & DIM_MASK)\n                                    | REFERENCE_KIND\n                                    | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\n                } else {\n                    // If srcType and dstType are array types of equal dimension but different element types,\n                    // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\n                    int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\n                    mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n                }\n            } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\n                // If srcType is any other reference or array type,\n                // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\n                // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\n                // with a non reference element type (and similarly for dstDim).\n                int srcDim = srcType & DIM_MASK;\n                if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\n                    srcDim = ELEMENT_OF + srcDim;\n                }\n                int dstDim = dstType & DIM_MASK;\n                if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\n                    dstDim = ELEMENT_OF + dstDim;\n                }\n                mergedType =\n                        Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n            } else {\n                // If srcType is any other type, merge(srcType, dstType) = TOP.\n                mergedType = TOP;\n            }\n        } else if (dstType == NULL) {\n            // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\n            // an array type or a reference type.\n            mergedType =\n                    (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\n        } else {\n            // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\n            mergedType = TOP;\n        }\n        if (mergedType != dstType) {\n            dstTypes[dstIndex] = mergedType;\n            return true;\n        }\n        return false;\n    }\n\n    // -----------------------------------------------------------------------------------------------\n    // Frame output methods, to generate StackMapFrame attributes\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\n     * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\n     * {@link MethodWriter#visitFrameEnd} methods.\n     *\n     * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\n     *                     Frame}.\n     */\n    final void accept(final MethodWriter methodWriter) {\n        // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\n        // all trailing TOP types.\n        int[] localTypes = inputLocals;\n        int numLocal = 0;\n        int numTrailingTop = 0;\n        int i = 0;\n        while (i < localTypes.length) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            if (localType == TOP) {\n                numTrailingTop++;\n            } else {\n                numLocal += numTrailingTop + 1;\n                numTrailingTop = 0;\n            }\n        }\n        // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\n        int[] stackTypes = inputStack;\n        int numStack = 0;\n        i = 0;\n        while (i < stackTypes.length) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            numStack++;\n        }\n        // Visit the frame and its content.\n        int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\n        i = 0;\n        while (numLocal-- > 0) {\n            int localType = localTypes[i];\n            i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, localType);\n        }\n        i = 0;\n        while (numStack-- > 0) {\n            int stackType = stackTypes[i];\n            i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n            methodWriter.visitAbstractType(frameIndex++, stackType);\n        }\n        methodWriter.visitFrameEnd();\n    }\n//\n//    /**\n//     * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\n//     * format used in StackMapTable attributes.\n//     *\n//     * @param symbolTable  the type table to use to lookup and store type {@link Symbol}.\n//     * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\n//     *                     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n//     * @param output       where the abstract type must be put.\n//     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n//     * 4.7.4</a>\n//     */\n//    static void putAbstractType(\n//            final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\n//        int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\n//        if (arrayDimensions == 0) {\n//            int typeValue = abstractType & VALUE_MASK;\n//            switch (abstractType & KIND_MASK) {\n//                case CONSTANT_KIND:\n//                    output.putByte(typeValue);\n//                    break;\n//                case REFERENCE_KIND:\n//                    output\n//                            .putByte(ITEM_OBJECT)\n//                            .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, symbolTable.typeTable[typeValue].value).index);\n//                    break;\n//                case UNINITIALIZED_KIND:\n//                    output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.typeTable[typeValue].data);\n//                    break;\n//                default:\n//                    throw new AssertionError();\n//            }\n//        } else {\n//            // Case of an array type, we need to build its descriptor first.\n//            StringBuilder typeDescriptor = new StringBuilder();\n//            while (arrayDimensions-- > 0) {\n//                typeDescriptor.append('[');\n//            }\n//            if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\n//                typeDescriptor\n//                        .append('L')\n//                        .append(symbolTable.typeTable[abstractType & VALUE_MASK].value)\n//                        .append(';');\n//            } else {\n//                switch (abstractType & VALUE_MASK) {\n//                    case Frame.ITEM_ASM_BOOLEAN:\n//                        typeDescriptor.append('Z');\n//                        break;\n//                    case Frame.ITEM_ASM_BYTE:\n//                        typeDescriptor.append('B');\n//                        break;\n//                    case Frame.ITEM_ASM_CHAR:\n//                        typeDescriptor.append('C');\n//                        break;\n//                    case Frame.ITEM_ASM_SHORT:\n//                        typeDescriptor.append('S');\n//                        break;\n//                    case Frame.ITEM_INTEGER:\n//                        typeDescriptor.append('I');\n//                        break;\n//                    case Frame.ITEM_FLOAT:\n//                        typeDescriptor.append('F');\n//                        break;\n//                    case Frame.ITEM_LONG:\n//                        typeDescriptor.append('J');\n//                        break;\n//                    case Frame.ITEM_DOUBLE:\n//                        typeDescriptor.append('D');\n//                        break;\n//                    default:\n//                        throw new AssertionError();\n//                }\n//            }\n//            output\n//                    .putByte(ITEM_OBJECT)\n//                    .putShort(symbolTable.addConstantUtf8Reference(/*CONSTANT_CLASS_TAG*/ 7, typeDescriptor.toString()).index);\n//        }\n//    }\n}\n"
    },
    {
        "file_name": "ByteVector.java",
        "package": "com.alibaba.fastjson2.internal.asm",
        "code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n  int currentLength=length;\n  if (currentLength + 2 > data.length) {\n    enlarge(2);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)byteValue1;\n  currentData[currentLength++]=(byte)byteValue2;\n  length=currentLength;\n  return this;\n}\n",
        "class_name": "ByteVector",
        "method_name": "put11",
        "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
        "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n"
    }
]