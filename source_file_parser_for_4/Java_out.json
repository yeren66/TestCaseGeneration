[
    {
        "project_name": "Java",
        "file_name": "ConnectedComponent.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/ConnectedComponent.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.graphs",
        "docstring": "/**\n     * Main method used for counting the connected components. Iterates through\n     * the array of nodes to do a depth first search to get all nodes of the\n     * graph from the actual node. These nodes are added to the array\n     * markedNodes and will be ignored if they are chosen in the nodeList.\n     *\n     * @return returns the amount of unconnected graphs\n     */",
        "source_code": "\npublic int countGraphs() {\n    int count = 0;\n    Set<Node> markedNodes = new HashSet<Node>();\n\n    for (Node n : nodeList) {\n        if (!markedNodes.contains(n)) {\n            markedNodes.add(n);\n            markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n            count++;\n        }\n    }\n\n    return count;\n}\n",
        "class_name": "Graph",
        "method_name": "countGraphs",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A class that counts the number of different connected components in a graph\n *\n * @author Lukas Keul, Florian Mercks\n */\nclass Graph<E extends Comparable<E>> {\n\n    class Node {\n\n        E name;\n\n        public Node(E name) {\n            this.name = name;\n        }\n    }\n\n    class Edge {\n\n        Node startNode, endNode;\n\n        public Edge(Node startNode, Node endNode) {\n            this.startNode = startNode;\n            this.endNode = endNode;\n        }\n    }\n\n    ArrayList<Edge> edgeList;\n    ArrayList<Node> nodeList;\n\n    public Graph() {\n        edgeList = new ArrayList<Edge>();\n        nodeList = new ArrayList<Node>();\n    }\n\n    /**\n     * Adds a new Edge to the graph. If the nodes aren't yet in nodeList, they\n     * will be added to it.\n     *\n     * @param startNode the starting Node from the edge\n     * @param endNode the ending Node from the edge\n     */\n    public void addEdge(E startNode, E endNode) {\n        Node start = null, end = null;\n        for (Node node : nodeList) {\n            if (startNode.compareTo(node.name) == 0) {\n                start = node;\n            } else if (endNode.compareTo(node.name) == 0) {\n                end = node;\n            }\n        }\n        if (start == null) {\n            start = new Node(startNode);\n            nodeList.add(start);\n        }\n        if (end == null) {\n            end = new Node(endNode);\n            nodeList.add(end);\n        }\n\n        edgeList.add(new Edge(start, end));\n    }\n\n    /**\n     * Main method used for counting the connected components. Iterates through\n     * the array of nodes to do a depth first search to get all nodes of the\n     * graph from the actual node. These nodes are added to the array\n     * markedNodes and will be ignored if they are chosen in the nodeList.\n     *\n     * @return returns the amount of unconnected graphs\n     */\n    public int countGraphs() {\n        int count = 0;\n        Set<Node> markedNodes = new HashSet<Node>();\n\n        for (Node n : nodeList) {\n            if (!markedNodes.contains(n)) {\n                markedNodes.add(n);\n                markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    /**\n     * Implementation of depth first search.\n     *\n     * @param n the actual visiting node\n     * @param visited A list of already visited nodes in the depth first search\n     * @return returns a set of visited nodes\n     */\n    public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited) {\n        visited.add(n);\n        for (Edge e : edgeList) {\n            if (e.startNode.equals(n) && !visited.contains(e.endNode)) {\n                depthFirstSearch(e.endNode, visited);\n            }\n        }\n        return visited;\n    }\n}\n\npublic class ConnectedComponent {\n\n    public static void main(String[] args) {\n        Graph<Character> graphChars = new Graph<>();\n\n        // Graph 1\n        graphChars.addEdge('a', 'b');\n        graphChars.addEdge('a', 'e');\n        graphChars.addEdge('b', 'e');\n        graphChars.addEdge('b', 'c');\n        graphChars.addEdge('c', 'd');\n        graphChars.addEdge('d', 'a');\n\n        graphChars.addEdge('x', 'y');\n        graphChars.addEdge('x', 'z');\n\n        graphChars.addEdge('w', 'w');\n\n        Graph<Integer> graphInts = new Graph<>();\n\n        // Graph 2\n        graphInts.addEdge(1, 2);\n        graphInts.addEdge(2, 3);\n        graphInts.addEdge(2, 4);\n        graphInts.addEdge(3, 5);\n\n        graphInts.addEdge(7, 8);\n        graphInts.addEdge(8, 10);\n        graphInts.addEdge(10, 8);\n\n        System.out.println(\"Amount of different char-graphs: \" + graphChars.countGraphs());\n        System.out.println(\"Amount of different int-graphs: \" + graphInts.countGraphs());\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\n\nimport java.util.HashSet;\n\nimport java.util.Set;\n\nclass Graph {\n    class Node {\n        E name;\n        public Node(E name);\n    }\n    class Edge {\n        Node startNode, endNode;\n        public Edge(Node startNode, Node endNode);\n    }\n    ArrayList<Edge> edgeList;\n    ArrayList<Node> nodeList;\n    public Graph();\n    public  addEdge(E startNode, E endNode);\n    public int countGraphs();\n    public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited);\n}\n\npublic class ConnectedComponent {\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "KahnsAlgorithm.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/KahnsAlgorithm.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.graphs",
        "docstring": "/**\n     * Returns an ArrayList with vertices arranged in topological order\n     */",
        "source_code": "\nArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n\n    ArrayList<E> answer = new ArrayList<>();\n\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n\n    return answer;\n}\n",
        "class_name": "AdjacencyList",
        "method_name": "topSortOrder",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n * An algorithm that sorts a graph in toplogical order.\n */\n/**\n * A class that represents the adjaceny list of a graph\n */\nclass AdjacencyList<E extends Comparable<E>> {\n\n    Map<E, ArrayList<E>> adj;\n\n    AdjacencyList() {\n        adj = new LinkedHashMap<E, ArrayList<E>>();\n    }\n\n    /**\n     * This function adds an Edge to the adjaceny list\n     *\n     * @param from , the vertex the edge is from\n     * @param to, the vertex the edge is going to\n     */\n    void addEdge(E from, E to) {\n        try {\n            adj.get(from).add(to);\n        } catch (Exception E) {\n            adj.put(from, new ArrayList<E>());\n            adj.get(from).add(to);\n        }\n        if (!adj.containsKey(to)) {\n            adj.put(to, new ArrayList<E>());\n        }\n    }\n\n    /**\n     * @param v, A vertex in a graph\n     * @return returns an ArrayList of all the adjacents of vertex v\n     */\n    ArrayList<E> getAdjacents(E v) {\n        return adj.get(v);\n    }\n\n    /**\n     * @return returns a set of all vertices in the graph\n     */\n    Set<E> getVertices() {\n        return adj.keySet();\n    }\n\n    /**\n     * Prints the adjacency list\n     */\n    void printGraph() {\n        for (E vertex : adj.keySet()) {\n            System.out.print(vertex + \" : \");\n            for (E adjacent : adj.get(vertex)) {\n                System.out.print(adjacent + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\nclass TopologicalSort<E extends Comparable<E>> {\n\n    AdjacencyList<E> graph;\n    Map<E, Integer> inDegree;\n\n    TopologicalSort(AdjacencyList<E> graph) {\n        this.graph = graph;\n    }\n\n    /**\n     * Calculates the in degree of all vertices\n     */\n    void calculateInDegree() {\n        inDegree = new HashMap<>();\n        for (E vertex : graph.getVertices()) {\n            if (!inDegree.containsKey(vertex)) {\n                inDegree.put(vertex, 0);\n            }\n            for (E adjacent : graph.getAdjacents(vertex)) {\n                try {\n                    inDegree.put(adjacent, inDegree.get(adjacent) + 1);\n                } catch (Exception e) {\n                    inDegree.put(adjacent, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an ArrayList with vertices arranged in topological order\n     */\n    ArrayList<E> topSortOrder() {\n        calculateInDegree();\n        Queue<E> q = new LinkedList<E>();\n\n        for (E vertex : inDegree.keySet()) {\n            if (inDegree.get(vertex) == 0) {\n                q.add(vertex);\n            }\n        }\n\n        ArrayList<E> answer = new ArrayList<>();\n\n        while (!q.isEmpty()) {\n            E current = q.poll();\n            answer.add(current);\n            for (E adjacent : graph.getAdjacents(current)) {\n                inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n                if (inDegree.get(adjacent) == 0) {\n                    q.add(adjacent);\n                }\n            }\n        }\n\n        return answer;\n    }\n}\n\n/**\n * A driver class that sorts a given graph in topological order.\n */\npublic class KahnsAlgorithm {\n\n    public static void main(String[] args) {\n        // Graph definition and initialization\n        AdjacencyList<String> graph = new AdjacencyList<>();\n        graph.addEdge(\"a\", \"b\");\n        graph.addEdge(\"c\", \"a\");\n        graph.addEdge(\"a\", \"d\");\n        graph.addEdge(\"b\", \"d\");\n        graph.addEdge(\"c\", \"u\");\n        graph.addEdge(\"u\", \"b\");\n\n        TopologicalSort<String> topSort = new TopologicalSort<>(graph);\n\n        // Printing the order\n        for (String s : topSort.topSortOrder()) {\n            System.out.print(s + \" \");\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\n\nimport java.util.HashMap;\n\nimport java.util.LinkedHashMap;\n\nimport java.util.LinkedList;\n\nimport java.util.Map;\n\nimport java.util.Queue;\n\nimport java.util.Set;\n\nclass AdjacencyList {\n    Map<E, ArrayList<E>> adj;\n    AdjacencyList();\n     addEdge(E from, E to);\n    ArrayList<E> getAdjacents(E v);\n    Set<E> getVertices();\n     printGraph();\n}\n\nclass TopologicalSort {\n    AdjacencyList<E> graph;\n    Map<E, Integer> inDegree;\n    TopologicalSort(AdjacencyList<E> graph);\n     calculateInDegree();\n    ArrayList<E> topSortOrder();\n}\n\npublic class KahnsAlgorithm {\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "NodeStack.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.stacks",
        "docstring": "/**\n     * Put a value onto the stack.\n     *\n     * @param item : value to be put on the stack.\n     */",
        "source_code": "\npublic void push(Item item) {\n    NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n    if (this.isEmpty()) {\n        NodeStack.setHead(new NodeStack<>(item));\n        newNs.setNext(null);\n        newNs.setPrevious(null);\n    } else {\n        newNs.setPrevious(NodeStack.head);\n        NodeStack.head.setNext(newNs);\n        NodeStack.setHead(newNs);\n    }\n\n    NodeStack.setSize(NodeStack.getSize() + 1);\n}\n",
        "class_name": "NodeStack",
        "method_name": "push",
        "argument_name": [
            "Item item"
        ],
        "full_context": "package com.thealgorithms.datastructures.stacks;\n\n/**\n * Implementation of a stack using nodes. Unlimited size, no arraylist.\n *\n * @author Kyler Smith, 2017\n */\npublic class NodeStack<Item> {\n\n    /**\n     * Entry point for the program.\n     */\n    public static void main(String[] args) {\n        NodeStack<Integer> Stack = new NodeStack<Integer>();\n\n        Stack.push(3);\n        Stack.push(4);\n        Stack.push(5);\n        System.out.println(\"Testing :\");\n        Stack.print(); // prints : 5 4 3\n\n        Integer x = Stack.pop(); // x = 5\n        Stack.push(1);\n        Stack.push(8);\n        Integer y = Stack.peek(); // y = 8\n        System.out.println(\"Testing :\");\n        Stack.print(); // prints : 8 1 4 3\n\n        System.out.println(\"Testing :\");\n        System.out.println(\"x : \" + x);\n        System.out.println(\"y : \" + y);\n    }\n\n    /**\n     * Information each node should contain.\n     *\n     * @value data : information of the value in the node\n     * @value head : the head of the stack\n     * @value next : the next value from this node\n     * @value previous : the last value from this node\n     * @value size : size of the stack\n     */\n    private Item data;\n\n    private static NodeStack<?> head;\n    private NodeStack<?> previous;\n    private static int size = 0;\n\n    /**\n     * Constructors for the NodeStack.\n     */\n    public NodeStack() {\n    }\n\n    private NodeStack(Item item) {\n        this.data = item;\n    }\n\n    /**\n     * Put a value onto the stack.\n     *\n     * @param item : value to be put on the stack.\n     */\n    public void push(Item item) {\n        NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n        if (this.isEmpty()) {\n            NodeStack.setHead(new NodeStack<>(item));\n            newNs.setNext(null);\n            newNs.setPrevious(null);\n        } else {\n            newNs.setPrevious(NodeStack.head);\n            NodeStack.head.setNext(newNs);\n            NodeStack.setHead(newNs);\n        }\n\n        NodeStack.setSize(NodeStack.getSize() + 1);\n    }\n\n    /**\n     * Value to be taken off the stack.\n     *\n     * @return item : value that is returned.\n     */\n    public Item pop() {\n        Item item = (Item) NodeStack.head.getData();\n\n        NodeStack.setHead(NodeStack.head.getPrevious());\n        NodeStack.head.setNext(null);\n\n        NodeStack.setSize(NodeStack.getSize() - 1);\n\n        return item;\n    }\n\n    /**\n     * Value that is next to be taken off the stack.\n     *\n     * @return item : the next value that would be popped off the stack.\n     */\n    public Item peek() {\n        return (Item) NodeStack.head.getData();\n    }\n\n    /**\n     * If the stack is empty or there is a value in.\n     *\n     * @return boolean : whether or not the stack has anything in it.\n     */\n    public boolean isEmpty() {\n        return NodeStack.getSize() == 0;\n    }\n\n    /**\n     * Returns the size of the stack.\n     *\n     * @return int : number of values in the stack.\n     */\n    public int size() {\n        return NodeStack.getSize();\n    }\n\n    /**\n     * Print the contents of the stack in the following format.\n     *\n     * <p>\n     * x <- head (next out) y z <- tail (first in) . . .\n     */\n    public void print() {\n        for (NodeStack<?> n = NodeStack.head; n != null; n = n.previous) {\n            System.out.println(n.getData().toString());\n        }\n    }\n\n    private static void setHead(NodeStack<?> ns) {\n        NodeStack.head = ns;\n    }\n\n    private void setNext(NodeStack<?> next) {\n    }\n\n    private NodeStack<?> getPrevious() {\n        return previous;\n    }\n\n    private void setPrevious(NodeStack<?> previous) {\n        this.previous = previous;\n    }\n\n    private static int getSize() {\n        return size;\n    }\n\n    private static void setSize(int size) {\n        NodeStack.size = size;\n    }\n\n    private Item getData() {\n        return this.data;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.stacks;\n\npublic class NodeStack {\n    static public  main(String args);\n    private Item data;\n    static private NodeStack<> head;\n    private NodeStack<> previous;\n    static private int size;\n    public NodeStack();\n    private NodeStack(Item item);\n    public  push(Item item);\n    public Item pop();\n    public Item peek();\n    public boolean isEmpty();\n    public int size();\n    public  print();\n    static private  setHead(NodeStack<> ns);\n    private  setNext(NodeStack<> next);\n    private NodeStack<> getPrevious();\n    private  setPrevious(NodeStack<> previous);\n    static private int getSize();\n    static private  setSize(int size);\n    private Item getData();\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "StackArrayList.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/stacks/StackArrayList.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.stacks",
        "docstring": "/**\n     * Return the element at the top of this stack without removing it from the\n     * stack.\n     *\n     * @return the element at the top of this stack.\n     */",
        "source_code": "\npublic int peek() {\n    if (isEmpty()) {\n        throw new EmptyStackException();\n    }\n    return stack.get(stack.size() - 1);\n}\n",
        "class_name": "StackArrayList",
        "method_name": "peek",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.stacks;\n\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\n\n/**\n * This class implements a Stack using an ArrayList.\n *\n * <p>\n * A stack is exactly what it sounds like. An element gets added to the top of\n * the stack and only the element on the top may be removed.\n *\n * <p>\n * This is an ArrayList Implementation of a stack, where size is not a problem\n * we can extend the stack as much as we want.\n */\npublic class StackArrayList {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        StackArrayList stack = new StackArrayList();\n        assert stack.isEmpty();\n\n        for (int i = 1; i <= 5; ++i) {\n            stack.push(i);\n            assert stack.size() == i;\n        }\n\n        assert stack.size() == 5;\n        assert stack.peek() == 5 && stack.pop() == 5 && stack.peek() == 4;\n\n        /* pop elements at the top of this stack one by one */\n        while (!stack.isEmpty()) {\n            stack.pop();\n        }\n        assert stack.isEmpty();\n\n        try {\n            stack.pop();\n            assert false;\n            /* this should not happen */\n        } catch (EmptyStackException e) {\n            assert true;\n            /* this should happen */\n        }\n    }\n\n    /**\n     * ArrayList representation of the stack\n     */\n    private ArrayList<Integer> stack;\n\n    /**\n     * Constructor\n     */\n    public StackArrayList() {\n        stack = new ArrayList<>();\n    }\n\n    /**\n     * Adds value to the end of list which is the top for stack\n     *\n     * @param value value to be added\n     */\n    public void push(int value) {\n        stack.add(value);\n    }\n\n    /**\n     * Removes the element at the top of this stack and returns\n     *\n     * @return Element popped\n     * @throws EmptyStackException if the stack is empty.\n     */\n    public int pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n\n        /* remove the element on the top of the stack */\n        return stack.remove(stack.size() - 1);\n    }\n\n    /**\n     * Test if the stack is empty.\n     *\n     * @return {@code true} if this stack is empty, {@code false} otherwise.\n     */\n    public boolean isEmpty() {\n        return stack.isEmpty();\n    }\n\n    /**\n     * Return the element at the top of this stack without removing it from the\n     * stack.\n     *\n     * @return the element at the top of this stack.\n     */\n    public int peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return stack.get(stack.size() - 1);\n    }\n\n    /**\n     * Return size of this stack.\n     *\n     * @return size of this stack.\n     */\n    public int size() {\n        return stack.size();\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.stacks;\n\nimport java.util.ArrayList;\n\nimport java.util.EmptyStackException;\n\npublic class StackArrayList {\n    static public  main(String args);\n    private ArrayList<Integer> stack;\n    public StackArrayList();\n    public  push(int value);\n    public int pop();\n    public boolean isEmpty();\n    public int peek();\n    public int size();\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "AbsoluteMax.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/AbsoluteMax.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Finds the absolute maximum value among the given numbers.\n     *\n     * @param numbers The numbers to compare.\n     * @return The absolute maximum value.\n     * @throws IllegalArgumentException If the input array is empty or null.\n     */",
        "source_code": "\npublic static int getMaxValue(int... numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    int absMax = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n            absMax = numbers[i];\n        }\n    }\n    return absMax;\n}\n",
        "class_name": "AbsoluteMax",
        "method_name": "getMaxValue",
        "argument_name": [
            "int numbers"
        ],
        "full_context": "package com.thealgorithms.maths;\n\npublic class AbsoluteMax {\n\n    /**\n     * Finds the absolute maximum value among the given numbers.\n     *\n     * @param numbers The numbers to compare.\n     * @return The absolute maximum value.\n     * @throws IllegalArgumentException If the input array is empty or null.\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        int absMax = numbers[0];\n        for (int i = 1; i < numbers.length; i++) {\n            if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n                absMax = numbers[i];\n            }\n        }\n        return absMax;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class AbsoluteMax {\n    static public int getMaxValue(int numbers);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "AliquotSum.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/AliquotSum.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Function to calculate the aliquot sum of an integer number\n     *\n     * @param n a positive integer\n     * @return aliquot sum of given {@code number}\n     */",
        "source_code": "\npublic static int getAliquotSum(int n) {\n    if (n <= 0) return -1;\n    int sum = 1;\n    double root = Math.sqrt(n);\n    /*\n     * We can get the factors after the root by dividing number by its factors\n     * before the root.\n     * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n     * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n     * Now by dividing 100 by each factor before 10 we get:\n     * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n     * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n     */\n    for (int i = 2; i <= root; i++) {\n        if (n % i == 0) {\n            sum += i + n / i;\n        }\n    }\n    // if n is a perfect square then its root was added twice in above loop, so subtracting root\n    // from sum\n    if (root == (int) root) sum -= root;\n    return sum;\n}\n",
        "class_name": "AliquotSum",
        "method_name": "getAliquotSum",
        "argument_name": [
            "int n"
        ],
        "full_context": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() { int value = 0; };\n\n        IntStream.iterate(1, i -> ++i).limit(number / 2).filter(i -> number % i == 0).forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n\n    /**\n     * Function to calculate the aliquot sum of an integer number\n     *\n     * @param n a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotSum(int n) {\n        if (n <= 0) return -1;\n        int sum = 1;\n        double root = Math.sqrt(n);\n        /*\n         * We can get the factors after the root by dividing number by its factors\n         * before the root.\n         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n         * Now by dividing 100 by each factor before 10 we get:\n         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n         * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n         */\n        for (int i = 2; i <= root; i++) {\n            if (n % i == 0) {\n                sum += i + n / i;\n            }\n        }\n        // if n is a perfect square then its root was added twice in above loop, so subtracting root\n        // from sum\n        if (root == (int) root) sum -= root;\n        return sum;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\npublic class AliquotSum {\n    static public int getAliquotValue(int number);\n    static public int getAliquotSum(int n);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Armstrong.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/Armstrong.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Checks whether a given number is an Armstrong number or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n     */",
        "source_code": "\npublic boolean isArmstrong(int number) {\n    long sum = 0;\n    String temp = Integer.toString(number); // Convert the given number to a string\n    int power = temp.length(); // Extract the length of the number (number of digits)\n    long originalNumber = number;\n\n    while (originalNumber > 0) {\n        long digit = originalNumber % 10;\n        sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n        originalNumber /= 10;\n    }\n\n    return sum == number;\n}\n",
        "class_name": "Armstrong",
        "method_name": "isArmstrong",
        "argument_name": [
            "int number"
        ],
        "full_context": "package com.thealgorithms.maths;\n\n/**\n * This class checks whether a given number is an Armstrong number or not.\n * An Armstrong number is a number that is equal to the sum of its own digits,\n * each raised to the power of the number of digits.\n *\n * For example, 370 is an Armstrong number because 3^3 + 7^3 + 0^3 = 370.\n * 1634 is an Armstrong number because 1^4 + 6^4 + 3^4 + 4^4 = 1634.\n * An Armstrong number is often called a Narcissistic number.\n *\n * @author satyabarghav\n */\npublic class Armstrong {\n\n    /**\n     * Checks whether a given number is an Armstrong number or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n     */\n    public boolean isArmstrong(int number) {\n        long sum = 0;\n        String temp = Integer.toString(number); // Convert the given number to a string\n        int power = temp.length(); // Extract the length of the number (number of digits)\n        long originalNumber = number;\n\n        while (originalNumber > 0) {\n            long digit = originalNumber % 10;\n            sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n            originalNumber /= 10;\n        }\n\n        return sum == number;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class Armstrong {\n    public boolean isArmstrong(int number);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Average.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/Average.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * find average value of an int array\n     *\n     * @param numbers the array contains element and the sum does not excess long\n     *                value limit\n     * @return average value\n     */",
        "source_code": "\npublic static int average(int[] numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    long sum = 0;\n    for (int number : numbers) {\n        sum += number;\n    }\n    return (int) (sum / numbers.length);\n}\n",
        "class_name": "Average",
        "method_name": "average",
        "argument_name": [
            "int[] numbers"
        ],
        "full_context": "package com.thealgorithms.maths;\n\n/**\n * Calculate average of a list of numbers\n */\npublic class Average {\n\n    /**\n     * Calculate average of a list of numbers\n     *\n     * @param numbers array to store numbers\n     * @return mean of given numbers\n     */\n    public static double average(double[] numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        double sum = 0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        return sum / numbers.length;\n    }\n\n    /**\n     * find average value of an int array\n     *\n     * @param numbers the array contains element and the sum does not excess long\n     *                value limit\n     * @return average value\n     */\n    public static int average(int[] numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        long sum = 0;\n        for (int number : numbers) {\n            sum += number;\n        }\n        return (int) (sum / numbers.length);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class Average {\n    static public double average(double[] numbers);\n    static public int average(int[] numbers);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "FFT.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
        "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
        "class_name": "FFT",
        "method_name": "fft",
        "argument_name": [
            "ArrayList<Complex> x",
            "boolean inverse"
        ],
        "full_context": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double) Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */\n    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n        int log2N = findLog2(N);\n        x = fftBitReversal(N, log2N, x);\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        x = inverseFFT(N, inverse, x);\n        return x;\n    }\n\n    /* Find the log2(N) */\n    public static int findLog2(int N) {\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n        return log2N;\n    }\n\n    /* Swap the values of the signal with bit-reversal method */\n    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x) {\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n        return x;\n    }\n\n    /* Divide by N if we want the inverse FFT */\n    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x) {\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\npublic class FFT {\n    static class Complex {\n        private double real, img;\n        public Complex();\n        public Complex(double r, double i);\n        public double getReal();\n        public double getImaginary();\n        public Complex add(Complex z);\n        public Complex subtract(Complex z);\n        public Complex multiply(Complex z);\n        public Complex multiply(double n);\n        public Complex conjugate();\n        public double abs();\n        public Complex divide(Complex z);\n        public Complex divide(double n);\n    }\n    static public ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse);\n    static public int findLog2(int N);\n    static public ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x);\n    static public ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x);\n    static private int reverseBits(int num, int log2N);\n    static private  paddingPowerOfTwo(ArrayList<Complex> x);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "FindMax.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/FindMax.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */",
        "source_code": "\npublic static int findMax(final int[] array) {\n    int n = array.length;\n    if (n == 0) {\n        throw new IllegalArgumentException(\"Array must be non-empty.\");\n    }\n    int max = array[0];\n    for (int i = 1; i < n; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}\n",
        "class_name": "FindMax",
        "method_name": "findMax",
        "argument_name": [
            "int[] array"
        ],
        "full_context": "package com.thealgorithms.maths;\n\npublic final class FindMax {\n    private FindMax() {\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(final int[] array) {\n        int n = array.length;\n        if (n == 0) {\n            throw new IllegalArgumentException(\"Array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < n; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\nfinal public class FindMax {\n    private FindMax();\n    static public int findMax(int[] array);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "TwinPrime.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/TwinPrime.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */",
        "source_code": "\nstatic int getTwinPrime(int inputNumber) {\n\n    // if inputNumber and (inputNumber + 2) are both prime\n    // then return (inputNumber + 2) as a result\n    if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n        return inputNumber + 2;\n    }\n    // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n    // then return -1 as a result\n    return -1;\n}\n",
        "class_name": "TwinPrime",
        "method_name": "getTwinPrime",
        "argument_name": [
            "int inputNumber"
        ],
        "full_context": "package com.thealgorithms.maths;\n/*\n * Java program to find 'twin prime' of a prime number\n * Twin Prime: Twin prime of a number n is (n+2)\n * if and only if n & (n+2) are prime.\n * Wikipedia: https://en.wikipedia.org/wiki/Twin_prime\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class TwinPrime {\n\n    /**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */\n    static int getTwinPrime(int inputNumber) {\n\n        // if inputNumber and (inputNumber + 2) are both prime\n        // then return (inputNumber + 2) as a result\n        if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n            return inputNumber + 2;\n        }\n        // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n        // then return -1 as a result\n        return -1;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class TwinPrime {\n    static int getTwinPrime(int inputNumber);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "QuickSort.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.sorts",
        "docstring": "/**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */",
        "source_code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] array) {\n    doSort(array, 0, array.length - 1);\n    return array;\n}\n",
        "class_name": "QuickSort",
        "method_name": "sort",
        "argument_name": [
            "T array"
        ],
        "full_context": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Randomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils;\n\nclass QuickSort implements SortAlgorithm {\n    public T sort(T array);\n    static private  doSort(T array, int left, int right);\n    static private int randomPartition(T array, int left, int right);\n    static private int partition(T array, int left, int right);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "HeapSort.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/sorts/HeapSort.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.sorts",
        "docstring": "/**\n     * For simplicity, we are considering the heap root index as 1 instead of 0.\n     * It simplifies future calculations. Because of that we are decreasing the\n     * provided indexes by 1 in {@link #swap(Object[], int, int)} and\n     * {@link #less(Comparable[], int, int)} functions.\n     */",
        "source_code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    int n = unsorted.length;\n    heapify(unsorted, n);\n    while (n > 1) {\n        swap(unsorted, 1, n--);\n        siftDown(unsorted, 1, n);\n    }\n    return unsorted;\n}\n",
        "class_name": "HeapSort",
        "method_name": "sort",
        "argument_name": [
            "T unsorted"
        ],
        "full_context": "package com.thealgorithms.sorts;\n\n/**\n * Heap Sort Algorithm Implementation\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Heapsort\">Heap Sort Algorithm</a>\n */\npublic class HeapSort implements SortAlgorithm {\n\n    /**\n     * For simplicity, we are considering the heap root index as 1 instead of 0.\n     * It simplifies future calculations. Because of that we are decreasing the\n     * provided indexes by 1 in {@link #swap(Object[], int, int)} and\n     * {@link #less(Comparable[], int, int)} functions.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        int n = unsorted.length;\n        heapify(unsorted, n);\n        while (n > 1) {\n            swap(unsorted, 1, n--);\n            siftDown(unsorted, 1, n);\n        }\n        return unsorted;\n    }\n\n    private static <T extends Comparable<T>> void heapify(T[] unsorted, int n) {\n        for (int k = n / 2; k >= 1; k--) {\n            siftDown(unsorted, k, n);\n        }\n    }\n\n    private static <T extends Comparable<T>> void siftDown(T[] unsorted, int k, int n) {\n        while (2 * k <= n) {\n            int j = 2 * k;\n            if (j < n && less(unsorted, j, j + 1)) {\n                j++;\n            }\n            if (!less(unsorted, k, j)) {\n                break;\n            }\n            swap(unsorted, k, j);\n            k = j;\n        }\n    }\n\n    private static <T> void swap(T[] array, int idx, int idy) {\n        T swap = array[idx - 1];\n        array[idx - 1] = array[idy - 1];\n        array[idy - 1] = swap;\n    }\n\n    private static <T extends Comparable<T>> boolean less(T[] array, int idx, int idy) {\n        return array[idx - 1].compareTo(array[idy - 1]) < 0;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.sorts;\n\npublic class HeapSort implements SortAlgorithm {\n    public T sort(T unsorted);\n    static private  heapify(T unsorted, int n);\n    static private  siftDown(T unsorted, int k, int n);\n    static private  swap(T array, int idx, int idy);\n    static private boolean less(T array, int idx, int idy);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "HammingDistance.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/strings/HammingDistance.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.strings",
        "docstring": "/**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */",
        "source_code": "\npublic static int calculateHammingDistance(String s1, String s2) throws Exception {\n    if (s1.length() != s2.length()) {\n        throw new Exception(\"String lengths must be equal\");\n    }\n\n    int stringLength = s1.length();\n    int counter = 0;\n\n    for (int i = 0; i < stringLength; i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            counter++;\n        }\n    }\n    return counter;\n}\n",
        "class_name": "HammingDistance",
        "method_name": "calculateHammingDistance",
        "argument_name": [
            "String s1",
            "String s2"
        ],
        "full_context": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length\nis the number of positions at which the corresponding symbols are different.\nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2) throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n\n        int stringLength = s1.length();\n        int counter = 0;\n\n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.strings;\n\npublic class HammingDistance {\n    static public int calculateHammingDistance(String s1, String s2)throws Exception;\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Lower.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/strings/Lower.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.strings",
        "docstring": "/**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */",
        "source_code": "\npublic static String toLowerCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n        if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n            values[i] = Character.toLowerCase(values[i]);\n        }\n    }\n    return new String(values);\n}\n",
        "class_name": "Lower",
        "method_name": "toLowerCase",
        "argument_name": [
            "String s"
        ],
        "full_context": "package com.thealgorithms.strings;\n\npublic class Lower {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n        for (String s : strings) {\n            assert toLowerCase(s).equals(s.toLowerCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */\n    public static String toLowerCase(String s) {\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n                values[i] = Character.toLowerCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.strings;\n\npublic class Lower {\n    static public  main(String args);\n    static public String toLowerCase(String s);\n}\n\n"
    }
]