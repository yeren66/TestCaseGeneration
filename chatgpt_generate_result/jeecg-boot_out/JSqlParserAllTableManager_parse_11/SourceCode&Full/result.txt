Source code: 


public Map<String, SelectSqlInfo> parse() throws JSQLParserException {
    // 1. 创建解析器
    CCJSqlParserManager mgr = new CCJSqlParserManager();
    // 2. 使用解析器解析sql生成具有层次结构的java类
    Statement stmt = mgr.parse(new StringReader(this.sql));
    if (stmt instanceof Select) {
        Select selectStatement = (Select) stmt;
        SelectBody selectBody = selectStatement.getSelectBody();
        this.parsedSql = selectBody.toString();
        // 3. 解析select查询sql的信息
        if (selectBody instanceof PlainSelect) {
            PlainSelect plainSelect = (PlainSelect) selectBody;
            // 4. 合并 fromItems
            List<FromItem> fromItems = new ArrayList<>();
            fromItems.add(plainSelect.getFromItem());
            // 4.1 处理join的表
            List<Join> joins = plainSelect.getJoins();
            if (joins != null) {
                joins.forEach(join -> fromItems.add(join.getRightItem()));
            }
            // 5. 处理 fromItems
            for (FromItem fromItem : fromItems) {
                // 5.1 通过表名的方式from
                if (fromItem instanceof Table) {
                    this.addSqlInfoByTable((Table) fromItem);
                }
                // 5.2 通过子查询的方式from
                else if (fromItem instanceof SubSelect) {
                    this.handleSubSelect((SubSelect) fromItem);
                }
            }
            // 6. 解析 selectFields
            List<SelectItem> selectItems = plainSelect.getSelectItems();
            for (SelectItem selectItem : selectItems) {
                // 6.1 查询的是全部字段
                if (selectItem instanceof AllColumns) {
                    // 当 selectItem 为 AllColumns 时，fromItem 必定为 Table
                    String tableName = plainSelect.getFromItem(Table.class).getName();
                    // 此处必定不为空，因为在解析 fromItem 时，已经将表名添加到 allTableMap 中
                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);
                    assert sqlInfo != null;
                    // 设置为查询全部字段
                    sqlInfo.setSelectAll(true);
                    sqlInfo.setSelectFields(null);
                    sqlInfo.setRealSelectFields(null);
                }
                // 6.2 查询的是带表别名（ u.* )的全部字段
                else if (selectItem instanceof AllTableColumns) {
                    AllTableColumns allTableColumns = (AllTableColumns) selectItem;
                    String aliasName = allTableColumns.getTable().getName();
                    // 通过别名获取表名
                    String tableName = this.tableAliasMap.get(aliasName);
                    if (tableName == null) {
                        tableName = aliasName;
                    }
                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);
                    // 如果此处为空，则说明该字段是通过子查询获取的，所以可以不处理，只有实际表才需要处理
                    if (sqlInfo != null) {
                        // 设置为查询全部字段
                        sqlInfo.setSelectAll(true);
                        sqlInfo.setSelectFields(null);
                        sqlInfo.setRealSelectFields(null);
                    }
                }
                // 6.3 各种字段表达式处理
                else if (selectItem instanceof SelectExpressionItem) {
                    SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;
                    Expression expression = selectExpressionItem.getExpression();
                    Alias alias = selectExpressionItem.getAlias();
                    this.handleExpression(expression, alias, plainSelect.getFromItem());
                }
            }
        } else {
            log.warn("暂时尚未处理该类型的 SelectBody: {}", selectBody.getClass().getName());
            throw new JeecgBootException("暂时尚未处理该类型的 SelectBody");
        }
    } else {
        // 非 select 查询sql，不做处理
        throw new JeecgBootException("非 select 查询sql，不做处理");
    }
    return this.allTableMap;
}



No.1 generated result --------------------------

@Test
public void parseTest() {
    String selectSql = "SELECT * FROM users";
    JSqlParserAllTableManager parser = new JSqlParserAllTableManager(selectSql);
    try {
        parser.parse();
        // Assert the expected values
        // For example:
        Map<String, SelectSqlInfo> result = parser.getAllTableMap();
        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.containsKey("users"));
        SelectSqlInfo sqlInfo = result.get("users");
        assertTrue(sqlInfo.isSelectAll());
        assertNull(sqlInfo.getSelectFields());
        assertNull(sqlInfo.getRealSelectFields());
    } catch (JSQLParserException e) {
        e.printStackTrace();
    }
}


No.2 generated result --------------------------

@Test
public void parseTest() throws JSQLParserException {
    String selectSql = "SELECT t1.column1, t2.column2 FROM table1 t1 JOIN table2 t2 ON t1.id = t2.id";
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);
    Map<String, SelectSqlInfo> result = manager.parse();

    assertNotNull(result);
    assertEquals(2, result.size());
    assertTrue(result.containsKey("table1"));
    assertTrue(result.containsKey("table2"));

    SelectSqlInfo table1Info = result.get("table1");
    assertEquals("SELECT t1.column1, t2.column2 FROM table1 t1 JOIN table2 t2 ON t1.id = t2.id", table1Info.getSelectSql());
    assertFalse(table1Info.isSelectAll());
    assertEquals(2, table1Info.getSelectFields().size());
    assertEquals(2, table1Info.getRealSelectFields().size());

    SelectSqlInfo table2Info = result.get("table2");
    assertEquals("SELECT t1.column1, t2.column2 FROM table1 t1 JOIN table2 t2 ON t1.id = t2.id", table2Info.getSelectSql());
    assertFalse(table2Info.isSelectAll());
    assertEquals(2, table2Info.getSelectFields().size());
    assertEquals(2, table2Info.getRealSelectFields().size());
}


No.3 generated result --------------------------

@Test
public void parseTest() {
    String sql = "SELECT * FROM users";
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sql);
    try {
        manager.parse();
        Map<String, SelectSqlInfo> allTableMap = manager.getAllTableMap();
        assertNotNull(allTableMap);
        assertEquals(1, allTableMap.size());
        assertTrue(allTableMap.containsKey("users"));
        SelectSqlInfo sqlInfo = allTableMap.get("users");
        assertTrue(sqlInfo.isSelectAll());
        assertNull(sqlInfo.getSelectFields());
        assertNull(sqlInfo.getRealSelectFields());
    } catch (JSQLParserException e) {
        fail("Failed to parse the SQL statement");
    }
}


No.4 generated result --------------------------

@Test
public void parseTest() {
    String selectSql = "SELECT * FROM table1";
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);
    try {
        manager.parse();
        // Add assertions here to verify the expected output
    } catch (JSQLParserException e) {
        fail("Parsing failed: " + e.getMessage());
    }
}


No.5 generated result --------------------------

@Test
public void parseTest() {
    String selectSql = "SELECT a.id, b.name FROM table_a a JOIN table_b b ON a.id = b.id";
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);
    try {
        manager.parse();
        Map<String, SelectSqlInfo> result = manager.getAllTableMap();
        assertEquals(2, result.size());
        assertNotNull(result.get("table_a"));
        assertNotNull(result.get("table_b"));
        SelectSqlInfo tableAInfo = result.get("table_a");
        SelectSqlInfo tableBInfo = result.get("table_b");
        assertTrue(tableAInfo.isSelectAll());
        assertNull(tableAInfo.getSelectFields());
        assertNull(tableAInfo.getRealSelectFields());
        assertTrue(tableBInfo.isSelectAll());
        assertNull(tableBInfo.getSelectFields());
        assertNull(tableBInfo.getRealSelectFields());
    } catch (Exception e) {
        fail("An exception occurred: " + e.getMessage());
    }
}


No.6 generated result --------------------------

@Test
public void parseTest() {
    String selectSql = "SELECT * FROM table1";
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);
    try {
        Map<String, SelectSqlInfo> result = manager.parse();
        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.containsKey("table1"));
        SelectSqlInfo sqlInfo = result.get("table1");
        assertTrue(sqlInfo.isSelectAll());
        assertNull(sqlInfo.getSelectFields());
        assertNull(sqlInfo.getRealSelectFields());
    } catch (JSQLParserException e) {
        fail("Exception occurred: " + e.getMessage());
    }
}


No.7 generated result --------------------------

JSqlParserAllTableManager manager = new JSqlParserAllTableManager("SELECT * FROM table_name");
Map<String, SelectSqlInfo> result = manager.parse();
assertEquals(1, result.size());
SelectSqlInfo sqlInfo = result.get("table_name");
assertTrue(sqlInfo.isSelectAll());
assertNull(sqlInfo.getSelectFields());
assertNull(sqlInfo.getRealSelectFields());


No.8 generated result --------------------------

@Test
public void parseTest() {
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager("SELECT * FROM table");
    try {
        Map<String, SelectSqlInfo> result = manager.parse();
        assertNotNull(result);
        assertEquals(1, result.size());
        // Add more assertions for the expected values
    } catch (JSQLParserException e) {
        fail("Exception thrown: " + e.getMessage());
    }
}


No.9 generated result --------------------------

@Test
public void parseTest() {
    String sql = "SELECT * FROM table1 t1 INNER JOIN table2 t2 ON t1.id = t2.id";
    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sql);
    try {
        Map<String, SelectSqlInfo> result = manager.parse();
        assertEquals(2, result.size());
        assertTrue(result.containsKey("table1"));
        assertTrue(result.containsKey("table2"));
    } catch (JSQLParserException e) {
        fail("An exception was thrown: " + e.getMessage());
    }
}


No.10 generated result --------------------------

package org.jeecg.common.util.sqlparse;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class JSqlParserAllTableManagerTest {
    @Test
    public void parseTest() {
        String selectSql = "SELECT a.id, b.name FROM table_a a JOIN table_b b ON a.id = b.id";
        
        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);
        try {
            manager.parse();
            // Add assertions here
        } catch (Exception e) {
            fail("Exception occurred: " + e.getMessage());
        }
    }
}


