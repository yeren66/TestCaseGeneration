{
    "project_name": "JCTools",
    "file_name": "NonBlockingSetInt.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
    "execute_path": "JCTools",
    "package": "org.jctools.maps",
    "docstring": null,
    "source_code": "// Help copy this one word.  State Machine.\n// (1) If not \"made immutable\" in the old array, set the sign bit to make\n//     it immutable.\n// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old\n// (3) If non-zero in old array & non-zero in new, CAS old to zero\n// (4) Zero in old, new is valid\n// At this point, old should be immutable-zero & new has a copy of bits\nprivate NBSI help_copy_impl( int i ) {\n  // Handle every 64th bit via using a nested array\n  NBSI old = this;          // The bit array being copied from\n  NBSI nnn = _new;          // The bit array being copied to\n  if( nnn == null ) return this; // Promoted already\n  int j = i;                // The bit index being added\n  while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n    old = old._nbsi64;      // Recurse\n    nnn = nnn._nbsi64;      // Recurse\n    j = j>>6;               // Strip off low 6 bits (all set)\n  }\n\n  // Transit from state 1: word is not immutable yet\n  // Immutable is in bit 63, the sign bit.\n  long bits = old._bits[j>>6];\n  while( bits >= 0 ) {      // Still in state (1)?\n    long oldbits = bits;\n    bits |= mask(63);       // Target state of bits: sign-bit means immutable\n    if( old.CAS( j>>6, oldbits, bits ) ) {\n      if( oldbits == 0 ) _copyDone.addAndGet(1);\n      break;                // Success - old array word is now immutable\n    }\n    bits = old._bits[j>>6]; // Retry if CAS failed\n  }\n\n  // Transit from state 2: non-zero in old and zero in new\n  if( bits != mask(63) ) {  // Non-zero in old?\n    long new_bits = nnn._bits[j>>6];\n    if( new_bits == 0 ) {   // New array is still zero\n      new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n      // One-shot CAS attempt, no loop, from 0 to non-zero.\n      // If it fails, somebody else did the copy for us\n      if( !nnn.CAS( j>>6, 0, new_bits ) )\n        new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n      assert new_bits != 0;\n    }\n\n    // Transit from state 3: non-zero in old and non-zero in new\n    // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n    if( old.CAS( j>>6, bits, mask(63) ) )\n      _copyDone.addAndGet(1); // One more word finished copying\n  }\n\n  // Now in state 4: zero (and immutable) in old\n\n  // Return the self bitvector for 'fluid' programming style\n  return this;\n}\n",
    "class_name": "NonBlockingSetInt",
    "method_name": "help_copy_impl",
    "arguments": [
        "int i"
    ],
    "generate_test": [
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt set = new NonBlockingSetInt();\n    \n    // Create a NBSI object\n    NonBlockingSetInt.NBSI nbsi = set.new NBSI(10, null, set);\n    \n    // Perform the help_copy_impl method\n    NonBlockingSetInt.NBSI result = nbsi.help_copy_impl(5);\n    \n    // Assertions\n    assertNotNull(result);\n    assertSame(nbsi, result);\n}",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt set = new NonBlockingSetInt();\n    set.add(5);\n    NBSI nbsi = set._nbsi;\n    NBSI nbsiCopy = set.help_copy_impl(0);\n    assertEquals(nbsi, nbsiCopy);\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        NonBlockingSetInt nonBlockingSetInt = new NonBlockingSetInt();\n        NonBlockingSetInt.NBSI nbsi = nonBlockingSetInt.new NBSI(10, null, nonBlockingSetInt);\n\n        NonBlockingSetInt.NBSI result = nbsi.help_copy_impl(0);\n\n        assertNotNull(result);\n        // Add additional assertions as needed...\n    }\n}",
        "@Test\npublic void help_copy_implTest() {\n    NBSI nbsi = new NBSI(10, new ConcurrentAutoTable(), new NonBlockingSetInt());\n    NBSI result = nbsi.help_copy_impl(0);\n    \n    // Assertion statements\n    // ...\n}",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt.NBSI old = new NonBlockingSetInt.NBSI(10, null, null);\n    NonBlockingSetInt.NBSI nnn = new NonBlockingSetInt.NBSI(10, null, null);\n    NonBlockingSetInt.NBSI result = old.help_copy_impl(0);\n    assertEquals(old, result);\n}",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt.NBSI nbsi = new NonBlockingSetInt.NBSI(10, null, null);\n    NonBlockingSetInt.NBSI nbsi64 = new NonBlockingSetInt.NBSI(10, null, null);\n    nbsi._nbsi64 = nbsi64;\n    long[] bits = new long[1];\n    bits[0] = 3;\n    nbsi._bits = bits;\n    \n    NonBlockingSetInt.NBSI newNbsi = new NonBlockingSetInt.NBSI(10, null, null);\n    newNbsi._bits = new long[1];\n    \n    // Set up context\n    // ...\n\n    NonBlockingSetInt.NBSI result = nbsi.help_copy_impl(0);\n    \n    // Assertions\n    assertEquals(nbsi._bits[0], 3);\n    assertEquals(result, nbsi);\n}",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt.NBSI nbsi = new NonBlockingSetInt.NBSI(100, new ConcurrentAutoTable(), new NonBlockingSetInt());\n    nbsi.add(5);\n    nbsi.add(10);\n    \n    NonBlockingSetInt.NBSI old = nbsi;\n    NonBlockingSetInt.NBSI newNbsi = nbsi._new;\n    int i = 0;\n    \n    NonBlockingSetInt.NBSI result = help_copy_impl(old, newNbsi, i);\n    \n    assertEquals(old, result);\n}\n\npublic NonBlockingSetInt.NBSI help_copy_impl(NonBlockingSetInt.NBSI old, NonBlockingSetInt.NBSI nnn, int i) {\n    // Handle every 64th bit via using a nested array\n    if( nnn == null ) return old; // Promoted already\n    int j = i;                // The bit index being added\n    while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n        old = old._nbsi64;      // Recurse\n        nnn = nnn._nbsi64;      // Recurse\n        j = j>>6;               // Strip off low 6 bits (all set)\n    }\n\n    // Transit from state 1: word is not immutable yet\n    // Immutable is in bit 63, the sign bit.\n    long bits = old._bits[j>>6];\n    while( bits >= 0 ) {      // Still in state (1)?\n        long oldbits = bits;\n        bits |= mask(63);       // Target state of bits: sign-bit means immutable\n        if( old.CAS( j>>6, oldbits, bits ) ) {\n            if( oldbits == 0 ) _copyDone.addAndGet(1);\n            break;                // Success - old array word is now immutable\n        }\n        bits = old._bits[j>>6]; // Retry if CAS failed\n    }\n\n    // Transit from state 2: non-zero in old and zero in new\n    if( bits != mask(63) ) {  // Non-zero in old?\n        long new_bits = nnn._bits[j>>6];\n        if( new_bits == 0 ) {   // New array is still zero\n            new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n            // One-shot CAS attempt, no loop, from 0 to non-zero.\n            // If it fails, somebody else did the copy for us\n            if( !nnn.CAS( j>>6, 0, new_bits ) )\n                new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n            assert new_bits != 0;\n        }\n\n        // Transit from state 3: non-zero in old and non-zero in new\n        // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n        if( old.CAS( j>>6, bits, mask(63) ) )\n            _copyDone.addAndGet(1); // One more word finished copying\n    }\n\n    // Now in state 4: zero (and immutable) in old\n\n    // Return the self bitvector for 'fluid' programming style\n    return old;\n}",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt setInt = new NonBlockingSetInt();\n    NonBlockingSetInt.NBSI nbsi = setInt.new NBSI(10, null, setInt);\n    int i = 0;\n    \n    // TODO: Setup initial values for nbsi and _new variables\n    \n    NonBlockingSetInt.NBSI result = nbsi.help_copy_impl(i);\n    \n    // TODO: Verify the expected behavior of the method\n    \n    assertNotNull(result);\n}",
        "@Test\n    public void help_copy_implTest() {\n        NonBlockingSetInt set = new NonBlockingSetInt();\n        NonBlockingSetInt.NBSI nbsi = new NonBlockingSetInt.NBSI(10, null, set);\n        NonBlockingSetInt.NBSI nbsi2 = new NonBlockingSetInt.NBSI(10, null, set);\n        \n        nbsi._bits = new long[1];\n        nbsi._bits[0] = 5;\n        \n        nbsi2._bits = new long[1];\n        nbsi2._bits[0] = 0;\n        \n        nbsi.help_copy_impl(0);\n        \n        assertEquals(0, nbsi._bits[0]);\n        assertEquals(5, nbsi2._bits[0]);\n    }",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetInt set = new NonBlockingSetInt();\n    NonBlockingSetInt.NBSI nbsi = set.new NBSI(10, null, set);\n    NonBlockingSetInt.NBSI old = set.new NBSI(10, null, set);\n    nbsi._bits = new long[2];\n    old._bits = new long[2];\n    old._bits[0] = 1;\n    \n    NonBlockingSetInt.NBSI result = nbsi.help_copy_impl(0);\n    \n    assertEquals(0, old._bits[0]);\n    assertEquals(0, nbsi._bits[0]);\n    assertEquals(1, result._bits[0]);\n}"
    ]
}