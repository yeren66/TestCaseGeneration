{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "Node",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<Node>();\n        Node node1 = new Node();\n        Node node2 = new Node();\n        node1.color = 1;\n        node1.edges = new HashSet<Integer>(Arrays.asList(2, 3));\n        node2.color = 1;\n        node2.edges = new HashSet<Integer>(Arrays.asList(1));\n        nodes.add(null); // Add null as index 0 is not used\n        nodes.add(node1);\n        nodes.add(node2);\n        \n        int n = 2;\n        int m = 2;\n        \n        int result = MColoring.possiblePaint(nodes, n, m);\n        \n        assertEquals(1, result);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node();\n        node1.color = 1;\n        node1.edges = new HashSet<>();\n        node1.edges.add(2);\n\n        Node node2 = new Node();\n        node2.color = 1;\n        node2.edges = new HashSet<>();\n        node2.edges.add(1);\n        node2.edges.add(3);\n\n        Node node3 = new Node();\n        node3.color = 1;\n        node3.edges = new HashSet<>();\n        node3.edges.add(2);\n\n        nodes.add(null); // Adjust the indices as the nodes start from index 1\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n\n        int n = 3; // Number of nodes\n        int m = 2; // Number of colors\n\n        int expected = 1; // The expected output\n        int actual = MColoring.possiblePaint(nodes, n, m);\n\n        assertEquals(expected, actual);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        // Prepare input\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        node1.color = 1;\n        node1.edges = new HashSet<>();\n        node1.edges.add(2);\n        node1.edges.add(3);\n        node2.color = 1;\n        node2.edges = new HashSet<>();\n        node2.edges.add(1);\n        node2.edges.add(3);\n        node3.color = 1;\n        node3.edges = new HashSet<>();\n        node3.edges.add(1);\n        node3.edges.add(2);\n        nodes.add(null); // Index 0 is not used\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n        int n = 3;\n        int m = 2;\n\n        // Execute method to be tested\n        int result = MColoring.possiblePaint(nodes, n, m);\n\n        // Assert the result\n        assertEquals(1, result);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create test data\n        Node node1 = new Node();\n        node1.color = 1;\n        node1.edges = new HashSet<>();\n        Node node2 = new Node();\n        node2.color = 1;\n        node2.edges = new HashSet<>();\n        // Add edges between nodes\n        node1.edges.add(2);\n        node2.edges.add(1);\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(null); // Due to 1-based indexing\n        nodes.add(node1);\n        nodes.add(node2);\n\n        // Call the method being tested\n        int result = MColoring.possiblePaint(nodes, 2, 2);\n\n        // Assert the result\n        assertEquals(1, result);\n    }\n}",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    \n    // Creating nodes and adding edges\n    Node node1 = new Node();\n    node1.color = 1;\n    node1.edges = new HashSet<>(Arrays.asList(2, 3));\n    nodes.add(node1);\n    \n    Node node2 = new Node();\n    node2.color = 2;\n    node2.edges = new HashSet<>(Arrays.asList(1, 3));\n    nodes.add(node2);\n    \n    Node node3 = new Node();\n    node3.color = 3;\n    node3.edges = new HashSet<>(Arrays.asList(1, 2));\n    nodes.add(node3);\n    \n    int n = nodes.size();\n    int m = 3;\n    \n    int result = MColoring.possiblePaint(nodes, n, m);\n    \n    assertEquals(1, result);\n}",
        "ArrayList<Node> nodes = new ArrayList<>();\nNode node1 = new Node();\nnode1.color = 1;\nnode1.edges = new HashSet<>(Arrays.asList(2, 3));\nNode node2 = new Node();\nnode2.color = 2;\nnode2.edges = new HashSet<>(Arrays.asList(1, 3));\nNode node3 = new Node();\nnode3.color = 1;\nnode3.edges = new HashSet<>(Collections.singletonList(2));\nnodes.add(node1);\nnodes.add(node2);\nnodes.add(node3);\n\nint n = 3;\nint m = 2;\nint result = MColoring.possiblePaint(nodes, n, m);\nassertEquals(1, result);",
        "import java.util.ArrayList;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node();\n        node1.color = 1;\n        node1.edges = new HashSet<>();\n        Node node2 = new Node();\n        node2.color = 1;\n        node2.edges = new HashSet<>();\n        Node node3 = new Node();\n        node3.color = 1;\n        node3.edges = new HashSet<>();\n        nodes.add(null); // node1 will be at index 1, so add a null at index 0\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n\n        // Set edges for nodes\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(1);\n        nodes.get(3).edges.add(2);\n\n        // Test the method\n        int result = MColoring.possiblePaint(nodes, 3, 2);\n        assertEquals(1, result);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create nodes\n        Node node1 = new Node();\n        node1.color = 1;\n        node1.edges = new HashSet<>();\n        node1.edges.add(2);\n\n        Node node2 = new Node();\n        node2.color = 2;\n        node2.edges = new HashSet<>();\n        node2.edges.add(1);\n\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(null); // Index 0 is not used\n        nodes.add(node1); // Index 1\n        nodes.add(node2); // Index 2\n\n        // Test possiblePaint() method\n        int result = MColoring.possiblePaint(nodes, 2, 2);\n        Assertions.assertEquals(1, result);\n    }\n}",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    int n = 5;\n    int m = 3;\n    \n    // Create nodes and set color and edges\n    Node node1 = new Node();\n    node1.color = 1;\n    node1.edges = new HashSet<>(Arrays.asList(2, 3));  \n    \n    Node node2 = new Node();\n    node2.color = 2;\n    node2.edges = new HashSet<>(Arrays.asList(1, 3));\n    \n    Node node3 = new Node();\n    node3.color = 1;\n    node3.edges = new HashSet<>(Arrays.asList(1, 2));\n    \n    Node node4 = new Node();\n    node4.color = 2;\n    node4.edges = new HashSet<>(Arrays.asList(5));\n    \n    Node node5 = new Node();\n    node5.color = 1;\n    node5.edges = new HashSet<>(Arrays.asList(4));\n    \n    nodes.add(node1);\n    nodes.add(node2);\n    nodes.add(node3);\n    nodes.add(node4);\n    nodes.add(node5);\n    \n    int expectedResult = 1;\n    int actualResult = MColoring.possiblePaint(nodes, n, m);\n    \n    assertEquals(expectedResult, actualResult);\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class NodeTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node0 = new Node();\n        node0.color = 1;\n        node0.edges = new HashSet<>();\n        nodes.add(node0);\n\n        Node node1 = new Node();\n        node1.color = 2;\n        node1.edges = new HashSet<>();\n        nodes.add(node1);\n        \n        // Create any number of nodes (assuming 8)\n        Node node2 = new Node();\n        node2.color = 1;\n        node2.edges = new HashSet<>();\n        nodes.add(node2);\n\n        Node node3 = new Node();\n        node3.color = 3;\n        node3.edges = new HashSet<>();\n        nodes.add(node3);\n\n        // Create any number of edges between nodes (assuming 5)\n        node0.edges.add(1);\n        node0.edges.add(2);\n        node1.edges.add(0);\n        node1.edges.add(2);\n        node1.edges.add(3);\n        node2.edges.add(0);\n        node2.edges.add(1);\n        node2.edges.add(3);\n        node3.edges.add(1);\n        node3.edges.add(2);\n\n        int n = nodes.size() - 1;\n        int m = 3;\n\n        int expectedOutput = 1; // Define the expected output\n        int actualOutput = MColoring.possiblePaint(nodes, n, m); // Call the method to be tested\n        assertEquals(expectedOutput, actualOutput); // Verify\n        \n        // Add more test cases if needed\n        // ...\n    }\n}"
    ]
}