Source code: 


ArrayList<E> topSortOrder() {
    calculateInDegree();
    Queue<E> q = new LinkedList<E>();

    for (E vertex : inDegree.keySet()) {
        if (inDegree.get(vertex) == 0) {
            q.add(vertex);
        }
    }

    ArrayList<E> answer = new ArrayList<>();

    while (!q.isEmpty()) {
        E current = q.poll();
        answer.add(current);
        for (E adjacent : graph.getAdjacents(current)) {
            inDegree.put(adjacent, inDegree.get(adjacent) - 1);
            if (inDegree.get(adjacent) == 0) {
                q.add(adjacent);
            }
        }
    }

    return answer;
}



No.1 generated result --------------------------

package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

public class AdjacencyListTest {
    @Test
    public void topSortOrderTest() {
        AdjacencyList<Integer> graph = new AdjacencyList<>(); // Assuming the AdjacencyList class is parameterized with Integer
        graph.addEdge(1, 2);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        ArrayList<Integer> expected = new ArrayList<>();
        expected.add(1);
        expected.add(2);
        expected.add(3);
        expected.add(4);

        ArrayList<Integer> actual = graph.topSortOrder();

        assertEquals(expected, actual);
    }
}


No.2 generated result --------------------------

package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

public class AdjacencyListTest {
    @Test
    public void topSortOrderTest() {
        AdjacencyList<Integer> graph = new AdjacencyList<>();
        // Add test data to the graph

        ArrayList<Integer> expected = new ArrayList<>();
        expected.add(1);
        expected.add(2);
        expected.add(3);
        expected.add(4);
        expected.add(5);

        assertEquals(expected, graph.topSortOrder());
    }
}


No.3 generated result --------------------------

@Test
public void topSortOrderTest() {
    ArrayList<Integer> expected = new ArrayList<>();
    expected.add(1);
    expected.add(2);
    expected.add(4);
    expected.add(3);
    
    ArrayList<Integer> actual = new AdjacencyList().topSortOrder();
    
    assertEquals(expected, actual);
}


No.4 generated result --------------------------

@Test
public void topSortOrderTest() {
    AdjacencyList<String> graph = new AdjacencyList<>();
    // Add vertices and edges to the graph

    ArrayList<String> expected = new ArrayList<>();
    expected.add("A");
    expected.add("B");
    expected.add("C");

    ArrayList<String> result = graph.topSortOrder();

    assertEquals(expected, result);
}


No.5 generated result --------------------------

ArrayList<E> graph = new ArrayList<>(); // create a graph
        graph.add(new E()); // add vertices to the graph
        graph.add(new E());
        graph.add(new E());
        graph.add(new E());

        // add edges to the graph
        graph.get(0).addAdjacent(graph.get(1));
        graph.get(0).addAdjacent(graph.get(3));
        graph.get(1).addAdjacent(graph.get(2));

        // create an instance of the class that contains the topSortOrder() method
        ClassName className = new ClassName();

        // invoke the topSortOrder() method and obtain the result
        ArrayList<E> result = className.topSortOrder();

        // create an array list containing the expected order of vertices after topological sorting
        ArrayList<E> expected = new ArrayList<>();
        expected.add(graph.get(0)); // vertex 0 will be the first one after topological sorting
        expected.add(graph.get(1)); // vertex 1 will be the second one after topological sorting
        expected.add(graph.get(2)); // vertex 2 will be the third one after topological sorting
        expected.add(graph.get(3)); // vertex 3 will be the fourth one after topological sorting

        // compare the result with the expected order of vertices
        assertEquals(expected, result);


No.6 generated result --------------------------

package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class AdjacencyListTest {
    @Test
    public void topSortOrderTest() {
        ArrayList<Integer> expected = new ArrayList<>();
        expected.add(1);
        expected.add(2);
        expected.add(3);
        
        AdjacencyList<Integer> graph = new AdjacencyList<>();
        // Add vertices and edges to the graph
        
        ArrayList<Integer> actual = graph.topSortOrder();
        assertEquals(expected, actual);
    }
}


No.7 generated result --------------------------

package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class AdjacencyListTest {
    @Test
    public void topSortOrderTest() {
        AdjacencyList<String> graph = new AdjacencyList<>();
        graph.addEdge("A", "B");
        graph.addEdge("B", "C");
        graph.addEdge("C", "D");
        graph.addEdge("D", "E");
        graph.addEdge("E", "F");
        
        ArrayList<String> expected = new ArrayList<>();
        expected.add("A");
        expected.add("B");
        expected.add("C");
        expected.add("D");
        expected.add("E");
        expected.add("F");
        
        ArrayList<String> actual = graph.topSortOrder();
        
        assertEquals(expected, actual);
    }
}


No.8 generated result --------------------------

In order to complete the unit test for the given Java source code, you can follow the steps below:

package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Arrays;

public class AdjacencyListTest {
    @Test
    public void topSortOrderTest() {
        // Create an instance of the AdjacencyList class
        AdjacencyList<Integer> graph = new AdjacencyList<>();
        
        // Add vertices to the graph
        graph.addVertex(1);
        graph.addVertex(2);
        graph.addVertex(3);
        graph.addVertex(4);
        
        // Add edges to the graph
        graph.addEdge(1, 2);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);
        
        // Calculate the topological sort of the graph
        ArrayList<Integer> expectedResult = new ArrayList<>(Arrays.asList(1, 2, 3, 4));
        ArrayList<Integer> actualResult = graph.topSortOrder();
        
        // Assert that the actual result matches the expected result
        assertEquals(expectedResult, actualResult);
    }
}


No.9 generated result --------------------------

@Test
public void topSortOrderTest() {
    // Given
    ArrayList<E> expected = new ArrayList<>();
    expected.add(vertex1);
    expected.add(vertex2);
    expected.add(vertex3);
    expected.add(vertex4);
  
    // When
    ArrayList<E> result = adjList.topSortOrder();
    
    // Then
    assertEquals(expected, result);
}


No.10 generated result --------------------------

@Test
    public void topSortOrderTest() {
        AdjacencyList<Integer> graph = new AdjacencyList<>();
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 4);
        graph.addEdge(3, 4);
        
        ArrayList<Integer> expected = new ArrayList<>();
        expected.add(1);
        expected.add(2);
        expected.add(3);
        expected.add(4);
        
        ArrayList<Integer> actual = graph.topSortOrder();
        
        assertEquals(expected, actual);
    }


