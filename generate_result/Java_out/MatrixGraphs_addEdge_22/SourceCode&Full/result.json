{
    "project_name": "Java",
    "file_name": "MatrixGraphs.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/MatrixGraphs.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.graphs",
    "docstring": "/**\n     * This method adds an edge to the graph between two specified vertices\n     *\n     * @param from the data of the vertex the edge is from\n     * @param to the data of the vertex the edge is going to\n     * @return returns true if the edge did not exist, return false if it\n     * already did\n     */",
    "source_code": "\npublic boolean addEdge(int from, int to) {\n    if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) {\n        if (!this.adjacencyOfEdgeDoesExist(from, to)) {\n            this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_EXIST;\n            this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_EXIST;\n            this.setNumberOfEdges(this.numberOfEdges() + 1);\n            return true;\n        }\n    }\n\n    return false;\n}\n",
    "class_name": "MatrixGraphs",
    "method_name": "addEdge",
    "arguments": [
        "int from",
        "int to"
    ],
    "generate_test": [
        "\npublic boolean addEdge(int from, int to) {\n    if (!vertexDoesExist(from)) {\n        throw new IllegalArgumentException(\"Vertex \" + from + \" does not exist in this graph.\");\n    } else if (!vertexDoesExist(to)) {\n        throw new IllegalArgumentException(\"Vertex \" + to + \" does not exist in this graph.\");\n    } else if (adjacencyOfEdgeDoesExist(from, to)) {\n        return false; // Edge already exists. No need to add again.\n    }\n\n    int[][] adjacency = _adjacency;\n    boolean directed = _directed;\n    boolean weighted = _weighted;\n    int numberOfVertices = _numberOfVertices;\n\n    // Add the edge to both vertices:\n    adjacency[from][to] = EDGE_EXIST;\n    if (!directed) {\n        adjacency[to][from] = EDGE_EXIST;\n    }\n\n    // Update the number of edges in the graph:\n    setNumberOfEdges(numberOfEdges() + 1);\n\n    return true;\n}\n",
        "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MatrixGraphTest {\n    @Test\n    public void addEdge() {\n        // Set up graph with 3 vertices and no edges\n        int numVertices = 3;\n        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(numVertices);\n        \n        // Add edge from vertex 0 to vertex 2\n        graph.addEdge(0, 2);\n        \n        // Check that the number of edges is updated correctly\n        assertEquals(1, graph.numberOfEdges());\n        \n        // Check that the adjacency matrix indices are properly updated\n        int[][] adjMatrix = graph.adjacency();\n        assertTrue(adjMatrix[0][2] == AdjacencyMatrixGraph.EDGE_EXIST);\n        assertTrue(adjMatrix[2][0] == AdjacencyMatrixGraph.EDGE_EXIST);\n    }\n}",
        "    package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MatrixGraphsTest {\n    private MatrixGraph graph = new MatrixGraph(5);\n\n    @Test\n    public void addEdgeTest() {\n        assertTrue(graph.addEdge(0, 1));\n        assertEquals(\"Expected value of edge(0,1) to be 1 but was \" + graph.getEdge(0, 1), 1, graph.getEdge(0, 1));\n    }\n}",
        "\npackage com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MatrixGraphsTest {\n    @Test\n    public void addEdgeTest() {\n        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(4);\n        assertEquals(0, graph.numberOfEdges());\n        graph.addEdge(1, 2);\n        assertEquals(1, graph.numberOfEdges());\n    }\n}\n",
        "Timeout",
        "public void addEdge(int from, int to)",
        "\n/**\n * Adds a directed edge from vertex v to vertex w in this graph.\n */\npublic void addEdge(int v, int w) {\n    validateVertex(v);\n    validateVertex(w);\n    _adjacencyMatrix[v][w] = true;\n}\n",
        "<FILL>\n\n@Test\npublic void depthFirstOrderTest() {\n    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);\n    assertEquals(\"[0, 2, 5, 7, 8, 9]\", graph.depthFirstOrder(0).toString());\n}\n\n@Test\npublic void breadthFirstOrderTest() {\n    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);\n    assertEquals(\"[0, 2, 5, 7, 8, 9]\", graph.breadthFirstOrder(0).toString());\n}\n\n@Test\npublic void removeEdgeTest() {\n    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);\n    assertTrue(graph.addEdge(0, 2));\n    assertTrue(graph.removeEdge(0, 2));\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\n\n/**\n * This class is a implementation of Adjacency Matrix Graph Data Structure\n */\npublic class MatrixGraph {\n    private static final int EDGE_NONE = 0, EDGE_EXIST = 1;\n    private final int _numberOfVertices; // Number of vertices in graph\n    private final int[][] _adjacency; // Adjacency matrix\n\n    public MatrixGraph(int numberOfVertices) {\n        this._numberOfVertices = numberOfVertices;\n        this._adjacency = new int[numberOfVertices][numberOfVertices];\n    }\n\n    /**\n     * Return the adjacency matrix\n     */\n    public int[][] adjacency() {\n        return this._adjacency;\n    }\n\n    /**\n     * Get number of vertices\n     *\n     * @return number of vertices in graph\n     */\n    public int numberOfVertices() {\n        return this._numberOfVertices;\n    }\n\n    /**\n     * Get number of edges\n     *\n     * @return the total number of edges in graph\n     */\n    public int numberOfEdges() {\n        int numEdges = 0;\n        for (int i = 0; i < _numberOfVertices; ++i) {\n            for (int j = 0; j < _numberOfVertices; ++j) {\n                if (_adjacency[i][j] == EDGE_EXIST) {\n                    numEdges++;\n                }\n            }\n        }\n        return numEdges / 2; // Because edges are stored twice (once for each vertex)\n    }\n\n    /**\n     * Adds a directed edge to the graph. This edge is represented as an array of vertices [from, to]\n     * Returns false if the edge could not be created due to vertex constraints.\n     */\n    public boolean addEdge(int[] edge) {\n        int from = edge[0]; // First vertex in edge\n        int to = edge[1]; // Second vertex in edge\n        return this.addEdge(from, to);\n    }\n\n    /**\n     * Adds a directed edge to the graph. Returns false if the edge could not be created due to vertex constraints.\n     */\n    public boolean addEdge(int from, int to) {\n        if (this.vertexDoesExist(from < 0 || from >= this._numberOfVertices)\n                || (to < 0 || to >= this._numberOfVertices))) {\n            return false; // If any vertex index is out of range [0, numberOfVertices)\n        } else if (!this.adjacent(from, to)) { // If edge already exists\n            this._adjacency[from][to] = EDGE_EXIST;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns whether an edge exists between two vertices.\n     */\n    public boolean adjacent(int from, int to) {\n        if (this._adjacency[from][to] == EDGE_EXIST) { // If edge exists\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns whether a vertex exists in the graph.\n     */\n    public boolean vertexExists(int index) {\n        if (index >= 0 && index < this._numberOfVertices) { // If vertex is within range [0, numberOfVertices)\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns whether an edge exists between two vertices.\n     */\n    public boolean edgesExists(int from, int to) {\n        if (this.adjacent(from, to)) { // If edge already exists\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a list of all the vertices in the graph.\n     */\n    public ArrayList<Integer> getAllVertices() {\n        ArrayList<Integer> result = new ArrayList<>(); // Initialize empty array to store results in\n        for (int i = 0; i < this._numberOfVertices; i++) { // Iterate over all vertices\n            result.add(i); // Add vertex index to results arraylist\n        }\n        return result; // Return results arraylist\n    }\n\n    /**\n     * Returns a list of all the edges in the graph. An edge is represented as an array [from, to].\n     */\n    public ArrayList<int[]> getAllEdges() {\n        ArrayList<Integer[]> result = new ArrayList<>(); // Initialize empty array to store results in\n        for (int i = 0; i < this._numberOfVertices - 1; i++) { // Iterate over all vertices except the last vertex\n            int from = i; // Get first vertex index in edge\n            int to = i + 1; // Get second vertex index in edge\n            result.add(new Integer[]{from, to}); // Add edge [from, to] to results arraylist\n        }\n        return result; // Return results arraylist\n    }\n}",
        "Please find below a possible solution for the \"add edge\" test case:\n\nimport com.thealgorithms.datastructures.graphs.*;\n\npublic class MatrixGraphTest {\n    @Test\n    public void addEdgeTest() {\n        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(3); // initialize a graph with 3 vertices\n\n        assertFalse(graph.adjacencyOfEdgeDoesExist(0, 1)); // assert that there is no edge between vertex 0 and vertex 1\n        graph.addEdge(0, 1); // add an edge between vertex 0 and vertex 1\n        assertTrue(graph.adjacencyOfEdgeDoesExist(0, 1)); // assert that the edge exists between vertex 0 and vertex 1\n    }\n}\n    \n### Response:"
    ]
}