Source code: 


public boolean addEdge(int from, int to) {
    if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) {
        if (!this.adjacencyOfEdgeDoesExist(from, to)) {
            this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_EXIST;
            this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_EXIST;
            this.setNumberOfEdges(this.numberOfEdges() + 1);
            return true;
        }
    }

    return false;
}



No.1 generated result --------------------------


public boolean addEdge(int from, int to) {
    if (!vertexDoesExist(from)) {
        throw new IllegalArgumentException("Vertex " + from + " does not exist in this graph.");
    } else if (!vertexDoesExist(to)) {
        throw new IllegalArgumentException("Vertex " + to + " does not exist in this graph.");
    } else if (adjacencyOfEdgeDoesExist(from, to)) {
        return false; // Edge already exists. No need to add again.
    }

    int[][] adjacency = _adjacency;
    boolean directed = _directed;
    boolean weighted = _weighted;
    int numberOfVertices = _numberOfVertices;

    // Add the edge to both vertices:
    adjacency[from][to] = EDGE_EXIST;
    if (!directed) {
        adjacency[to][from] = EDGE_EXIST;
    }

    // Update the number of edges in the graph:
    setNumberOfEdges(numberOfEdges() + 1);

    return true;
}



No.2 generated result --------------------------

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MatrixGraphTest {
    @Test
    public void addEdge() {
        // Set up graph with 3 vertices and no edges
        int numVertices = 3;
        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(numVertices);
        
        // Add edge from vertex 0 to vertex 2
        graph.addEdge(0, 2);
        
        // Check that the number of edges is updated correctly
        assertEquals(1, graph.numberOfEdges());
        
        // Check that the adjacency matrix indices are properly updated
        int[][] adjMatrix = graph.adjacency();
        assertTrue(adjMatrix[0][2] == AdjacencyMatrixGraph.EDGE_EXIST);
        assertTrue(adjMatrix[2][0] == AdjacencyMatrixGraph.EDGE_EXIST);
    }
}


No.3 generated result --------------------------

    package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class MatrixGraphsTest {
    private MatrixGraph graph = new MatrixGraph(5);

    @Test
    public void addEdgeTest() {
        assertTrue(graph.addEdge(0, 1));
        assertEquals("Expected value of edge(0,1) to be 1 but was " + graph.getEdge(0, 1), 1, graph.getEdge(0, 1));
    }
}


No.4 generated result --------------------------


package com.thealgorithms.datastructures.graphs;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class MatrixGraphsTest {
    @Test
    public void addEdgeTest() {
        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(4);
        assertEquals(0, graph.numberOfEdges());
        graph.addEdge(1, 2);
        assertEquals(1, graph.numberOfEdges());
    }
}



No.5 generated result --------------------------

Timeout


No.6 generated result --------------------------

public void addEdge(int from, int to)


No.7 generated result --------------------------


/**
 * Adds a directed edge from vertex v to vertex w in this graph.
 */
public void addEdge(int v, int w) {
    validateVertex(v);
    validateVertex(w);
    _adjacencyMatrix[v][w] = true;
}



No.8 generated result --------------------------

<FILL>

@Test
public void depthFirstOrderTest() {
    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);
    assertEquals("[0, 2, 5, 7, 8, 9]", graph.depthFirstOrder(0).toString());
}

@Test
public void breadthFirstOrderTest() {
    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);
    assertEquals("[0, 2, 5, 7, 8, 9]", graph.breadthFirstOrder(0).toString());
}

@Test
public void removeEdgeTest() {
    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);
    assertTrue(graph.addEdge(0, 2));
    assertTrue(graph.removeEdge(0, 2));
}


No.9 generated result --------------------------

package com.thealgorithms.datastructures.graphs;

import java.util.ArrayList;

/**
 * This class is a implementation of Adjacency Matrix Graph Data Structure
 */
public class MatrixGraph {
    private static final int EDGE_NONE = 0, EDGE_EXIST = 1;
    private final int _numberOfVertices; // Number of vertices in graph
    private final int[][] _adjacency; // Adjacency matrix

    public MatrixGraph(int numberOfVertices) {
        this._numberOfVertices = numberOfVertices;
        this._adjacency = new int[numberOfVertices][numberOfVertices];
    }

    /**
     * Return the adjacency matrix
     */
    public int[][] adjacency() {
        return this._adjacency;
    }

    /**
     * Get number of vertices
     *
     * @return number of vertices in graph
     */
    public int numberOfVertices() {
        return this._numberOfVertices;
    }

    /**
     * Get number of edges
     *
     * @return the total number of edges in graph
     */
    public int numberOfEdges() {
        int numEdges = 0;
        for (int i = 0; i < _numberOfVertices; ++i) {
            for (int j = 0; j < _numberOfVertices; ++j) {
                if (_adjacency[i][j] == EDGE_EXIST) {
                    numEdges++;
                }
            }
        }
        return numEdges / 2; // Because edges are stored twice (once for each vertex)
    }

    /**
     * Adds a directed edge to the graph. This edge is represented as an array of vertices [from, to]
     * Returns false if the edge could not be created due to vertex constraints.
     */
    public boolean addEdge(int[] edge) {
        int from = edge[0]; // First vertex in edge
        int to = edge[1]; // Second vertex in edge
        return this.addEdge(from, to);
    }

    /**
     * Adds a directed edge to the graph. Returns false if the edge could not be created due to vertex constraints.
     */
    public boolean addEdge(int from, int to) {
        if (this.vertexDoesExist(from < 0 || from >= this._numberOfVertices)
                || (to < 0 || to >= this._numberOfVertices))) {
            return false; // If any vertex index is out of range [0, numberOfVertices)
        } else if (!this.adjacent(from, to)) { // If edge already exists
            this._adjacency[from][to] = EDGE_EXIST;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Returns whether an edge exists between two vertices.
     */
    public boolean adjacent(int from, int to) {
        if (this._adjacency[from][to] == EDGE_EXIST) { // If edge exists
            return true;
        } else {
            return false;
        }
    }

    /**
     * Returns whether a vertex exists in the graph.
     */
    public boolean vertexExists(int index) {
        if (index >= 0 && index < this._numberOfVertices) { // If vertex is within range [0, numberOfVertices)
            return true;
        } else {
            return false;
        }
    }

    /**
     * Returns whether an edge exists between two vertices.
     */
    public boolean edgesExists(int from, int to) {
        if (this.adjacent(from, to)) { // If edge already exists
            return true;
        } else {
            return false;
        }
    }

    /**
     * Returns a list of all the vertices in the graph.
     */
    public ArrayList<Integer> getAllVertices() {
        ArrayList<Integer> result = new ArrayList<>(); // Initialize empty array to store results in
        for (int i = 0; i < this._numberOfVertices; i++) { // Iterate over all vertices
            result.add(i); // Add vertex index to results arraylist
        }
        return result; // Return results arraylist
    }

    /**
     * Returns a list of all the edges in the graph. An edge is represented as an array [from, to].
     */
    public ArrayList<int[]> getAllEdges() {
        ArrayList<Integer[]> result = new ArrayList<>(); // Initialize empty array to store results in
        for (int i = 0; i < this._numberOfVertices - 1; i++) { // Iterate over all vertices except the last vertex
            int from = i; // Get first vertex index in edge
            int to = i + 1; // Get second vertex index in edge
            result.add(new Integer[]{from, to}); // Add edge [from, to] to results arraylist
        }
        return result; // Return results arraylist
    }
}


No.10 generated result --------------------------

Please find below a possible solution for the "add edge" test case:

import com.thealgorithms.datastructures.graphs.*;

public class MatrixGraphTest {
    @Test
    public void addEdgeTest() {
        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(3); // initialize a graph with 3 vertices

        assertFalse(graph.adjacencyOfEdgeDoesExist(0, 1)); // assert that there is no edge between vertex 0 and vertex 1
        graph.addEdge(0, 1); // add an edge between vertex 0 and vertex 1
        assertTrue(graph.adjacencyOfEdgeDoesExist(0, 1)); // assert that the edge exists between vertex 0 and vertex 1
    }
}
    
### Response:


