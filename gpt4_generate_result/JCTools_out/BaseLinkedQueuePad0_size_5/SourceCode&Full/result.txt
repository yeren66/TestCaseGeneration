Source code: 


@Override
public final int size()
{
    // Read consumer first, this is important because if the producer is node is 'older' than the consumer
    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.
    LinkedQueueNode<E> chaserNode = lvConsumerNode();
    LinkedQueueNode<E> producerNode = lvProducerNode();
    int size = 0;
    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.
    while (chaserNode != producerNode && // don't go passed producer node
        chaserNode != null && // stop at last node
        size < Integer.MAX_VALUE) // stop at max int
    {
        LinkedQueueNode<E> next;
        next = chaserNode.lvNext();
        // check if this node has been consumed, if so return what we have
        if (next == chaserNode)
        {
            return size;
        }
        chaserNode = next;
        size++;
    }
    return size;
}



No.1 generated result --------------------------

null


No.2 generated result --------------------------

null


No.3 generated result --------------------------

null


No.4 generated result --------------------------

null


No.5 generated result --------------------------

null


No.6 generated result --------------------------

null


No.7 generated result --------------------------

null


No.8 generated result --------------------------

null


No.9 generated result --------------------------

null


No.10 generated result --------------------------

null


