Source code: 


private Object parseDictText(Object result) {
    if (result instanceof Result) {
        if (((Result) result).getResult() instanceof IPage) {
            List<JSONObject> items = new ArrayList<>();

            //step.1 筛选出加了 Dict 注解的字段列表
            List<Field> dictFieldList = new ArrayList<>();
            // 字典数据列表， key = 字典code，value=数据列表
            Map<String, List<String>> dataListMap = new HashMap<>(5);
            //取出结果集
            List<Object> records=((IPage) ((Result) result).getResult()).getRecords();
            //update-begin--Author:zyf -- Date:20220606 ----for：【VUEN-1230】 判断是否含有字典注解,没有注解返回-----
            Boolean hasDict= checkHasDict(records);
            if(!hasDict){
                return result;
            }

            log.debug(" __ 进入字典翻译切面 DictAspect —— " );
            //update-end--Author:zyf -- Date:20220606 ----for：【VUEN-1230】 判断是否含有字典注解,没有注解返回-----
            for (Object record : records) {
                String json="{}";
                try {
                    //update-begin--Author:zyf -- Date:20220531 ----for：【issues/#3629】 DictAspect Jackson序列化报错-----
                    //解决@JsonFormat注解解析不了的问题详见SysAnnouncement类的@JsonFormat
                     json = objectMapper.writeValueAsString(record);
                    //update-end--Author:zyf -- Date:20220531 ----for：【issues/#3629】 DictAspect Jackson序列化报错-----
                } catch (JsonProcessingException e) {
                    log.error("json解析失败"+e.getMessage(),e);
                }
                //update-begin--Author:scott -- Date:20211223 ----for：【issues/3303】restcontroller返回json数据后key顺序错乱 -----
                JSONObject item = JSONObject.parseObject(json, Feature.OrderedField);
                //update-end--Author:scott -- Date:20211223 ----for：【issues/3303】restcontroller返回json数据后key顺序错乱 -----

                //update-begin--Author:scott -- Date:20190603 ----for：解决继承实体字段无法翻译问题------
                //for (Field field : record.getClass().getDeclaredFields()) {
                // 遍历所有字段，把字典Code取出来，放到 map 里
                for (Field field : oConvertUtils.getAllFields(record)) {
                    String value = item.getString(field.getName());
                    if (oConvertUtils.isEmpty(value)) {
                        continue;
                    }
                //update-end--Author:scott  -- Date:20190603 ----for：解决继承实体字段无法翻译问题------
                    if (field.getAnnotation(Dict.class) != null) {
                        if (!dictFieldList.contains(field)) {
                            dictFieldList.add(field);
                        }
                        String code = field.getAnnotation(Dict.class).dicCode();
                        String text = field.getAnnotation(Dict.class).dicText();
                        String table = field.getAnnotation(Dict.class).dictTable();

                        List<String> dataList;
                        String dictCode = code;
                        if (!StringUtils.isEmpty(table)) {
                            dictCode = String.format("%s,%s,%s", table, text, code);
                        }
                        dataList = dataListMap.computeIfAbsent(dictCode, k -> new ArrayList<>());
                        this.listAddAllDeduplicate(dataList, Arrays.asList(value.split(",")));
                    }
                    //date类型默认转换string格式化日期
                    //update-begin--Author:zyf -- Date:20220531 ----for：【issues/#3629】 DictAspect Jackson序列化报错-----
                    //if (JAVA_UTIL_DATE.equals(field.getType().getName())&&field.getAnnotation(JsonFormat.class)==null&&item.get(field.getName())!=null){
                        //SimpleDateFormat aDate=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                        // item.put(field.getName(), aDate.format(new Date((Long) item.get(field.getName()))));
                    //}
                    //update-end--Author:zyf -- Date:20220531 ----for：【issues/#3629】 DictAspect Jackson序列化报错-----
                }
                items.add(item);
            }

            //step.2 调用翻译方法，一次性翻译
            Map<String, List<DictModel>> translText = this.translateAllDict(dataListMap);

            //step.3 将翻译结果填充到返回结果里
            for (JSONObject record : items) {
                for (Field field : dictFieldList) {
                    String code = field.getAnnotation(Dict.class).dicCode();
                    String text = field.getAnnotation(Dict.class).dicText();
                    String table = field.getAnnotation(Dict.class).dictTable();

                    String fieldDictCode = code;
                    if (!StringUtils.isEmpty(table)) {
                        fieldDictCode = String.format("%s,%s,%s", table, text, code);
                    }

                    String value = record.getString(field.getName());
                    if (oConvertUtils.isNotEmpty(value)) {
                        List<DictModel> dictModels = translText.get(fieldDictCode);
                        if(dictModels==null || dictModels.size()==0){
                            continue;
                        }

                        String textValue = this.translDictText(dictModels, value);
                        log.debug(" 字典Val : " + textValue);
                        log.debug(" __翻译字典字段__ " + field.getName() + CommonConstant.DICT_TEXT_SUFFIX + "： " + textValue);

                        // TODO-sun 测试输出，待删
                        log.debug(" ---- dictCode: " + fieldDictCode);
                        log.debug(" ---- value: " + value);
                        log.debug(" ----- text: " + textValue);
                        log.debug(" ---- dictModels: " + JSON.toJSONString(dictModels));

                        record.put(field.getName() + CommonConstant.DICT_TEXT_SUFFIX, textValue);
                    }
                }
            }

            ((IPage) ((Result) result).getResult()).setRecords(items);
        }

    }
    return result;
}



No.1 generated result --------------------------

package org.jeecg.common.aspect;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import com.alibaba.fastjson.JSONObject;
import java.lang.reflect.Field;
import java.util.*;

class DictAspectTest {
    private DictAspect dictAspect;
    private Result resultMock;
    private IPage iPageMock;
    private Object recordMock;

    @BeforeEach
    void setUp() {
        // Initialize the objects and mocks here, as assumptions are made
        // about the existence of these classes and the interaction with DictAspect
        
        dictAspect = new DictAspect();
        resultMock = mock(Result.class);        // Assuming Result is mockable
        iPageMock = mock(IPage.class);          // Assuming IPage is mockable
        recordMock = mock(Object.class);        // Create a mock record
        
        // Configure the mocks if needed
    }

    @Test
    public void parseDictTextTest() {
        // Given
        List<Object> records = Arrays.asList(recordMock);
        when(resultMock.getResult()).thenReturn(iPageMock);
        when(iPageMock.getRecords()).thenReturn(records);
        
        // Assume the mocked record contain dummy fields with @Dict annotations
        // You may need to define the annotation, field value retrieval etc.

        // When
        Object returnedResult = dictAspect.parseDictText(resultMock);

        // Then
        assertNotNull(returnedResult, "Returned result should not be null");
        // Perform assertions specific to your implementation details

        // Clean-up and mock verifications if needed
    }
    
    // Helper methods and classes for the test
    // Define mock(), or ensure a mocking library such as Mockito is imported and used
    
    // You may need to create additional classes and mocks to simulate the behaviour
    // of omitted classes such as Result, IPage, oConvertUtils, Dict, etc.
}


No.2 generated result --------------------------

package org.jeecg.common.aspect;

import com.alibaba.fastjson.JSONObject;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.jeecg.common.aspect.annotation.Dict;
import org.jeecg.common.util.CommonConstant;
import org.jeecg.common.util.oConvertUtils;
import org.jeecg.modules.system.model.DictModel;
import org.jeecg.modules.system.service.ISysDictService;
import org.jeecg.modules.system.vo.Result;
import org.jeecgframework.core.util.JsonFormat;

import java.lang.reflect.Field;
import java.text.SimpleDateFormat;
import java.util.*;

public class DictAspectTest {

    private DictAspect dictAspect;
    private ISysDictService dictService;

    @BeforeEach
    public void setUp() {
        dictService = Mockito.mock(ISysDictService.class);
        dictAspect = new DictAspect(dictService);
    }

    @Test
    public void parseDictTextTest() {
        // Mockito setup for ISysDictService if necessary
        // Assuming ISysDictService is used and needs to be mocked
        DictModel dictModel = new DictModel("testValue", "Test Text");
        List<DictModel> dictModelList = new ArrayList<>();
        dictModelList.add(dictModel);
        Mockito.when(dictService.queryDictItemsByCode(Mockito.anyString())).thenReturn(dictModelList);

        // Assuming the following classes exist based on the method being tested
        IPage<?> page = Mockito.mock(IPage.class);
        Result<?> mockResult = new Result<>();
        mockResult.setResult(page);

        // Assuming 'record' is a simple mocked POJO for testing (needs to be replaced with a proper 'record' instance)
        List<Object> records = new ArrayList<>();
        Object record = Mockito.mock(Object.class);
        records.add(record);

        Mockito.when(page.getRecords()).thenReturn(records);

        // Mocked method 'translateAllDict' - assuming it's part of the DictAspect class
        Map<String, List<DictModel>> translatedTexts = new HashMap<>();
        translatedTexts.put("testCode", dictModelList);
        Mockito.doReturn(translatedTexts).when(dictAspect).translateAllDict(Mockito.anyMap());

        // Mocked method 'translDictText' - assuming it's part of the DictAspect class
        Mockito.doReturn("Test Text").when(dictAspect).translDictText(Mockito.anyList(), Mockito.anyString());

        // Create a Dict annotated field
        Field dictAnnotatedField = Mockito.mock(Field.class);
        Dict dictAnnotation = Mockito.mock(Dict.class);
        Mockito.when(dictAnnotation.dicCode()).thenReturn("testCode");
        Mockito.when(dictAnnotation.dicText()).thenReturn("testText");
        Mockito.when(dictAnnotation.dictTable()).thenReturn("");
        Mockito.when(dictAnnotatedField.getAnnotation(Dict.class)).thenReturn(dictAnnotation);
        Mockito.when(dictAnnotatedField.getName()).thenReturn("testField");

        // Invoke the method under test
        Object result = dictAspect.parseDictText(mockResult);

        // Assertions and verifications
        Mockito.verify(dictService, Mockito.times(1)).queryDictItemsByCode(Mockito.anyString());
        assertNotNull(result);
        assertTrue(result instanceof Result);
        @SuppressWarnings("unchecked") // Assuming safe cast based on mock setup
        List<JSONObject> resultRecords = (List<JSONObject>) ((Result<?>) result).getResult().getRecords();
        assertFalse(resultRecords.isEmpty());
        JSONObject jsonRecord = resultRecords.get(0);
        assertEquals("Test Text", jsonRecord.getString("testField" + CommonConstant.DICT_TEXT_SUFFIX));
    }
}


No.3 generated result --------------------------

package org.jeecg.common.aspect;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import org.mockito.*;
import java.lang.reflect.Field;
import java.util.*;

public class DictAspectTest {

    private DictAspect dictAspect;
    private Result mockResult;
    private IPage mockPage;
    private List<Object> records;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() throws Exception {
        // Create a new DictAspect object to be used in tests
        dictAspect = new DictAspect();
        // Initialize ObjectMapper instance or mock if needed for serialization
        objectMapper = new ObjectMapper();
        // Mock the Result object to simulate the real behavior
        mockResult = Mockito.mock(Result.class);
        // Mock the IPage object to simulate the pagination
        mockPage = Mockito.mock(IPage.class);
        // Create a fake record list that would normally be populated in the real object
        records = new ArrayList<>();
        // Add a mock object (which should be your custom object that holds result data) to the list
        records.add(new YourCustomResultObject());
        // Configure the mock IPage to return the fake records list
        Mockito.when(mockPage.getRecords()).thenReturn(records);
        // Configure the mock Result to return the mock IPage when getResult is called
        Mockito.when(mockResult.getResult()).thenReturn(mockPage);
        // Assuming DictAspect has a method setObjectMapper to set the ObjectMapper instance
        dictAspect.setObjectMapper(objectMapper);
    }

    @Test
    public void parseDictTextTest() {
        // Pass the mock result to the method we want to test
        Object result = dictAspect.parseDictText(mockResult);

        // Verify the mock interactions
        Mockito.verify(mockPage, Mockito.times(1)).getRecords();
        Mockito.verify(mockResult, Mockito.times(2)).getResult();

        // Assert that the result is still a Result instance
        assertTrue(result instanceof Result);

        // The below assertions need to be customized based on your actual IPage and Result object expected state
        Result parsedResult = (Result) result;
        IPage parsedPage = (IPage) parsedResult.getResult();
        assertNotNull(parsedPage);
        List<Object> parsedRecords = parsedPage.getRecords();
        assertNotNull(parsedRecords);

        // Here you would assert the state of your custom objects within the records list
        // For example, if DictAspect was supposed to modify an attribute in your objects, assert that change here
        // Assuming you're expecting a 'translatedText' field after parseDictText is called
        for (Object record : parsedRecords) {
            YourCustomResultObject yourObject = (YourCustomResultObject) record;
            assertNotNull(yourObject.getTranslatedText(), "The translated text should not be null after parsing");
        }
    }

    // This class needs to be replaced with the actual object type that's used in the records list.
    // Replace this with your actual class that contains the fields and methods that DictAspect interacts with.
    class YourCustomResultObject {
        // Example fields and methods to resemble a real object
        private String translatedText;

        public String getTranslatedText() {
            return translatedText;
        }

        public void setTranslatedText(String translatedText) {
            this.translatedText = translatedText;
        }
    }
}


