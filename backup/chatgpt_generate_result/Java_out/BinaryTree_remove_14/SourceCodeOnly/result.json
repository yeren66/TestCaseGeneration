{
    "project_name": "Java",
    "file_name": "BinaryTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": "/**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */",
    "source_code": "\npublic boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n\n            temp.right.parent = temp.parent;\n\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n\n            temp.left.parent = temp.parent;\n\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}\n",
    "class_name": "BinaryTree",
    "method_name": "remove",
    "arguments": [
        "int value"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        BinaryTree binaryTree = new BinaryTree();\n        \n        // Add test values to the binary tree\n        \n        // Test removing a value that doesn't exist\n        assertFalse(binaryTree.remove(<non-existing-value>));\n        \n        // Test removing a value with no children\n        assertTrue(binaryTree.remove(<value-with-no-children>));\n        \n        // Test removing a value with two children\n        assertTrue(binaryTree.remove(<value-with-two-children>));\n        \n        // Test removing a value with one child\n        assertTrue(binaryTree.remove(<value-with-one-child>));\n        \n        // Test removing the root\n        assertTrue(binaryTree.remove(binaryTree.getRoot().data));\n    }\n}",
        "@Test\npublic void removeTest() {\n    BinaryTree tree = new BinaryTree();\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(8);\n    tree.insert(2);\n    tree.insert(4);\n    tree.insert(7);\n    tree.insert(9);\n\n    assertTrue(tree.remove(4));\n    assertFalse(tree.remove(6));\n    assertTrue(tree.remove(8));\n    assertFalse(tree.remove(8));\n    assertTrue(tree.remove(5));\n}",
        "@Test\npublic void removeTest() {\n    BinaryTree tree = new BinaryTree();\n    \n    // Add nodes to the binary tree\n    \n    // Test case 1: Remove a node with no children\n    assertTrue(tree.remove(<value>));\n    \n    // Test case 2: Remove a node with two children\n    assertTrue(tree.remove(<value>));\n    \n    // Test case 3: Remove a node with one child\n    assertTrue(tree.remove(<value>));\n    \n    // Test case 4: Remove the root node\n    assertTrue(tree.remove(<value>));\n}",
        "Node root;\n\n@BeforeEach\npublic void setUp() {\n    // Set up the binary tree\n    root = new Node(5);\n    root.left = new Node(3);\n    root.right = new Node(7);\n    root.left.parent = root;\n    root.right.parent = root;\n}\n\n@Test\npublic void removeTest() {\n    // Test case 1: Remove a leaf node (no children)\n    assertTrue(remove(3));\n    assertNull(root.left);\n    \n    // Test case 2: Remove a node with two children\n    assertTrue(remove(5));\n    assertEquals(7, root.data);\n    assertNull(root.left);\n    assertNull(root.right.left);\n    \n    // Test case 3: Remove a node with one child\n    assertTrue(remove(7));\n    assertNull(root.right);\n}\n\nprivate boolean remove(int value) {\n    // Implement the remove method here\n    // ...\n    return <FILL>;\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        BinaryTree tree = new BinaryTree();\n        \n        // Test case 1: Removing a node with no children\n        tree.insert(5);\n        boolean removed1 = tree.remove(5);\n        assertFalse(removed1);\n        \n        // Test case 2: Removing a node with two children\n        tree.insert(10);\n        tree.insert(5);\n        tree.insert(15);\n        tree.insert(3);\n        tree.insert(7);\n        tree.insert(12);\n        tree.insert(20);\n        boolean removed2 = tree.remove(10);\n        assertTrue(removed2);\n        \n        // Test case 3: Removing a node with one child\n        tree.insert(10);\n        tree.insert(8);\n        boolean removed3 = tree.remove(10);\n        assertTrue(removed3);\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    BinarySearchTree tree;\n\n    @BeforeEach\n    public void setup() {\n        tree = new BinarySearchTree();\n        // Add nodes to the tree for testing\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(70);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(60);\n        tree.insert(80);\n    }\n\n    @Test\n    public void removeTest() {\n        // Remove a leaf node\n        assertTrue(tree.remove(20));\n        assertNull(tree.search(20));\n\n        // Remove a node with one child\n        assertTrue(tree.remove(70));\n        assertNull(tree.search(70));\n\n        // Remove a node with two children\n        assertTrue(tree.remove(30));\n        assertNull(tree.search(30));\n\n        // Remove the root node\n        assertTrue(tree.remove(50));\n        assertNull(tree.search(50));\n\n        // Remove a non-existent node\n        assertFalse(tree.remove(100));\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        BinaryTree bt = new BinaryTree();\n        \n        // Insert nodes into the binary tree\n        \n        // Test removing a node that doesn't exist\n        assertFalse(bt.remove(10));\n        \n        // Test removing a node that is the only node in the tree\n        bt.insert(5);\n        assertTrue(bt.remove(5));\n        assertNull(bt.getRoot());\n        \n        // Test removing a node with no children\n        bt.insert(5);\n        bt.insert(3);\n        bt.insert(7);\n        assertTrue(bt.remove(3));\n        assertFalse(bt.contains(3));\n        \n        // Test removing a node with two children\n        bt.insert(5);\n        bt.insert(3);\n        bt.insert(7);\n        bt.insert(2);\n        bt.insert(4);\n        bt.insert(6);\n        bt.insert(8);\n        assertTrue(bt.remove(3));\n        assertFalse(bt.contains(3));\n        \n        // Test removing a node with only a left child\n        bt.insert(5);\n        bt.insert(3);\n        bt.insert(2);\n        bt.insert(4);\n        assertTrue(bt.remove(3));\n        assertFalse(bt.contains(3));\n        \n        // Test removing a node with only a right child\n        bt.insert(5);\n        bt.insert(3);\n        bt.insert(7);\n        bt.insert(6);\n        bt.insert(8);\n        assertTrue(bt.remove(7));\n        assertFalse(bt.contains(7));\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        BinaryTree tree = new BinaryTree();\n        \n        // Test Case 1: Removing a node with no children\n        tree.insert(10);\n        assertTrue(tree.remove(10)); // Remove the root\n        assertNull(tree.root); // Root should be null after removal\n        \n        // Test Case 2: Removing a node with two children\n        tree.insert(10);\n        tree.insert(5);\n        tree.insert(15);\n        assertTrue(tree.remove(10)); // Remove the root with two children\n        assertNotNull(tree.root); // Root should not be null after removal\n        \n        // Test Case 3: Removing a node with one child\n        tree.insert(10);\n        tree.insert(5);\n        assertTrue(tree.remove(10)); // Remove the root with one child\n        assertNotNull(tree.root); // Root should not be null after removal\n        \n        // Additional Test Cases can be added here\n        \n        <FILL>\n    }\n}",
        "    @Test\n    public void removeTest() {\n        BinaryTree binaryTree = new BinaryTree();\n        \n        binaryTree.insert(5);\n        binaryTree.insert(3);\n        binaryTree.insert(7);\n        binaryTree.insert(2);\n        binaryTree.insert(4);\n        \n        assertTrue(binaryTree.remove(2));\n        assertFalse(binaryTree.remove(6));\n        \n        BinaryTree expectedTree = new BinaryTree();\n        \n        expectedTree.insert(5);\n        expectedTree.insert(3);\n        expectedTree.insert(7);\n        expectedTree.insert(4);\n        \n        assertEquals(expectedTree.getRoot(), binaryTree.getRoot());\n    }",
        "public void removeTest() {\n    BinaryTree tree = new BinaryTree();\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(7);\n    tree.insert(2);\n    tree.insert(4);\n    tree.insert(6);\n    tree.insert(8);\n    \n    boolean result1 = tree.remove(4);\n    assertTrue(result1);\n    assertNull(tree.find(4));\n    \n    boolean result2 = tree.remove(7);\n    assertTrue(result2);\n    assertNull(tree.find(7));\n}"
    ]
}