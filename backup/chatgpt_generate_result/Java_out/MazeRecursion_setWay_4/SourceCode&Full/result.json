{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "int[][] map = new int[8][7];\n        \n// Set the ceiling and floor to 1\nfor (int i = 0; i < 7; i++) {\n    map[0][i] = 1;\n    map[7][i] = 1;\n}\n\n// Then we set the left and right wall to 1\nfor (int i = 0; i < 8; i++) {\n    map[i][0] = 1;\n    map[i][6] = 1;\n}\n\n// Here we set the obstacle\nmap[3][1] = 1;\nmap[3][2] = 1;\n\nboolean result = MazeRecursion.setWay(map, 1, 1);\n\nassertTrue(result);",
        "@Test\npublic void setWayTest() {\n    int[][] map = new int[][]{\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 0, 0, 1},\n            {1, 0, 0, 0, 1, 1, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 0, 0, 1, 0, 1},\n            {1, 1, 1, 1, 1, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n    };\n    boolean result = MazeRecursion.setWay(map, 1, 1);\n    assertTrue(result);\n}",
        "@Test\npublic void setWayTest() {\n    int[][] expectedMap = {\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 2, 2, 2, 2, 2, 1},\n        {1, 0, 0, 0, 0, 2, 1},\n        {1, 0, 1, 1, 0, 2, 1},\n        {1, 0, 1, 1, 0, 0, 1},\n        {1, 0, 2, 2, 2, 0, 1},\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 1, 1, 1, 1, 1, 1}\n    };\n\n    boolean result = MazeRecursion.setWay(new int[8][7], 1, 1);\n\n    assertTrue(result);\n    assertArrayEquals(expectedMap, map);\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = new int[8][7];\n    \n    for (int i = 0; i < 7; i++) {\n        map[0][i] = 1;\n        map[7][i] = 1;\n    }\n\n    for (int i = 0; i < 8; i++) {\n        map[i][0] = 1;\n        map[i][6] = 1;\n    }\n\n    map[3][1] = 1;\n    map[3][2] = 1;\n\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n    \n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 7; j++) {\n            assertTrue(map[i][j] == 2 || map[i][j] == 3);\n        }\n    }\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {{1, 1, 1, 1, 1, 1, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 0, 1, 1, 0, 0, 1},\n                   {1, 0, 1, 1, 0, 0, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 1, 1, 1, 1, 1, 1},\n                   {1, 1, 1, 1, 1, 1, 1},\n                   {1, 1, 1, 1, 1, 1, 1}};\n    \n    boolean result = MazeRecursion.setWay(map, 1, 1);\n    \n    assertTrue(result);\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[8][7];\n        \n        // Initialize the map\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1] = 1;\n        map[3][2] = 1;\n        \n        // Run the setWay method\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        \n        // Verify the result\n        assertTrue(result);\n        \n        // Verify the changes made to the map\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 0, 0, 0, 0, 1},\n            {1, 2, 2, 2, 0, 0, 1},\n            {1, 1, 1, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        assertArrayEquals(expectedMap, map);\n    }\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = new int[][] {\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0, 1},\n        {1, 0, 1, 1, 0, 1, 1},\n        {1, 0, 1, 1, 0, 0, 1},\n        {1, 0, 0, 0, 1, 0, 1},\n        {1, 0, 1, 1, 1, 0, 1},\n        {1, 1, 1, 1, 1, 2, 1},\n        {1, 1, 1, 1, 1, 1, 1}\n    };\n    boolean result = MazeRecursion.setWay(map, 1, 1);\n    assertTrue(result);\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[8][7];\n        \n        // Initialize the map\n        \n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Set the left and right walls to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Set the expected result\n        boolean expectedResult = true;\n\n        // Call the method to test\n        boolean actualResult = MazeRecursion.setWay(map, 1, 1);\n\n        // Assert the result\n        assertEquals(expectedResult, actualResult);\n    }\n}",
        "@Test\npublic void setWayTest() {\n    int[][] maze = new int[8][7];\n    for (int i = 0; i < 7; i++) {\n        maze[0][i] = 1;\n        maze[7][i] = 1;\n    }\n    for (int i = 0; i < 8; i++) {\n        maze[i][0] = 1;\n        maze[i][6] = 1;\n    }\n    maze[3][1] = 1;\n    maze[3][2] = 1;\n    \n    MazeRecursion.setWay(maze, 1, 1);\n    \n    int[][] expected = {\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 2, 0, 0, 0, 0, 1},\n        {1, 2, 2, 0, 0, 0, 1},\n        {1, 1, 1, 1, 0, 0, 1},\n        {1, 0, 0, 0, 0, 0, 1},\n        {1, 1, 0, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1, 2, 1},\n        {1, 1, 1, 1, 1, 3, 1}\n    };\n    \n    assertArrayEquals(expected, maze);\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = new int[8][7];\n    // Set the maze map with obstacles and walls\n    // ... (initialize the maze map)\n    \n    boolean result = MazeRecursion.setWay(map, 1, 1);\n    \n    assertTrue(result);\n    // Assert the expected values in the map after the ball's path is found\n    // ... (assertions)\n}"
    ]
}