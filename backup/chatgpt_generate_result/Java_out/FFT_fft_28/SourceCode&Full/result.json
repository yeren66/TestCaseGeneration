{
    "project_name": "Java",
    "file_name": "FFT.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.maths",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
    "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
    "class_name": "FFT",
    "method_name": "fft",
    "arguments": [
        "ArrayList<Complex> x",
        "boolean inverse"
    ],
    "generate_test": [
        "@Test\npublic void fftTest() {\n    ArrayList<Complex> input = new ArrayList<>();\n    input.add(new Complex(1, 0));\n    input.add(new Complex(2, 0));\n    input.add(new Complex(3, 0));\n    input.add(new Complex(4, 0));\n\n    ArrayList<Complex> expectedOutput = new ArrayList<>();\n    expectedOutput.add(new Complex(10, 0));\n    expectedOutput.add(new Complex(-2, 2));\n    expectedOutput.add(new Complex(-2, 0));\n    expectedOutput.add(new Complex(-2, -2));\n\n    ArrayList<Complex> actualOutput = FFT.fft(input, false);\n\n    assertEquals(expectedOutput, actualOutput);\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(1, 0));\n        input.add(new Complex(2, 0));\n        input.add(new Complex(3, 0));\n        input.add(new Complex(4, 0));\n        \n        ArrayList<Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Complex(10, 0));\n        expectedOutput.add(new Complex(-2, 2));\n        expectedOutput.add(new Complex(-2, 0));\n        expectedOutput.add(new Complex(-2, -2));\n        \n        ArrayList<Complex> actualOutput = FFT.fft(input, false);\n        \n        // Compare the expected output with the actual output\n        for (int i = 0; i < actualOutput.size(); i++) {\n            assertEquals(expectedOutput.get(i).getReal(), actualOutput.get(i).getReal(), 0.0001);\n            assertEquals(expectedOutput.get(i).getImaginary(), actualOutput.get(i).getImaginary(), 0.0001);\n        }\n    }\n}",
        "@Test\n    public void fftTest() {\n        // Create input signal\n        ArrayList<FFT.Complex> signal = new ArrayList<>();\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(1, 0));\n\n        // Call the fft method\n        ArrayList<FFT.Complex> result = FFT.fft(signal, false);\n\n        // Assert the expected output\n        ArrayList<FFT.Complex> expected = new ArrayList<>();\n        expected.add(new FFT.Complex(4, 0));\n        expected.add(new FFT.Complex(0, 0));\n        expected.add(new FFT.Complex(0, 0));\n        expected.add(new FFT.Complex(0, 0));\n        assertArrayEquals(expected.toArray(), result.toArray());\n    }",
        "@Test\npublic void fftTest() {\n    // Arrange\n    ArrayList<Complex> input = new ArrayList<>();\n    input.add(new Complex(1, 0));\n    input.add(new Complex(2, 0));\n    input.add(new Complex(3, 0));\n    input.add(new Complex(4, 0));\n    \n    ArrayList<Complex> expected = new ArrayList<>();\n    expected.add(new Complex(10, 0));\n    expected.add(new Complex(-2, -2));\n    expected.add(new Complex(-2, 0));\n    expected.add(new Complex(-2, 2));\n    \n    // Act\n    ArrayList<Complex> actual = FFT.fft(input, false);\n    \n    // Assert\n    for (int i = 0; i < expected.size(); i++) {\n        assertEquals(expected.get(i).getReal(), actual.get(i).getReal(), 0.0001);\n        assertEquals(expected.get(i).getImaginary(), actual.get(i).getImaginary(), 0.0001);\n    }\n}",
        "@Test\npublic void fftTest() {\n    ArrayList<FFT.Complex> input = new ArrayList<>();\n    input.add(new FFT.Complex(1, 0));\n    input.add(new FFT.Complex(2, 0));\n    input.add(new FFT.Complex(3, 0));\n\n    ArrayList<FFT.Complex> expectedOutput = new ArrayList<>();\n    expectedOutput.add(new FFT.Complex(6, 0));\n    expectedOutput.add(new FFT.Complex(-1.5000000000000004, 2.598076211353315));\n    expectedOutput.add(new FFT.Complex(-1.5, -2.598076211353316));\n    \n    ArrayList<FFT.Complex> actualOutput = FFT.fft(input, false);\n    \n    for (int i = 0; i < expectedOutput.size(); i++) {\n        assertEquals(expectedOutput.get(i).getReal(), actualOutput.get(i).getReal(), 0.001);\n        assertEquals(expectedOutput.get(i).getImaginary(), actualOutput.get(i).getImaginary(), 0.001);\n    }\n}",
        "@Test\npublic void fftTest() {\n    // Create the input signal\n    ArrayList<Complex> inputSignal = new ArrayList<>();\n    // Add elements to the input signal ArrayList\n\n    // Call the fft() method to obtain the output signal\n    ArrayList<Complex> outputSignal = FFT.fft(inputSignal, false);\n\n    // Define the expected output signal\n    ArrayList<Complex> expectedOutputSignal = new ArrayList<>();\n    // Add elements to the expected output signal ArrayList\n\n    // Assert that the output signal is equal to the expected output signal\n    assertEquals(expectedOutputSignal, outputSignal);\n}",
        "@Test\npublic void fftTest() {\n    ArrayList<Complex> input = new ArrayList<>();\n    input.add(new Complex(1, 0));\n    input.add(new Complex(2, 0));\n    input.add(new Complex(3, 0));\n    input.add(new Complex(4, 0));\n\n    ArrayList<Complex> expectedOutput = new ArrayList<>();\n    expectedOutput.add(new Complex(10, 0));\n    expectedOutput.add(new Complex(-2, 2));\n    expectedOutput.add(new Complex(-2, 0));\n    expectedOutput.add(new Complex(-2, -2));\n\n    ArrayList<Complex> actualOutput = FFT.fft(input, false);\n    for (int i = 0; i < input.size(); i++) {\n        Complex expected = expectedOutput.get(i);\n        Complex actual = actualOutput.get(i);\n        assertEquals(expected.getReal(), actual.getReal(), 0.0001);\n        assertEquals(expected.getImaginary(), actual.getImaginary(), 0.0001);\n    }\n}",
        "@Test\npublic void fftTest() {\n    ArrayList<Complex> input = new ArrayList<>();\n    input.add(new Complex(1, 0));\n    input.add(new Complex(2, 0));\n    input.add(new Complex(3, 0));\n    input.add(new Complex(4, 0));\n    \n    ArrayList<Complex> expectedOutput = new ArrayList<>();\n    expectedOutput.add(new Complex(10, 0));\n    expectedOutput.add(new Complex(-2, 2));\n    expectedOutput.add(new Complex(-2, 0));\n    expectedOutput.add(new Complex(-2, -2));\n    \n    ArrayList<Complex> result = FFT.fft(input, false);\n    \n    for (int i = 0; i < result.size(); i++) {\n        Complex expected = expectedOutput.get(i);\n        Complex actual = result.get(i);\n        assertEquals(expected.getReal(), actual.getReal(), 0.00001);\n        assertEquals(expected.getImaginary(), actual.getImaginary(), 0.00001);\n    }\n}",
        "@Test\npublic void fftTest() {\n    ArrayList<FFT.Complex> input = new ArrayList<>();\n    input.add(new FFT.Complex(1, 0));\n    input.add(new FFT.Complex(2, 0));\n    input.add(new FFT.Complex(3, 0));\n    input.add(new FFT.Complex(4, 0));\n\n    ArrayList<FFT.Complex> expectedOutput = new ArrayList<>();\n    expectedOutput.add(new FFT.Complex(10, 0));\n    expectedOutput.add(new FFT.Complex(-2, 2));\n    expectedOutput.add(new FFT.Complex(-2, 0));\n    expectedOutput.add(new FFT.Complex(-2, -2));\n\n    ArrayList<FFT.Complex> result = FFT.fft(input, false);\n    for (int i = 0; i < result.size(); i++) {\n        assertEquals(expectedOutput.get(i).getReal(), result.get(i).getReal(), 0.0001);\n        assertEquals(expectedOutput.get(i).getImaginary(), result.get(i).getImaginary(), 0.0001);\n    }\n}",
        "@Test\npublic void fftTest() {\n    ArrayList<FFT.Complex> input = new ArrayList<>();\n    input.add(new FFT.Complex(1, 0));\n    input.add(new FFT.Complex(2, 0));\n    input.add(new FFT.Complex(3, 0));\n    input.add(new FFT.Complex(4, 0));\n\n    ArrayList<FFT.Complex> expectedOutput = new ArrayList<>();\n    expectedOutput.add(new FFT.Complex(10, 0));\n    expectedOutput.add(new FFT.Complex(-2, 2));\n    expectedOutput.add(new FFT.Complex(-2, 0));\n    expectedOutput.add(new FFT.Complex(-2, -2));\n\n    ArrayList<FFT.Complex> actualOutput = FFT.fft(input, false);\n\n    assertEquals(expectedOutput, actualOutput);\n}"
    ]
}