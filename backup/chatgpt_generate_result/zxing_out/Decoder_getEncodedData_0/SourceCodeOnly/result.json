{
    "project_name": "zxing",
    "file_name": "Decoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.decoder",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */",
    "source_code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "arguments": [
        "boolean[] correctedBits"
    ],
    "generate_test": [
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Input data\n        boolean[] correctedBits = new boolean[]{true, false, true, false, true, true, false, true};\n\n        // Expected result\n        String expected = \"ABC\";\n\n        // Actual result\n        String actual = Decoder.getEncodedData(correctedBits);\n\n        // Compare the actual result with the expected result\n        assertEquals(expected, actual);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        boolean[] correctedBits = new boolean[]{true, false, true, true, false, true}; // Example corrected bits\n        String expected = \"Test\"; // Example expected result\n        \n        try {\n            String result = Decoder.getEncodedData(correctedBits);\n            assertEquals(expected, result);\n        } catch (Exception e) {\n            fail(\"An exception occurred: \" + e.getMessage());\n        }\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        boolean[] bits = {true, true, false, true, false}; // example inputs\n        String expectedResult = \"TestString\"; // example expected output\n        \n        String result = getEncodedData(bits);\n        \n        assertEquals(expectedResult, result);\n    }\n}",
        "@Test\npublic void getEncodedDataTest() throws FormatException {\n    // Define input boolean array\n    boolean[] correctedBits = new boolean[]{true, false, true, false, true, true, false, true, true, false};\n\n    // Define expected result\n    String expectedResult = \"Hello\";\n\n    // Call getEncodedData method\n    String result = Decoder.getEncodedData(correctedBits);\n\n    // Compare expected result with the actual result\n    assertEquals(expectedResult, result);\n}",
        "@Test\npublic void getEncodedDataTest() {\n  boolean[] correctedBits = new boolean[]{false, true, false, true, true, true, false, true, false, false, true, true, false, true, false, false, true, true, true, false, true, true, true, true, false};\n  String expectedOutput = \"Hello World\";\n  String actualOutput = null;\n  \n  try {\n    actualOutput = Decoder.getEncodedData(correctedBits);\n  } catch (FormatException e) {\n    fail(\"FormatException occurred: \" + e.getMessage());\n  }\n  \n  assertEquals(expectedOutput, actualOutput);\n}",
        "\n@Test\npublic void getEncodedDataTest() throws FormatException {\n  boolean[] correctedBits = {true, true, true, true, true, false, true, true, true, false, true, true, true, false, true};\n  String expected = \"Hello\";\n  String actual = Decoder.getEncodedData(correctedBits);\n  assertEquals(expected, actual);\n}\n",
        "@Test\npublic void getEncodedDataTest() throws FormatException {\n    boolean[] correctedBits = {true, false, true, false, false, true, true, true, false, false};\n    String expectedResult = \"Hello\";\n    \n    String actualResult = getEncodedData(correctedBits);\n    \n    assertEquals(expectedResult, actualResult);\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        boolean[] correctedBits = {true, false, false, true, true, false, true, false, true, false, false, true};\n        \n        String expectedResult = \"Hello\";\n        String actualResult = getEncodedData(correctedBits);\n        \n        assertEquals(expectedResult, actualResult);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        boolean[] correctedBits = {true, false, true, true, false, true};\n        String expectedOutput = \"\"; // Replace with the expected output of the getEncodedData method\n        \n        String actualOutput = \"\";\n        try {\n            actualOutput = Encoder.getEncodedData(correctedBits);\n        } catch (FormatException e) {\n            e.printStackTrace();\n        }\n        \n        assertEquals(expectedOutput, actualOutput);\n    }\n}",
        "@Test\npublic void getEncodedDataTest() throws FormatException {\n    boolean[] correctedBits = {true, true, false, true, true, false, true, false, true};\n    String expected = \"ABCD\";\n  \n    String result = Decoder.getEncodedData(correctedBits);\n    \n    assertEquals(expected, result);\n}"
    ]
}