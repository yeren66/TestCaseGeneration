{
    "project_name": "javacv",
    "file_name": "Frame.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/Frame.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * This private method takes a buffer array as input and returns a deep copy.\n     * It is assumed that all buffers in the input array are of the same subclass.\n     *\n     * @param srcBuffers - Buffer array to be cloned\n     * @param clonedBuffers - Buffer array to fill with clones\n     * @return Opaque object to store\n     *\n     *  @author Extension proposed by Dragos Dutu\n     */",
    "source_code": "\nprivate static Pointer cloneBufferArray(Buffer[] srcBuffers, Buffer[] clonedBuffers) {\n    Pointer opaque = null;\n\n    if (srcBuffers != null && srcBuffers.length > 0) {\n        int totalCapacity = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            totalCapacity += srcBuffers[i].capacity();\n        }\n\n        /*\n         * In order to optimize the transfer we need a type check.\n         *\n         * Most CPUs support hardware memory transfer for different data\n         * types, so it's faster to copy more bytes at once rather\n         * than one byte per iteration as in case of ByteBuffer.\n         *\n         * For example, Intel CPUs support MOVSB (byte transfer), MOVSW\n         * (word transfer), MOVSD (double word transfer), MOVSS (32 bit\n         * scalar single precision floating point), MOVSQ (quad word\n         * transfer) and so on...\n         *\n         * Type checking may be improved by changing the order in\n         * which a buffer is checked against. If it's likely that the\n         * expected buffer is of type \"ShortBuffer\", then it should be\n         * checked at first place.\n         *\n         */\n\n        if (srcBuffers[0] instanceof ByteBuffer) {\n            BytePointer pointer = new BytePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ByteBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof ShortBuffer) {\n            ShortPointer pointer = new ShortPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ShortBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof IntBuffer) {\n            IntPointer pointer = new IntPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((IntBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof LongBuffer) {\n            LongPointer pointer = new LongPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((LongBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof FloatBuffer) {\n            FloatPointer pointer = new FloatPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((FloatBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof DoubleBuffer) {\n            DoublePointer pointer = new DoublePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((DoubleBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        }\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n    }\n\n    if (opaque != null) {\n        opaque.retainReference();\n    }\n    return opaque;\n}\n",
    "class_name": "Frame",
    "method_name": "cloneBufferArray",
    "arguments": [
        "Buffer srcBuffers",
        "Buffer clonedBuffers"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.DoubleBuffer;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\nimport java.nio.LongBuffer;\nimport java.nio.ShortBuffer;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        // Create srcBuffers and clonedBuffers\n        Buffer[] srcBuffers = new Buffer[2];\n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n\n        // Populate srcBuffers\n        srcBuffers[0] = ByteBuffer.allocate(10);\n        srcBuffers[1] = ShortBuffer.allocate(5);\n\n        // Call the method to test\n        Pointer result = cloneBufferArray(srcBuffers, clonedBuffers);\n\n        // Assert the result and clonedBuffers\n        assertNotNull(result);\n        assertNotNull(clonedBuffers[0]);\n        assertEquals(srcBuffers[0].capacity(), clonedBuffers[0].capacity());\n        assertNotNull(clonedBuffers[1]);\n        assertEquals(srcBuffers[1].capacity(), clonedBuffers[1].capacity());\n    }\n}",
        "private static Pointer cloneBufferArray(Buffer[] srcBuffers, Buffer[] clonedBuffers) {\n    Pointer opaque = null;\n\n    if (srcBuffers != null && srcBuffers.length > 0) {\n        int totalCapacity = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            totalCapacity += srcBuffers[i].capacity();\n        }\n\n        /*\n         * In order to optimize the transfer we need a type check.\n         *\n         * Most CPUs support hardware memory transfer for different data\n         * types, so it's faster to copy more bytes at once rather\n         * than one byte per iteration as in case of ByteBuffer.\n         *\n         * For example, Intel CPUs support MOVSB (byte transfer), MOVSW\n         * (word transfer), MOVSD (double word transfer), MOVSS (32 bit\n         * scalar single precision floating point), MOVSQ (quad word\n         * transfer) and so on...\n         *\n         * Type checking may be improved by changing the order in\n         * which a buffer is checked against. If it's likely that the\n         * expected buffer is of type \"ShortBuffer\", then it should be\n         * checked at first place.\n         *\n         */\n\n        if (srcBuffers[0] instanceof ByteBuffer) {\n            BytePointer pointer = new BytePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ByteBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof ShortBuffer) {\n            ShortPointer pointer = new ShortPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ShortBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof IntBuffer) {\n            IntPointer pointer = new IntPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((IntBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof LongBuffer) {\n            LongPointer pointer = new LongPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((LongBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof FloatBuffer) {\n            FloatPointer pointer = new FloatPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((FloatBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof DoubleBuffer) {\n            DoublePointer pointer = new DoublePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((DoubleBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        }\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n    }\n\n    if (opaque != null) {\n        opaque.retainReference();\n    }\n    return opaque;\n}\n\npackage org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        Buffer[] srcBuffers = new Buffer[2];\n        srcBuffers[0] = ByteBuffer.allocate(4);\n        srcBuffers[1] = ShortBuffer.allocate(4);\n\n        Buffer[] clonedBuffers = new Buffer[2];\n\n        Pointer result = cloneBufferArray(srcBuffers, clonedBuffers);\n\n        assertNotNull(result);\n        assertEquals(srcBuffers[0].limit(), clonedBuffers[0].limit());\n        assertEquals(srcBuffers[1].limit(), clonedBuffers[1].limit());\n    }\n}",
        "@Test\npublic void cloneBufferArrayTest() {\n    // Create source buffers and cloned buffers\n    Buffer[] srcBuffers = new Buffer[2];\n    srcBuffers[0] = ByteBuffer.allocate(10);\n    srcBuffers[1] = ShortBuffer.allocate(5);\n    Buffer[] clonedBuffers = new Buffer[2];\n\n    // Call the method to be tested\n    Pointer result = cloneBufferArray(srcBuffers, clonedBuffers);\n\n    // Assert that the result is not null\n    assertNotNull(result);\n\n    // Assert that the cloned buffers have the same contents as the source buffers\n    for (int i = 0; i < srcBuffers.length; i++) {\n        srcBuffers[i].rewind();\n        clonedBuffers[i].rewind();\n        while (srcBuffers[i].hasRemaining() && clonedBuffers[i].hasRemaining()) {\n            assertEquals(srcBuffers[i].get(), clonedBuffers[i].get());\n        }\n        assertEquals(srcBuffers[i].position(), clonedBuffers[i].position());\n    }\n    \n    // Retain reference to the opaque pointer\n    result.retainReference();\n}",
        "@Test\npublic void cloneBufferArrayTest() {\n    Buffer[] srcBuffers = new Buffer[3]; // create an array of Buffer objects\n    int totalCapacity = 0;\n    for (int i = 0; i < srcBuffers.length; i++) {\n        srcBuffers[i] = ByteBuffer.allocate(1024); // create a ByteBuffer with capacity 1024\n        totalCapacity += srcBuffers[i].capacity();\n    }\n    \n    Buffer[] clonedBuffers = new Buffer[srcBuffers.length]; // create an array to store cloned buffers\n    \n    Pointer opaque = Frame.cloneBufferArray(srcBuffers, clonedBuffers); // call the method to be tested\n    \n    assertNotNull(opaque); // assert that the returned opaque pointer is not null\n    assertEquals(srcBuffers.length, clonedBuffers.length); // assert that the length of srcBuffers and clonedBuffers is the same\n    \n    for (int i = 0; i < srcBuffers.length; i++) {\n        assertEquals(srcBuffers[i].capacity(), clonedBuffers[i].capacity()); // assert that the capacity of each pair of buffers is the same\n        assertArrayEquals(srcBuffers[i].array(), clonedBuffers[i].array()); // assert that the content of each pair of buffers is the same\n        assertEquals(srcBuffers[i].position(), clonedBuffers[i].position()); // assert that the position of each pair of buffers is the same\n    }\n}",
        "@Test\npublic void cloneBufferArrayTest() {\n    Buffer[] srcBuffers = new Buffer[2];\n    srcBuffers[0] = ByteBuffer.allocate(10);\n    srcBuffers[1] = ByteBuffer.allocate(20);\n    \n    Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n    \n    Pointer result = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n    \n    assertNotNull(result);\n    \n    // Continue with the assertions for the rest of the test case\n}",
        "\npackage org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        Buffer[] srcBuffers = new Buffer[2];\n        srcBuffers[0] = ByteBuffer.allocate(4);\n        srcBuffers[1] = ShortBuffer.allocate(4);\n        \n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n        Pointer opaque = cloneBufferArray(srcBuffers, clonedBuffers);\n        \n        assertNotNull(opaque);\n        assertNotNull(clonedBuffers);\n\n        // Perform assertions on clonedBuffers, if needed\n    }\n}",
        "@Test\npublic void cloneBufferArrayTest() {\n    Buffer[] srcBuffers = new Buffer[]{ByteBuffer.allocate(10)};\n    Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n\n    Pointer opaque = cloneBufferArray(srcBuffers, clonedBuffers);\n\n    assertNotNull(opaque);\n    assertEquals(srcBuffers.length, clonedBuffers.length);\n\n    for (int i = 0; i < srcBuffers.length; i++) {\n        assertNotNull(clonedBuffers[i]);\n        assertEquals(srcBuffers[i].capacity(), clonedBuffers[i].capacity());\n\n        // Additional assertions specific to the type of buffer can be added here\n        // For example:\n        if (srcBuffers[i] instanceof ByteBuffer) {\n            assertTrue(clonedBuffers[i] instanceof ByteBuffer);\n        } else if (srcBuffers[i] instanceof ShortBuffer) {\n            assertTrue(clonedBuffers[i] instanceof ShortBuffer);\n        } else if (srcBuffers[i] instanceof IntBuffer) {\n            assertTrue(clonedBuffers[i] instanceof IntBuffer);\n        } else if (srcBuffers[i] instanceof LongBuffer) {\n            assertTrue(clonedBuffers[i] instanceof LongBuffer);\n        } else if (srcBuffers[i] instanceof FloatBuffer) {\n            assertTrue(clonedBuffers[i] instanceof FloatBuffer);\n        } else if (srcBuffers[i] instanceof DoubleBuffer) {\n            assertTrue(clonedBuffers[i] instanceof DoubleBuffer);\n        }\n    }\n\n    // Additional assertions related to the behavior of cloneBufferArray() can be added here\n}",
        "} else if (srcBuffers[0] instanceof CharBuffer) {\n    CharPointer pointer = new CharPointer(totalCapacity);\n    for (int i = 0; i < srcBuffers.length; i++) {\n        clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                .asBuffer().put((CharBuffer)srcBuffers[i]);\n        pointer.position(pointer.limit());\n    }\n    opaque = pointer;\n} else if (srcBuffers[0] instanceof CharBuffer) {\n    CharPointer pointer = new CharPointer(totalCapacity);\n    for (int i = 0; i < srcBuffers.length; i++) {\n        clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                .asBuffer().put((CharBuffer)srcBuffers[i]);\n        pointer.position(pointer.limit());\n    }\n    opaque = pointer;\n}",
        "@Test\npublic void cloneBufferArrayTest() {\n    // Create sample input\n    Buffer[] srcBuffers = new Buffer[2];\n    Buffer[] clonedBuffers = new Buffer[2];\n    srcBuffers[0] = ByteBuffer.allocate(10);\n    srcBuffers[1] = FloatBuffer.allocate(5);\n    \n    // Call the method under test\n    Pointer result = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n    \n    // Perform assertions on the output\n    assertNotNull(result);\n    assertEquals(0, result.position());\n    assertEquals(10 + 5, result.limit());\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        // Initialize the input buffers\n        Buffer[] srcBuffers = new Buffer[2];\n        srcBuffers[0] = ByteBuffer.allocate(16);\n        srcBuffers[1] = ShortBuffer.allocate(8);\n\n        // Initialize the output buffers\n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n\n        // Call the method to be tested\n        Pointer result = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        // Assert the result\n        assertNotNull(result);\n    }\n}"
    ]
}