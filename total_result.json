[
    {
        "project_name": "commons-math",
        "code": "\npublic boolean compareAndSetFeatures(double[] expect,\n                                     double[] update) {\n    if (update.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     update.length, size);\n    }\n\n    // Get the internal reference. Note that this must not be a copy;\n    // otherwise the \"compareAndSet\" below will always fail.\n    final double[] current = features.get();\n    if (!containSameValues(current, expect)) {\n        // Some other thread already modified the state.\n        return false;\n    }\n\n    // Increment attempt counter.\n    numberOfAttemptedUpdates.incrementAndGet();\n\n    if (features.compareAndSet(current, update.clone())) {\n        // The current thread could atomically update the state (attempt succeeded).\n        numberOfSuccessfulUpdates.incrementAndGet();\n        return true;\n    } else {\n        // Some other thread came first (attempt failed).\n        return false;\n    }\n}\n",
        "package": "org.apache.commons.math4.neuralnet",
        "class_name": "Neuron",
        "method_name": "compareAndSetFeatures",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (!(o instanceof Pair)) {\n        return false;\n    } else {\n        Pair<?, ?> oP = (Pair<?, ?>) o;\n        return (key == null ?\n                oP.key == null :\n                key.equals(oP.key)) &&\n            (value == null ?\n             oP.value == null :\n             value.equals(oP.value));\n    }\n}\n",
        "package": "org.apache.commons.math4.legacy.core",
        "class_name": "Pair",
        "method_name": "equals",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "slowexp",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\n@Override\npublic int hashCode() {\n    int result = key == null ? 0 : key.hashCode();\n\n    final int h = value == null ? 0 : value.hashCode();\n    result = 37 * result + h ^ (h >>> 16);\n\n    return result;\n}\n",
        "package": "org.apache.commons.math4.legacy.core",
        "class_name": "Pair",
        "method_name": "hashCode",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic double slowCos(final double x, final double[] result) {\n\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        if ((i & 1) != 0) { // skip odd entries\n            continue;\n        }\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        if ((i & 2) != 0) { // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0]; ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "slowCos",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "splitReciprocal",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nprivate boolean containSameValues(double[] current,\n                                  double[] expect) {\n    if (expect.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     expect.length, size);\n    }\n\n    for (int i = 0; i < size; i++) {\n        if (!Precision.equals(current[i], expect[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n",
        "package": "org.apache.commons.math4.neuralnet",
        "class_name": "Neuron",
        "method_name": "containSameValues",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n    out.println(name);\n    checkLen(expectedLen, array2d.length);\n    out.println(TABLE_START_DECL + \" \");\n    int i = 0;\n    for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n        out.print(\"        {\");\n        for (double d : array) { // assume inner array has very few entries\n            out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n        }\n        out.println(\"}, // \" + i++);\n    }\n    out.println(TABLE_END_DECL);\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "printarray",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\nprivate static double[][] calculateSubMatrix(double[][] matrix){\n    int equations = matrix.length;\n    int coefficients = matrix[0].length;\n    double[][] result = new double[equations - 1][coefficients - 1];\n    for (int eq = 1; eq < equations; eq++) {\n        double factor = matrix[0][0] / matrix[eq][0];\n        for (int coe = 1; coe < coefficients; coe++) {\n            result[eq - 1][coe -1] = matrix[0][coe] - matrix[eq][coe]\n                    * factor;\n        }\n    }\n    if (equations == 1) {\n        return result;\n    }\n    // check for zero pivot element\n    if (result[0][0] == 0) {\n        boolean found = false;\n        for (int i = 0; i < result.length; i ++) {\n            if (result[i][0] != 0) {\n                found = true;\n                double[] temp = result[0];\n                System.arraycopy(result[i], 0, result[0], 0, \n                        result[i].length);\n                System.arraycopy(temp, 0, result[i], 0, temp.length);\n                break;\n            }\n        }\n        if (!found) {\n            //System.out.println(\"Equation has no solution!\");\n            return new double[equations - 1][coefficients - 1];\n        }\n    }\n    double[][] subMatrix = calculateSubMatrix(result);\n    for (int eq = 1; eq < equations -  1; eq++) {\n        result[eq][0] = 0;\n        if (coefficients - 1 - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, result[eq], 1, coefficients - 1 - 1);\n    }\n    return result;\n}\n",
        "package": "org.jfree.data.statistics",
        "class_name": "Regression",
        "method_name": "calculateSubMatrix",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static double calculatePieDatasetTotal(PieDataset dataset) {\n    Args.nullNotPermitted(dataset, \"dataset\");\n    List keys = dataset.getKeys();\n    double totalValue = 0;\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable current = (Comparable) iterator.next();\n        if (current != null) {\n            Number value = dataset.getValue(current);\n            double v = 0.0;\n            if (value != null) {\n                v = value.doubleValue();\n            }\n            if (v > 0) {\n                totalValue = totalValue + v;\n            }\n        }\n    }\n    return totalValue;\n}\n",
        "package": "org.jfree.data.general",
        "class_name": "DatasetUtils",
        "method_name": "calculatePieDatasetTotal",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\n@Override\npublic boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Series)) {\n        return false;\n    }\n    Series that = (Series) obj;\n    if (!Objects.equals(this.key, that.key)) {\n        return false;\n    }\n    if (!Objects.equals(this.description, that.description)) {\n        return false;\n    }\n    if (!that.canEqual(this)) {\n        return false;\n    }\n    return true;\n}\n",
        "package": "org.jfree.data.general",
        "class_name": "Series",
        "method_name": "equals",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static String writeKeyedValues(KeyedValues data) {\n    Args.nullNotPermitted(data, \"data\");\n    StringWriter sw = new StringWriter();\n    try {\n        writeKeyedValues(data, sw);\n    } catch (IOException ex) {\n        throw new RuntimeException(ex);\n    }\n    return sw.toString();\n}\n",
        "package": "org.jfree.data.json",
        "class_name": "JSONUtils",
        "method_name": "writeKeyedValues",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static double calculateQ1(List values) {\n    Args.nullNotPermitted(values, \"values\");\n\n    double result = Double.NaN;\n    int count = values.size();\n    if (count > 0) {\n        if (count % 2 == 1) {\n            if (count > 1) {\n                result = Statistics.calculateMedian(values, 0, count / 2);\n            }\n            else {\n                result = Statistics.calculateMedian(values, 0, 0);\n            }\n        }\n        else {\n            result = Statistics.calculateMedian(values, 0, count / 2 - 1);\n        }\n\n    }\n    return result;\n}\n",
        "package": "org.jfree.data.statistics",
        "class_name": "BoxAndWhiskerCalculator",
        "method_name": "calculateQ1",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static double[] getPowerRegression(double[][] data) {\n\n    int n = data.length;\n    if (n < 2) {\n        throw new IllegalArgumentException(\"Not enough data.\");\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        double x = Math.log(data[i][0]);\n        double y = Math.log(data[i][1]);\n        sumX += x;\n        sumY += y;\n        double xx = x * x;\n        sumXX += xx;\n        double xy = x * y;\n        sumXY += xy;\n    }\n    double sxx = sumXX - (sumX * sumX) / n;\n    double sxy = sumXY - (sumX * sumY) / n;\n    double xbar = sumX / n;\n    double ybar = sumY / n;\n\n    double[] result = new double[2];\n    result[1] = sxy / sxx;\n    result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n    return result;\n\n}\n",
        "package": "org.jfree.data.statistics",
        "class_name": "Regression",
        "method_name": "getPowerRegression",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-lang",
        "code": "\npublic CompareToBuilder append(final double[] lhs, final double[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "package": "org.apache.commons.lang3.builder",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "SourceCode&Full": [
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "commons-lang",
        "code": "\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "package": "org.apache.commons.lang3.builder",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-lang",
        "code": "\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "package": "org.apache.commons.lang3.builder",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Test Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "// Fast fuzzy version.  Used a cached value until it gets old, then re-up\n// the cache.\npublic long estimate_sum( ) {\n  // For short tables, just do the work\n  if( _t.length <= 64 ) return sum();\n  // For bigger tables, periodically freshen a cached value\n  long millis = System.currentTimeMillis();\n  if( _fuzzy_time != millis ) { // Time marches on?\n    _fuzzy_sum_cache = sum(); // Get sum the hard way\n    _fuzzy_time = millis;   // Indicate freshness of cached value\n  }\n  return _fuzzy_sum_cache;  // Return cached sum\n}\n",
        "package": "org.jctools.maps",
        "class_name": "ConcurrentAutoTable",
        "method_name": "estimate_sum",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "// Help any top-level NBSI to copy until completed.\n// Always return the _new version of *this* NBSI, in case we're nested.\nprivate NBSI help_copy() {\n  // Pick some words to help with - but only help copy the top-level NBSI.\n  // Nested NBSI waits until the top is done before we start helping.\n  NBSI top_nbsi = _non_blocking_set_int._nbsi;\n  final int HELP = 8;       // Tuning number: how much copy pain are we willing to inflict?\n  // We \"help\" by forcing individual bit indices to copy.  However, bits\n  // come in lumps of 64 per word, so we just advance the bit counter by 64's.\n  int idx = top_nbsi._copyIdx.getAndAdd(64*HELP);\n  for( int i=0; i<HELP; i++ ) {\n    int j = idx+i*64;\n    j %= (top_nbsi._bits.length<<6); // Limit, wrap to array size; means we retry indices\n    top_nbsi.help_copy_impl(j   );\n    top_nbsi.help_copy_impl(j+63); // Also force the nested-by-64 bit\n  }\n\n  // Top level guy ready to promote?\n  // Note: WE may not be the top-level guy!\n  if( top_nbsi._copyDone.get() == top_nbsi._sum_bits_length )\n    // One shot CAS to promote - it may fail since we are racing; others\n    // may promote as well\n    if( _non_blocking_set_int.CAS_nbsi( top_nbsi, top_nbsi._new ) ) {\n      //System.out.println(\"Promote at top level to size \"+(_non_blocking_set_int._nbsi._bits.length<<6));\n    }\n\n  // Return the new bitvector for 'fluid' programming style\n  return _new;\n}\n",
        "package": "org.jctools.maps",
        "class_name": "NonBlockingSetInt",
        "method_name": "help_copy",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\n@Override\npublic String toString() {\n  Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n  if( !i.hasNext())\n    return \"{}\";\n\n  StringBuilder sb = new StringBuilder();\n  sb.append('{');\n  for (;;) {\n    Entry<TypeK,TypeV> e = i.next();\n    TypeK key = e.getKey();\n    TypeV value = e.getValue();\n    sb.append(key   == this ? \"(this Map)\" : key);\n    sb.append('=');\n    sb.append(value == this ? \"(this Map)\" : value);\n    if( !i.hasNext())\n      return sb.append('}').toString();\n    sb.append(\", \");\n  }\n}\n",
        "package": "org.jctools.maps",
        "class_name": "NonBlockingHashMap",
        "method_name": "toString",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "// Help copy this one word.  State Machine.\n// (1) If not \"made immutable\" in the old array, set the sign bit to make\n//     it immutable.\n// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old\n// (3) If non-zero in old array & non-zero in new, CAS old to zero\n// (4) Zero in old, new is valid\n// At this point, old should be immutable-zero & new has a copy of bits\nprivate NBSI help_copy_impl( int i ) {\n  // Handle every 64th bit via using a nested array\n  NBSI old = this;          // The bit array being copied from\n  NBSI nnn = _new;          // The bit array being copied to\n  if( nnn == null ) return this; // Promoted already\n  int j = i;                // The bit index being added\n  while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n    old = old._nbsi64;      // Recurse\n    nnn = nnn._nbsi64;      // Recurse\n    j = j>>6;               // Strip off low 6 bits (all set)\n  }\n\n  // Transit from state 1: word is not immutable yet\n  // Immutable is in bit 63, the sign bit.\n  long bits = old._bits[j>>6];\n  while( bits >= 0 ) {      // Still in state (1)?\n    long oldbits = bits;\n    bits |= mask(63);       // Target state of bits: sign-bit means immutable\n    if( old.CAS( j>>6, oldbits, bits ) ) {\n      if( oldbits == 0 ) _copyDone.addAndGet(1);\n      break;                // Success - old array word is now immutable\n    }\n    bits = old._bits[j>>6]; // Retry if CAS failed\n  }\n\n  // Transit from state 2: non-zero in old and zero in new\n  if( bits != mask(63) ) {  // Non-zero in old?\n    long new_bits = nnn._bits[j>>6];\n    if( new_bits == 0 ) {   // New array is still zero\n      new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n      // One-shot CAS attempt, no loop, from 0 to non-zero.\n      // If it fails, somebody else did the copy for us\n      if( !nnn.CAS( j>>6, 0, new_bits ) )\n        new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n      assert new_bits != 0;\n    }\n\n    // Transit from state 3: non-zero in old and non-zero in new\n    // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n    if( old.CAS( j>>6, bits, mask(63) ) )\n      _copyDone.addAndGet(1); // One more word finished copying\n  }\n\n  // Now in state 4: zero (and immutable) in old\n\n  // Return the self bitvector for 'fluid' programming style\n  return this;\n}\n",
        "package": "org.jctools.maps",
        "class_name": "NonBlockingSetInt",
        "method_name": "help_copy_impl",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\nprivate int probe() {\n    // Fast path for reliable well-distributed probe, available from JDK 7+.\n    // As long as PROBE is final static this branch will be constant folded\n    // (i.e removed).\n    if (PROBE != -1) {\n        int probe;\n        if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n            ThreadLocalRandom.current(); // force initialization\n            probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n        }\n        return probe;\n    }\n\n    /*\n     * Else use much worse (for values distribution) method:\n     * Mix thread id with golden ratio and then xorshift it\n     * to spread consecutive ids (see Knuth multiplicative method as reference).\n     */\n    int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n    // xorshift\n    probe ^= probe << 13;\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n    return probe;\n}\n\n",
        "package": "org.jctools.counters",
        "class_name": "FixedSizeStripedLongCounterPrePad",
        "method_name": "probe",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\n@Override\npublic boolean offer(final E e)\n{\n    // Objects.requireNonNull(e);\n    if (null == e)\n    {\n        throw new NullPointerException();\n    }\n    // local load of field to avoid repeated loads after volatile reads\n    final E[] buffer = producerBuffer;\n    final long index = lpProducerIndex();\n    final long mask = producerMask;\n    final long offset = calcCircularRefElementOffset(index, mask);\n    // expected hot path\n    if (index < producerBufferLimit)\n    {\n        writeToQueue(buffer, e, index, offset);\n        return true;\n    }\n    return offerColdPath(buffer, mask, index, offset, e, null);\n}\n",
        "package": "org.jctools.queues",
        "class_name": "BaseSpscLinkedArrayQueuePrePad",
        "method_name": "offer",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\n@Override\npublic final int size()\n{\n    // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n    LinkedQueueNode<E> chaserNode = lvConsumerNode();\n    LinkedQueueNode<E> producerNode = lvProducerNode();\n    int size = 0;\n    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n    while (chaserNode != producerNode && // don't go passed producer node\n        chaserNode != null && // stop at last node\n        size < Integer.MAX_VALUE) // stop at max int\n    {\n        LinkedQueueNode<E> next;\n        next = chaserNode.lvNext();\n        // check if this node has been consumed, if so return what we have\n        if (next == chaserNode)\n        {\n            return size;\n        }\n        chaserNode = next;\n        size++;\n    }\n    return size;\n}\n",
        "package": "org.jctools.queues",
        "class_name": "BaseLinkedQueuePad0",
        "method_name": "size",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "// Determine the prior (lower number) region that meets the desired conditions\npublic static int PriorRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n{\n    double DParent = (double) Parent; \n    double DColor = (double) Color; if(DColor > 0) DColor = 1;\n    \n    int i;\n    for(i = Label; i >= 0; i--)\n    {\n        double [] Region = RegionData[i];\n        double ThisParent = Region[BLOBPARENT];\n        double ThisColor = Region[BLOBCOLOR];\n        if(DParent >= 0 && DParent != ThisParent) continue;\n        if(DColor >= 0 && DColor != ThisColor) continue;\n        if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n        break;      // We have a match!\n    }\n    if(i < 0) i = -1;   // Use -1 to flag that there was no match\n    return i;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Blobs",
        "method_name": "PriorRegion",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\ndouble[] locatePlanarObject(KeyPointVector objectKeypoints, Mat objectDescriptors,\n        KeyPointVector imageKeypoints, Mat imageDescriptors, double[] srcCorners) {\n    ptpairs.clear();\n    if (settings.useFLANN) {\n        flannFindPairs(objectDescriptors, imageDescriptors);\n    } else {\n        findPairs(objectDescriptors, imageDescriptors);\n    }\n    int n = ptpairs.size()/2;\n    logger.info(n + \" matching pairs found\");\n    if (n < settings.matchesMin) {\n        return null;\n    }\n\n    pt1 .resize(n);\n    pt2 .resize(n);\n    mask.resize(n);\n    FloatBuffer pt1Idx = pt1.createBuffer();\n    FloatBuffer pt2Idx = pt2.createBuffer();\n    for (int i = 0; i < n; i++) {\n        Point2f p1 = objectKeypoints.get(ptpairs.get(2*i)).pt();\n        pt1Idx.put(2*i, p1.x()); pt1Idx.put(2*i+1, p1.y());\n        Point2f p2 = imageKeypoints.get(ptpairs.get(2*i+1)).pt();\n        pt2Idx.put(2*i, p2.x()); pt2Idx.put(2*i+1, p2.y());\n    }\n\n    H = findHomography(pt1, pt2, CV_RANSAC, settings.ransacReprojThreshold, mask, 2000, 0.995);\n    if (H.empty() || countNonZero(mask) < settings.matchesMin) {\n        return null;\n    }\n\n    double[] h = (double[])H.createIndexer(false).array();\n    double[] dstCorners = new double[srcCorners.length];\n    for(int i = 0; i < srcCorners.length/2; i++) {\n        double x = srcCorners[2*i], y = srcCorners[2*i + 1];\n        double Z = 1/(h[6]*x + h[7]*y + h[8]);\n        double X = (h[0]*x + h[1]*y + h[2])*Z;\n        double Y = (h[3]*x + h[4]*y + h[5])*Z;\n        dstCorners[2*i    ] = X;\n        dstCorners[2*i + 1] = Y;\n    }\n    return dstCorners;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "ObjectFinder",
        "method_name": "locatePlanarObject",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\nprivate static Pointer cloneBufferArray(Buffer[] srcBuffers, Buffer[] clonedBuffers) {\n    Pointer opaque = null;\n\n    if (srcBuffers != null && srcBuffers.length > 0) {\n        int totalCapacity = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            totalCapacity += srcBuffers[i].capacity();\n        }\n\n        /*\n         * In order to optimize the transfer we need a type check.\n         *\n         * Most CPUs support hardware memory transfer for different data\n         * types, so it's faster to copy more bytes at once rather\n         * than one byte per iteration as in case of ByteBuffer.\n         *\n         * For example, Intel CPUs support MOVSB (byte transfer), MOVSW\n         * (word transfer), MOVSD (double word transfer), MOVSS (32 bit\n         * scalar single precision floating point), MOVSQ (quad word\n         * transfer) and so on...\n         *\n         * Type checking may be improved by changing the order in\n         * which a buffer is checked against. If it's likely that the\n         * expected buffer is of type \"ShortBuffer\", then it should be\n         * checked at first place.\n         *\n         */\n\n        if (srcBuffers[0] instanceof ByteBuffer) {\n            BytePointer pointer = new BytePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ByteBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof ShortBuffer) {\n            ShortPointer pointer = new ShortPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ShortBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof IntBuffer) {\n            IntPointer pointer = new IntPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((IntBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof LongBuffer) {\n            LongPointer pointer = new LongPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((LongBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof FloatBuffer) {\n            FloatPointer pointer = new FloatPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((FloatBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof DoubleBuffer) {\n            DoublePointer pointer = new DoublePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((DoubleBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        }\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n    }\n\n    if (opaque != null) {\n        opaque.retainReference();\n    }\n    return opaque;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Frame",
        "method_name": "cloneBufferArray",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic Frame convert(byte[] data, int width, int height) {\n    if (frame == null || frame.imageWidth != width\n            || frame.imageHeight != height || frame.imageChannels != 3) {\n        if (frame != null) {\n            frame.close();\n        }\n        frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n\n    // ported from https://android.googlesource.com/platform/development/+/master/tools/yuv420sp2rgb/yuv420sp2rgb.c\n    int offset = height * width;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n\n            if (Y < 0)\n                Y = 0;\n\n            // R = (int)(1.164 * Y + 2.018 * U);\n            // G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n            // B = (int)(1.164 * Y + 1.596 * V);\n\n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n\n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n\n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n\n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    return frame;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "AndroidFrameConverter",
        "method_name": "convert",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic static String[] listPS3Cameras() {\n    int no = getCameraCount();\n    String[] uuids;\n    if (no > 0) {\n        uuids = new String[no];\n        for (--no; no >=0; no--) { uuids[no] = CLCamera.cameraUUID(no); }\n        return uuids;\n    }\n    return null;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "PS3EyeFrameGrabber",
        "method_name": "listPS3Cameras",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\nprivate static int toIntExact(long value) {\n    if ((int) value != value) {\n        throw new ArithmeticException(\"integer overflow\");\n    }\n    return (int) value;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "IPCameraFrameGrabber",
        "method_name": "toIntExact",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic Frame grab() throws Exception {\n    device.wait_for_frames();\n\n      frameNumber++; \n    // For Framegrabber\n    if (colorEnabled && behaveAsColorFrameGrabber) {\n        IplImage image = grabVideo();\n\n        if (returnImage == null) {\n            int deviceWidth = device.get_stream_width(RealSense.color);\n            int deviceHeight = device.get_stream_height(RealSense.color);\n              returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 3);\n            returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 1);\n        }\n        cvCvtColor(image, returnImage, CV_BGR2GRAY);\n        return converter.convert(returnImage);\n    } else {\n        if (IREnabled) {\n            return converter.convert(grabIR());\n        } else {\n            if (depthEnabled) {\n                \n                // Fake colors\n                IplImage image = grabDepth();\n                if (returnImage == null) {\n                    int deviceWidth = device.get_stream_width(RealSense.depth);\n                    int deviceHeight = device.get_stream_height(RealSense.depth);\n              returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 3);\n                    returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 1);\n                } \n                return converter.convert(returnImage);\n            }\n        }\n    }\n\n    return null;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "RealSenseFrameGrabber",
        "method_name": "grab",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic static double homogToRt(CvMat H,\n        CvMat R1, CvMat t1, CvMat n1,\n        CvMat R2, CvMat t2, CvMat n2) {\n    CvMat S = S3x3.get(), U = U3x3.get(), V = V3x3.get();\n    cvSVD(H, S, U, V, 0);\n    double zeta = homogToRt(S, U, V, R1, t1, n1, R2, t2, n2);\n    return zeta;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "JavaCV",
        "method_name": "homogToRt",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "// Determine the next (higher number) region that meets the desired conditions\npublic static int NextRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n{\n    double DParent = (double) Parent; \n    double DColor = (double) Color; if(DColor > 0) DColor = 1;\n    \n    int i;\n    for(i = Label; i <= MaxLabel; i++)\n    {\n        double [] Region = RegionData[i];\n        double ThisParent = Region[BLOBPARENT];\n        double ThisColor = Region[BLOBCOLOR];\n        if(DParent >= 0 && DParent != ThisParent) continue;\n        if(DColor >= 0 && DColor != ThisColor) continue;\n        if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n        break;      // We have a match!\n    }\n    if(i > MaxLabel) i = -1;    // Use -1 to flag that there was no match\n    return i;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Blobs",
        "method_name": "NextRegion",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\n@Override\npublic Frame clone() {\n    Frame newFrame = new Frame();\n\n    // Video part\n    newFrame.imageWidth = imageWidth;\n    newFrame.imageHeight = imageHeight;\n    newFrame.imageDepth = imageDepth;\n    newFrame.imageChannels = imageChannels;\n    newFrame.imageStride = imageStride;\n    newFrame.keyFrame = keyFrame;\n    newFrame.pictType = pictType;\n    newFrame.streamIndex = streamIndex;\n    newFrame.type = type;\n    newFrame.opaque = new Pointer[3];\n    if (image != null) {\n        newFrame.image = new Buffer[image.length];\n        ((Pointer[])newFrame.opaque)[0] = cloneBufferArray(image, newFrame.image);\n    }\n\n    // Audio part\n    newFrame.audioChannels = audioChannels;\n    newFrame.sampleRate = sampleRate;\n    if (samples != null) {\n        newFrame.samples = new Buffer[samples.length];\n        ((Pointer[])newFrame.opaque)[1] = cloneBufferArray(samples, newFrame.samples);\n    }\n\n    // Other data streams\n    if (data != null) {\n        ByteBuffer[] dst = new ByteBuffer[1];\n        ((Pointer[])newFrame.opaque)[2] = cloneBufferArray(new ByteBuffer[]{data}, dst);\n        newFrame.data = dst[0];\n    }\n\n    // Add timestamp\n    newFrame.timestamp = timestamp;\n\n    return newFrame;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Frame",
        "method_name": "clone",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic double getAudioFrameRate() {\n    if (audio_st == null) {\n        return 0.0;\n    } else {\n        if (samples_frame == null || samples_frame.nb_samples() == 0) {\n            try {\n                grabFrame(true, false, false, false, false);\n                frameGrabbed = true;\n            } catch (Exception e) {\n                return 0.0;\n            }\n        }\n        if (samples_frame != null && samples_frame.nb_samples() != 0)\n            return ((double) getSampleRate()) / samples_frame.nb_samples();\n        else return 0.0;\n\n    }\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "FFmpegFrameGrabber",
        "method_name": "getAudioFrameRate",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic int[] grab_raw() {\n    if (camera.getCameraFrame(ps3_frame, timeout)) {\n        return ps3_frame;\n    }\n    else return null;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "PS3EyeFrameGrabber",
        "method_name": "grab_raw",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "//---------------------------------------------------------------------------------------\n// Main blob analysis routine\n//---------------------------------------------------------------------------------------\n// RegionData[0] is the border. It has Property[BLOBPARENT] = 0. \n\npublic int BlobAnalysis(IplImage Src,           // input image\n            int Col0, int Row0,                 // start of ROI\n            int Cols, int Rows,                 // size of ROI\n            int Border,                         // border color (0 = black; 1 = white)\n            int MinArea)                        // minimum region area\n{\n    CvMat SrcMat = Src.asCvMat();\n    int SrcCols = SrcMat.cols();\n    int SrcRows = SrcMat.rows();\n    \n    if(Col0 < 0) Col0 = 0;\n    if(Row0 < 0) Row0 = 0;\n    if(Cols < 0) Cols = SrcCols;\n    if(Rows < 0) Rows = SrcRows;\n    if(Col0 + Cols > SrcCols) Cols = SrcCols - Col0;\n    if(Row0 + Rows > SrcRows) Rows = SrcRows - Row0;\n\n    if(Cols > BLOBCOLCOUNT || Rows > BLOBROWCOUNT )\n    {\n        System.out.println(\"Error in Class Blobs: Image too large: Edit Blobs.java\");\n        System.exit(666);\n        return 0;\n    }\n    \n    // Initialization\n    int FillLabel = 0;\n    int FillColor = 0; if(Border > 0) { FillColor = 1; }\n    LabelA = LabelB = LabelC = LabelD = 0;\n    ColorA = ColorB = ColorC = ColorD = FillColor;\n    for(int k = 0; k < BLOBTOTALCOUNT; k++) SubsumedLabel[k] = -1;\n    \n    // Initialize border region\n    MaxLabel = 0;\n    double [] BorderRegion = RegionData[0];\n    BorderRegion[BLOBLABEL] = 0.0;\n    BorderRegion[BLOBPARENT] = -1.0;\n    BorderRegion[BLOBAREA] = Rows + Cols + 4;   // Top, left, and 4 corners\n    BorderRegion[BLOBCOLOR] = FillColor;\n    BorderRegion[BLOBSUMX] = 0.5 * ( (2.0 + Cols) * (Cols - 1.0) ) - Rows - 1 ;\n    BorderRegion[BLOBSUMY] = 0.5 * ( (2.0 + Rows) * (Rows - 1.0) ) - Cols - 1 ;\n    BorderRegion[BLOBMINX] = -1;\n    BorderRegion[BLOBMINY] = -1;\n    BorderRegion[BLOBMAXX] = Cols + 1.0;\n    BorderRegion[BLOBMAXY] = Rows + 1.0;\n    System.arraycopy(BorderRegion,0,RegionData[0],0,BLOBDATACOUNT); // RegionData[0] <- BorderRegion;\n    \n    //  The cells are identified this way\n    //          Last |AB|\n    //          This |CD|\n    //\n    // With 4 connectivity, there are 8 possibilities for the cells:\n    //                      No color transition     Color transition\n    //          Case              1  2  3  4          5  6  7  8 \n    //          Last Row        |pp|pp|pq|pq|       |pp|pp|pq|pq|   \n    //          This Row        |pP|qQ|pP|qQ|       |pQ|qP|pQ|qP|\n    //\n    // Region numbers are p, q, r, x; where p<>q\n    // Upper case letter is the current element at column=x row=y\n    // Color is 0 or 1      (1 stands for 255 in the actual image)\n    // Note that Case 4 is complicated because it joins two regions\n    //--------------------------\n    // Case 1: Colors A=B; C=D; A=C     \n    // Case 2: Colors A=B; C=D; A<>C    \n    // Case 3: Colors A<>B;C=D; A=C     \n    // Case 4: Colors A<>B;C=D; A<>C    \n    // Case 5: Colors A=B; C<>D; A=C    \n    // Case 6: Colors A=B; C<>D; A<>C   \n    // Case 7: Colors A<>B;C<>D; A=C    \n    // Case 8: Colors A<>B;C<>D; A<>C   \n    //--------------------------\n                \n    // Loop over rows of ROI. irow = Row0 is 1st row of image; irow = Row0+Row is last row of image.\n    for(int irow = Row0; irow < Row0+Rows; irow++)  // index within Src\n    {\n        jrow = irow - Row0; // index within ROI. 0 is first row. Rows is last row.\n        \n        // Loop over columns of ROI.\n        for(int icol = Col0; icol < Col0+Cols; icol++)  // index within Src\n        {\n            jcol = icol - Col0; // index within ROI\n\n            // initialize\n            ColorA = ColorB = ColorC = FillColor;\n            LabelA = LabelB = LabelC = LabelD = 0;\n            ColorD = (int) SrcMat.get(jrow,jcol);       // fetch color of cell\n        \n            if(jrow == 0 || jcol == 0)  // first column or row\n            {\n                if(jcol > 0)\n                {\n                    ColorC = (int) SrcMat.get(jrow,jcol-1);\n                    LabelC = LabelMat[jrow][jcol-1];\n                }\n                if(jrow > 0)\n                {\n                    ColorB = (int) SrcMat.get(jrow-1,jcol);\n                    LabelB = LabelMat[jrow-1][jcol];\n                }\n            }\n            else\n            {\n                ColorA = (int) SrcMat.get(jrow-1,jcol-1); if(ColorA > 0) ColorA = 1;\n                ColorB = (int) SrcMat.get(jrow-1,jcol); if(ColorB > 0) ColorB = 1;\n                ColorC = (int) SrcMat.get(jrow,jcol-1); if(ColorC > 0) ColorC = 1;\n                LabelA = LabelMat[jrow-1][jcol-1];\n                LabelB = LabelMat[jrow-1][jcol];\n                LabelC = LabelMat[jrow][jcol-1];\n            }   \n            if(ColorA > 0) ColorA = 1;\n            if(ColorB > 0) ColorB = 1;\n            if(ColorC > 0) ColorC = 1;\n            if(ColorD > 0) ColorD = 1;\n                \n            // Determine Case\n            int Case = 0;\n            if(ColorA == ColorB)\n            {\n                if(ColorC == ColorD) { if(ColorA == ColorC) Case = 1; else Case = 2; }\n                else { if(ColorA == ColorC) Case = 5; else Case = 6; }\n            }\n            else\n            {\n                if(ColorC == ColorD) { if(ColorA == ColorC) Case = 3; else Case = 4; }\n                else { if(ColorA == ColorC) Case = 7; else Case = 8; }\n            }\n\n            // Take appropriate action\n            if(Case == 1) { OldRegion(LabelC, -1, -1); }\n            else if(Case == 2 || Case == 3) { OldRegion(LabelC, LabelB, LabelC); }\n            else if(Case == 5 || Case == 8) // Isolated\n            {\n                if((jrow == Rows || jcol == Cols) && ColorD == FillColor) { OldRegion(0, -1, -1); } // attached to border region 0\n                else NewRegion(LabelB);\n            }\n            else if(Case == 6 || Case == 7) { OldRegion(LabelB, LabelB, LabelC); }\n            else            // Case 4 - The complicated situation\n            {\n                int LabelBRoot = SubsumptionChain(LabelB); \n                int LabelCRoot = SubsumptionChain(LabelC);\n                int LabelRoot = Math.min(LabelBRoot, LabelCRoot);\n                int LabelX;\n                if(LabelBRoot < LabelCRoot) { OldRegion(LabelB, -1, -1); LabelX = LabelC; }\n                else { OldRegion(LabelC, -1, -1); LabelX = LabelB; }\n                int NextLabelX = LabelX;\n                while(LabelRoot < LabelX)\n                {\n                    NextLabelX = SubsumedLabel[LabelX];\n                    SubsumedLabel[LabelX] = LabelRoot;\n                    LabelX = NextLabelX;\n                }\n            }\n                \n            // Last column or row. Final corner was handled earlier in Cases 5 and 8.\n            if((jrow == Rows || jcol == Cols) && ColorD == FillColor)\n            {\n                if(jcol < Cols)         // bottom row   \n                {\n                    if(ColorC != FillColor)     // Subsume B chain to border region 0\n                    {\n                        int LabelRoot = SubsumptionChain(LabelB);\n                        SubsumedLabel[LabelRoot] = 0;\n                    }\n                }\n                else if(jrow < Rows)    // right column\n                {\n                    if(ColorB != FillColor)     // Subsume C chain to border region 0\n                    {\n                        int LabelRoot = SubsumptionChain(LabelC);\n                        SubsumedLabel[LabelRoot] = 0;\n                    }\n                }\n                OldRegion(0, -1, -1);   // attached to border region 0\n            }\n\n            LabelMat[jrow][jcol] = LabelD;\n                \n        }\n    }\n\n    // Compute Condensation map\n    int Offset = 0;\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        if(SubsumedLabel[Label] > -1) Offset++;\n        CondensationMap[Label] = Label - Offset;\n    }\n\n    // Subsume regions that were flagged as connected; Perimeters add\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        int BetterLabel = SubsumptionChain(Label);\n        if(BetterLabel != Label) Subsume(BetterLabel, Label, 1);\n    }   \n\n    // Condense subsumed regions\n    int NewMaxLabel = 0;\n    for(int OldLabel = 1; OldLabel <= MaxLabel; OldLabel++)\n    {\n        if(SubsumedLabel[OldLabel] < 0) // Renumber valid regions only\n        {\n            double [] OldRegion = RegionData[OldLabel];\n            int OldParent = (int) OldRegion[BLOBPARENT];\n            int NewLabel = CondensationMap[OldLabel];\n            int NewParent = SubsumptionChain(OldParent);\n            NewParent = CondensationMap[NewParent];\n            OldRegion[BLOBLABEL] = (double) NewLabel;\n            OldRegion[BLOBPARENT] = (double) NewParent;\n            System.arraycopy(OldRegion,0,RegionData[NewLabel],0,BLOBDATACOUNT); //RegionData[NewLabel] <- ThisRegion;\n            NewMaxLabel = NewLabel;\n        }\n    }\n\n    // Zero out unneeded high labels\n    for(int Label = NewMaxLabel+1; Label <= MaxLabel; Label++) ResetRegion(Label);\n    MaxLabel = NewMaxLabel;\n    \n    // Flag for subsumption regions that have too small area\n    for(int Label = MaxLabel; Label > 0; Label--)\n    {\n        double [] ThisRegion = RegionData[Label];\n        int ThisArea = (int) ThisRegion[BLOBAREA];\n        if(ThisArea < MinArea)\n        {\n            int ThisParent = (int) ThisRegion[BLOBPARENT];\n            SubsumedLabel[Label] =  ThisParent;             // Flag this label as having been subsumed\n        }\n        else SubsumedLabel[Label] =  -1;\n    }\n    \n    // Compute Condensation map\n    Offset = 0;\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        if(SubsumedLabel[Label] > -1) Offset++;\n        CondensationMap[Label] = Label - Offset;      \n    }\n\n    // Subsume regions that were flagged as enclosed; Perimeters subtract\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        int BetterLabel = SubsumptionChain(Label);\n        if(BetterLabel != Label) Subsume(BetterLabel, Label, -1);\n    }   \n\n    // Condense subsumed regions\n    for(int OldLabel = 1; OldLabel <= MaxLabel; OldLabel++)\n    {\n        if(SubsumedLabel[OldLabel] < 0) // Renumber valid regions only\n        {\n            double [] OldRegion = RegionData[OldLabel];\n            int OldParent = (int) OldRegion[BLOBPARENT];\n            int NewLabel = CondensationMap[OldLabel];\n            int NewParent = SubsumptionChain(OldParent);\n            NewParent = CondensationMap[NewParent];\n            OldRegion[BLOBLABEL] = (double) NewLabel;\n            OldRegion[BLOBPARENT] = (double) NewParent;\n            System.arraycopy(OldRegion,0,RegionData[NewLabel],0,BLOBDATACOUNT); //RegionData[NewLabel] <- ThisRegion;\n            NewMaxLabel = NewLabel;\n        }\n    }\n    \n    // Zero out unneeded high labels\n    for(int Label = NewMaxLabel+1; Label <= MaxLabel; Label++) ResetRegion(Label);\n    MaxLabel = NewMaxLabel;\n\n    // Normalize summation fields into moments \n    for(int Label = 0; Label <= MaxLabel; Label++)\n    {\n        double [] ThisRegion = RegionData[Label];\n        \n        // Extract fields\n        double Area = ThisRegion[BLOBAREA];\n        double SumX = ThisRegion[BLOBSUMX];\n        double SumY = ThisRegion[BLOBSUMY];\n        double SumXX = ThisRegion[BLOBSUMXX];\n        double SumYY = ThisRegion[BLOBSUMYY];\n        double SumXY = ThisRegion[BLOBSUMXY];\n        \n        // Get averages\n        SumX /= Area;\n        SumY /= Area;\n        SumXX /= Area;\n        SumYY /= Area;\n        SumXY /= Area;\n        \n        // Create moments\n        SumXX -= SumX * SumX;\n        SumYY -= SumY * SumY;\n        SumXY -= SumX * SumY;\n        if(SumXY > -1.0E-14 && SumXY < 1.0E-14) SumXY = (float) 0.0; // Eliminate roundoff error\n\n        ThisRegion[BLOBSUMX] = SumX;\n        ThisRegion[BLOBSUMY] = SumY;\n        ThisRegion[BLOBSUMXX] = SumXX;\n        ThisRegion[BLOBSUMYY] = SumYY;\n        ThisRegion[BLOBSUMXY] = SumXY;\n\n        System.arraycopy(ThisRegion,0,RegionData[Label],0,BLOBDATACOUNT);   // RegionData[Label] <- ThisRegion;\n    }\n\n    // Adjust border region\n    BorderRegion = RegionData[0];\n    BorderRegion[BLOBSUMXX] = BorderRegion[BLOBSUMYY] = BorderRegion[BLOBSUMXY] = 0;    // Mark invalid fields\n    System.arraycopy(BorderRegion,0,RegionData[0],0,BLOBDATACOUNT); // RegionData[0] <- BorderRegion;\n    \n    return MaxLabel;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Blobs",
        "method_name": "BlobAnalysis",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    }
]