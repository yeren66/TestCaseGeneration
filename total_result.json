[
    {
        "project_name": "commons-math",
        "code": "\npublic boolean compareAndSetFeatures(double[] expect,\n                                     double[] update) {\n    if (update.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     update.length, size);\n    }\n\n    // Get the internal reference. Note that this must not be a copy;\n    // otherwise the \"compareAndSet\" below will always fail.\n    final double[] current = features.get();\n    if (!containSameValues(current, expect)) {\n        // Some other thread already modified the state.\n        return false;\n    }\n\n    // Increment attempt counter.\n    numberOfAttemptedUpdates.incrementAndGet();\n\n    if (features.compareAndSet(current, update.clone())) {\n        // The current thread could atomically update the state (attempt succeeded).\n        numberOfSuccessfulUpdates.incrementAndGet();\n        return true;\n    } else {\n        // Some other thread came first (attempt failed).\n        return false;\n    }\n}\n",
        "package": "org.apache.commons.math4.neuralnet",
        "class_name": "Neuron",
        "method_name": "compareAndSetFeatures",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (!(o instanceof Pair)) {\n        return false;\n    } else {\n        Pair<?, ?> oP = (Pair<?, ?>) o;\n        return (key == null ?\n                oP.key == null :\n                key.equals(oP.key)) &&\n            (value == null ?\n             oP.value == null :\n             value.equals(oP.value));\n    }\n}\n",
        "package": "org.apache.commons.math4.legacy.core",
        "class_name": "Pair",
        "method_name": "equals",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "slowexp",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\n@Override\npublic int hashCode() {\n    int result = key == null ? 0 : key.hashCode();\n\n    final int h = value == null ? 0 : value.hashCode();\n    result = 37 * result + h ^ (h >>> 16);\n\n    return result;\n}\n",
        "package": "org.apache.commons.math4.legacy.core",
        "class_name": "Pair",
        "method_name": "hashCode",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic double slowCos(final double x, final double[] result) {\n\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        if ((i & 1) != 0) { // skip odd entries\n            continue;\n        }\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        if ((i & 2) != 0) { // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0]; ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "slowCos",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "splitReciprocal",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nprivate boolean containSameValues(double[] current,\n                                  double[] expect) {\n    if (expect.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     expect.length, size);\n    }\n\n    for (int i = 0; i < size; i++) {\n        if (!Precision.equals(current[i], expect[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n",
        "package": "org.apache.commons.math4.neuralnet",
        "class_name": "Neuron",
        "method_name": "containSameValues",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-math",
        "code": "\nstatic void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n    out.println(name);\n    checkLen(expectedLen, array2d.length);\n    out.println(TABLE_START_DECL + \" \");\n    int i = 0;\n    for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n        out.print(\"        {\");\n        for (double d : array) { // assume inner array has very few entries\n            out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n        }\n        out.println(\"}, // \" + i++);\n    }\n    out.println(TABLE_END_DECL);\n}\n",
        "package": "org.apache.commons.math4.core.jdkmath",
        "class_name": "AccurateMathCalc",
        "method_name": "printarray",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\nprivate static double[][] calculateSubMatrix(double[][] matrix){\n    int equations = matrix.length;\n    int coefficients = matrix[0].length;\n    double[][] result = new double[equations - 1][coefficients - 1];\n    for (int eq = 1; eq < equations; eq++) {\n        double factor = matrix[0][0] / matrix[eq][0];\n        for (int coe = 1; coe < coefficients; coe++) {\n            result[eq - 1][coe -1] = matrix[0][coe] - matrix[eq][coe]\n                    * factor;\n        }\n    }\n    if (equations == 1) {\n        return result;\n    }\n    // check for zero pivot element\n    if (result[0][0] == 0) {\n        boolean found = false;\n        for (int i = 0; i < result.length; i ++) {\n            if (result[i][0] != 0) {\n                found = true;\n                double[] temp = result[0];\n                System.arraycopy(result[i], 0, result[0], 0, \n                        result[i].length);\n                System.arraycopy(temp, 0, result[i], 0, temp.length);\n                break;\n            }\n        }\n        if (!found) {\n            //System.out.println(\"Equation has no solution!\");\n            return new double[equations - 1][coefficients - 1];\n        }\n    }\n    double[][] subMatrix = calculateSubMatrix(result);\n    for (int eq = 1; eq < equations -  1; eq++) {\n        result[eq][0] = 0;\n        if (coefficients - 1 - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, result[eq], 1, coefficients - 1 - 1);\n    }\n    return result;\n}\n",
        "package": "org.jfree.data.statistics",
        "class_name": "Regression",
        "method_name": "calculateSubMatrix",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static double calculatePieDatasetTotal(PieDataset dataset) {\n    Args.nullNotPermitted(dataset, \"dataset\");\n    List keys = dataset.getKeys();\n    double totalValue = 0;\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable current = (Comparable) iterator.next();\n        if (current != null) {\n            Number value = dataset.getValue(current);\n            double v = 0.0;\n            if (value != null) {\n                v = value.doubleValue();\n            }\n            if (v > 0) {\n                totalValue = totalValue + v;\n            }\n        }\n    }\n    return totalValue;\n}\n",
        "package": "org.jfree.data.general",
        "class_name": "DatasetUtils",
        "method_name": "calculatePieDatasetTotal",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\n@Override\npublic boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Series)) {\n        return false;\n    }\n    Series that = (Series) obj;\n    if (!Objects.equals(this.key, that.key)) {\n        return false;\n    }\n    if (!Objects.equals(this.description, that.description)) {\n        return false;\n    }\n    if (!that.canEqual(this)) {\n        return false;\n    }\n    return true;\n}\n",
        "package": "org.jfree.data.general",
        "class_name": "Series",
        "method_name": "equals",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static String writeKeyedValues(KeyedValues data) {\n    Args.nullNotPermitted(data, \"data\");\n    StringWriter sw = new StringWriter();\n    try {\n        writeKeyedValues(data, sw);\n    } catch (IOException ex) {\n        throw new RuntimeException(ex);\n    }\n    return sw.toString();\n}\n",
        "package": "org.jfree.data.json",
        "class_name": "JSONUtils",
        "method_name": "writeKeyedValues",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static double calculateQ1(List values) {\n    Args.nullNotPermitted(values, \"values\");\n\n    double result = Double.NaN;\n    int count = values.size();\n    if (count > 0) {\n        if (count % 2 == 1) {\n            if (count > 1) {\n                result = Statistics.calculateMedian(values, 0, count / 2);\n            }\n            else {\n                result = Statistics.calculateMedian(values, 0, 0);\n            }\n        }\n        else {\n            result = Statistics.calculateMedian(values, 0, count / 2 - 1);\n        }\n\n    }\n    return result;\n}\n",
        "package": "org.jfree.data.statistics",
        "class_name": "BoxAndWhiskerCalculator",
        "method_name": "calculateQ1",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jfreechart",
        "code": "\npublic static double[] getPowerRegression(double[][] data) {\n\n    int n = data.length;\n    if (n < 2) {\n        throw new IllegalArgumentException(\"Not enough data.\");\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        double x = Math.log(data[i][0]);\n        double y = Math.log(data[i][1]);\n        sumX += x;\n        sumY += y;\n        double xx = x * x;\n        sumXX += xx;\n        double xy = x * y;\n        sumXY += xy;\n    }\n    double sxx = sumXX - (sumX * sumX) / n;\n    double sxy = sumXY - (sumX * sumY) / n;\n    double xbar = sumX / n;\n    double ybar = sumY / n;\n\n    double[] result = new double[2];\n    result[1] = sxy / sxx;\n    result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n    return result;\n\n}\n",
        "package": "org.jfree.data.statistics",
        "class_name": "Regression",
        "method_name": "getPowerRegression",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-lang",
        "code": "\npublic CompareToBuilder append(final double[] lhs, final double[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "package": "org.apache.commons.lang3.builder",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "SourceCode&Full": [
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "commons-lang",
        "code": "\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "package": "org.apache.commons.lang3.builder",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "commons-lang",
        "code": "\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "package": "org.apache.commons.lang3.builder",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Test Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "// Fast fuzzy version.  Used a cached value until it gets old, then re-up\n// the cache.\npublic long estimate_sum( ) {\n  // For short tables, just do the work\n  if( _t.length <= 64 ) return sum();\n  // For bigger tables, periodically freshen a cached value\n  long millis = System.currentTimeMillis();\n  if( _fuzzy_time != millis ) { // Time marches on?\n    _fuzzy_sum_cache = sum(); // Get sum the hard way\n    _fuzzy_time = millis;   // Indicate freshness of cached value\n  }\n  return _fuzzy_sum_cache;  // Return cached sum\n}\n",
        "package": "org.jctools.maps",
        "class_name": "ConcurrentAutoTable",
        "method_name": "estimate_sum",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "// Help any top-level NBSI to copy until completed.\n// Always return the _new version of *this* NBSI, in case we're nested.\nprivate NBSI help_copy() {\n  // Pick some words to help with - but only help copy the top-level NBSI.\n  // Nested NBSI waits until the top is done before we start helping.\n  NBSI top_nbsi = _non_blocking_set_int._nbsi;\n  final int HELP = 8;       // Tuning number: how much copy pain are we willing to inflict?\n  // We \"help\" by forcing individual bit indices to copy.  However, bits\n  // come in lumps of 64 per word, so we just advance the bit counter by 64's.\n  int idx = top_nbsi._copyIdx.getAndAdd(64*HELP);\n  for( int i=0; i<HELP; i++ ) {\n    int j = idx+i*64;\n    j %= (top_nbsi._bits.length<<6); // Limit, wrap to array size; means we retry indices\n    top_nbsi.help_copy_impl(j   );\n    top_nbsi.help_copy_impl(j+63); // Also force the nested-by-64 bit\n  }\n\n  // Top level guy ready to promote?\n  // Note: WE may not be the top-level guy!\n  if( top_nbsi._copyDone.get() == top_nbsi._sum_bits_length )\n    // One shot CAS to promote - it may fail since we are racing; others\n    // may promote as well\n    if( _non_blocking_set_int.CAS_nbsi( top_nbsi, top_nbsi._new ) ) {\n      //System.out.println(\"Promote at top level to size \"+(_non_blocking_set_int._nbsi._bits.length<<6));\n    }\n\n  // Return the new bitvector for 'fluid' programming style\n  return _new;\n}\n",
        "package": "org.jctools.maps",
        "class_name": "NonBlockingSetInt",
        "method_name": "help_copy",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\n@Override\npublic String toString() {\n  Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n  if( !i.hasNext())\n    return \"{}\";\n\n  StringBuilder sb = new StringBuilder();\n  sb.append('{');\n  for (;;) {\n    Entry<TypeK,TypeV> e = i.next();\n    TypeK key = e.getKey();\n    TypeV value = e.getValue();\n    sb.append(key   == this ? \"(this Map)\" : key);\n    sb.append('=');\n    sb.append(value == this ? \"(this Map)\" : value);\n    if( !i.hasNext())\n      return sb.append('}').toString();\n    sb.append(\", \");\n  }\n}\n",
        "package": "org.jctools.maps",
        "class_name": "NonBlockingHashMap",
        "method_name": "toString",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "// Help copy this one word.  State Machine.\n// (1) If not \"made immutable\" in the old array, set the sign bit to make\n//     it immutable.\n// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old\n// (3) If non-zero in old array & non-zero in new, CAS old to zero\n// (4) Zero in old, new is valid\n// At this point, old should be immutable-zero & new has a copy of bits\nprivate NBSI help_copy_impl( int i ) {\n  // Handle every 64th bit via using a nested array\n  NBSI old = this;          // The bit array being copied from\n  NBSI nnn = _new;          // The bit array being copied to\n  if( nnn == null ) return this; // Promoted already\n  int j = i;                // The bit index being added\n  while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n    old = old._nbsi64;      // Recurse\n    nnn = nnn._nbsi64;      // Recurse\n    j = j>>6;               // Strip off low 6 bits (all set)\n  }\n\n  // Transit from state 1: word is not immutable yet\n  // Immutable is in bit 63, the sign bit.\n  long bits = old._bits[j>>6];\n  while( bits >= 0 ) {      // Still in state (1)?\n    long oldbits = bits;\n    bits |= mask(63);       // Target state of bits: sign-bit means immutable\n    if( old.CAS( j>>6, oldbits, bits ) ) {\n      if( oldbits == 0 ) _copyDone.addAndGet(1);\n      break;                // Success - old array word is now immutable\n    }\n    bits = old._bits[j>>6]; // Retry if CAS failed\n  }\n\n  // Transit from state 2: non-zero in old and zero in new\n  if( bits != mask(63) ) {  // Non-zero in old?\n    long new_bits = nnn._bits[j>>6];\n    if( new_bits == 0 ) {   // New array is still zero\n      new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n      // One-shot CAS attempt, no loop, from 0 to non-zero.\n      // If it fails, somebody else did the copy for us\n      if( !nnn.CAS( j>>6, 0, new_bits ) )\n        new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n      assert new_bits != 0;\n    }\n\n    // Transit from state 3: non-zero in old and non-zero in new\n    // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n    if( old.CAS( j>>6, bits, mask(63) ) )\n      _copyDone.addAndGet(1); // One more word finished copying\n  }\n\n  // Now in state 4: zero (and immutable) in old\n\n  // Return the self bitvector for 'fluid' programming style\n  return this;\n}\n",
        "package": "org.jctools.maps",
        "class_name": "NonBlockingSetInt",
        "method_name": "help_copy_impl",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\nprivate int probe() {\n    // Fast path for reliable well-distributed probe, available from JDK 7+.\n    // As long as PROBE is final static this branch will be constant folded\n    // (i.e removed).\n    if (PROBE != -1) {\n        int probe;\n        if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n            ThreadLocalRandom.current(); // force initialization\n            probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n        }\n        return probe;\n    }\n\n    /*\n     * Else use much worse (for values distribution) method:\n     * Mix thread id with golden ratio and then xorshift it\n     * to spread consecutive ids (see Knuth multiplicative method as reference).\n     */\n    int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n    // xorshift\n    probe ^= probe << 13;\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n    return probe;\n}\n\n",
        "package": "org.jctools.counters",
        "class_name": "FixedSizeStripedLongCounterPrePad",
        "method_name": "probe",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\n@Override\npublic boolean offer(final E e)\n{\n    // Objects.requireNonNull(e);\n    if (null == e)\n    {\n        throw new NullPointerException();\n    }\n    // local load of field to avoid repeated loads after volatile reads\n    final E[] buffer = producerBuffer;\n    final long index = lpProducerIndex();\n    final long mask = producerMask;\n    final long offset = calcCircularRefElementOffset(index, mask);\n    // expected hot path\n    if (index < producerBufferLimit)\n    {\n        writeToQueue(buffer, e, index, offset);\n        return true;\n    }\n    return offerColdPath(buffer, mask, index, offset, e, null);\n}\n",
        "package": "org.jctools.queues",
        "class_name": "BaseSpscLinkedArrayQueuePrePad",
        "method_name": "offer",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "JCTools",
        "code": "\n@Override\npublic final int size()\n{\n    // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n    LinkedQueueNode<E> chaserNode = lvConsumerNode();\n    LinkedQueueNode<E> producerNode = lvProducerNode();\n    int size = 0;\n    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n    while (chaserNode != producerNode && // don't go passed producer node\n        chaserNode != null && // stop at last node\n        size < Integer.MAX_VALUE) // stop at max int\n    {\n        LinkedQueueNode<E> next;\n        next = chaserNode.lvNext();\n        // check if this node has been consumed, if so return what we have\n        if (next == chaserNode)\n        {\n            return size;\n        }\n        chaserNode = next;\n        size++;\n    }\n    return size;\n}\n",
        "package": "org.jctools.queues",
        "class_name": "BaseLinkedQueuePad0",
        "method_name": "size",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "// Determine the prior (lower number) region that meets the desired conditions\npublic static int PriorRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n{\n    double DParent = (double) Parent; \n    double DColor = (double) Color; if(DColor > 0) DColor = 1;\n    \n    int i;\n    for(i = Label; i >= 0; i--)\n    {\n        double [] Region = RegionData[i];\n        double ThisParent = Region[BLOBPARENT];\n        double ThisColor = Region[BLOBCOLOR];\n        if(DParent >= 0 && DParent != ThisParent) continue;\n        if(DColor >= 0 && DColor != ThisColor) continue;\n        if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n        break;      // We have a match!\n    }\n    if(i < 0) i = -1;   // Use -1 to flag that there was no match\n    return i;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Blobs",
        "method_name": "PriorRegion",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\ndouble[] locatePlanarObject(KeyPointVector objectKeypoints, Mat objectDescriptors,\n        KeyPointVector imageKeypoints, Mat imageDescriptors, double[] srcCorners) {\n    ptpairs.clear();\n    if (settings.useFLANN) {\n        flannFindPairs(objectDescriptors, imageDescriptors);\n    } else {\n        findPairs(objectDescriptors, imageDescriptors);\n    }\n    int n = ptpairs.size()/2;\n    logger.info(n + \" matching pairs found\");\n    if (n < settings.matchesMin) {\n        return null;\n    }\n\n    pt1 .resize(n);\n    pt2 .resize(n);\n    mask.resize(n);\n    FloatBuffer pt1Idx = pt1.createBuffer();\n    FloatBuffer pt2Idx = pt2.createBuffer();\n    for (int i = 0; i < n; i++) {\n        Point2f p1 = objectKeypoints.get(ptpairs.get(2*i)).pt();\n        pt1Idx.put(2*i, p1.x()); pt1Idx.put(2*i+1, p1.y());\n        Point2f p2 = imageKeypoints.get(ptpairs.get(2*i+1)).pt();\n        pt2Idx.put(2*i, p2.x()); pt2Idx.put(2*i+1, p2.y());\n    }\n\n    H = findHomography(pt1, pt2, CV_RANSAC, settings.ransacReprojThreshold, mask, 2000, 0.995);\n    if (H.empty() || countNonZero(mask) < settings.matchesMin) {\n        return null;\n    }\n\n    double[] h = (double[])H.createIndexer(false).array();\n    double[] dstCorners = new double[srcCorners.length];\n    for(int i = 0; i < srcCorners.length/2; i++) {\n        double x = srcCorners[2*i], y = srcCorners[2*i + 1];\n        double Z = 1/(h[6]*x + h[7]*y + h[8]);\n        double X = (h[0]*x + h[1]*y + h[2])*Z;\n        double Y = (h[3]*x + h[4]*y + h[5])*Z;\n        dstCorners[2*i    ] = X;\n        dstCorners[2*i + 1] = Y;\n    }\n    return dstCorners;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "ObjectFinder",
        "method_name": "locatePlanarObject",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\nprivate static Pointer cloneBufferArray(Buffer[] srcBuffers, Buffer[] clonedBuffers) {\n    Pointer opaque = null;\n\n    if (srcBuffers != null && srcBuffers.length > 0) {\n        int totalCapacity = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            totalCapacity += srcBuffers[i].capacity();\n        }\n\n        /*\n         * In order to optimize the transfer we need a type check.\n         *\n         * Most CPUs support hardware memory transfer for different data\n         * types, so it's faster to copy more bytes at once rather\n         * than one byte per iteration as in case of ByteBuffer.\n         *\n         * For example, Intel CPUs support MOVSB (byte transfer), MOVSW\n         * (word transfer), MOVSD (double word transfer), MOVSS (32 bit\n         * scalar single precision floating point), MOVSQ (quad word\n         * transfer) and so on...\n         *\n         * Type checking may be improved by changing the order in\n         * which a buffer is checked against. If it's likely that the\n         * expected buffer is of type \"ShortBuffer\", then it should be\n         * checked at first place.\n         *\n         */\n\n        if (srcBuffers[0] instanceof ByteBuffer) {\n            BytePointer pointer = new BytePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ByteBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof ShortBuffer) {\n            ShortPointer pointer = new ShortPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ShortBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof IntBuffer) {\n            IntPointer pointer = new IntPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((IntBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof LongBuffer) {\n            LongPointer pointer = new LongPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((LongBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof FloatBuffer) {\n            FloatPointer pointer = new FloatPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((FloatBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof DoubleBuffer) {\n            DoublePointer pointer = new DoublePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((DoubleBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        }\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n    }\n\n    if (opaque != null) {\n        opaque.retainReference();\n    }\n    return opaque;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Frame",
        "method_name": "cloneBufferArray",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic Frame convert(byte[] data, int width, int height) {\n    if (frame == null || frame.imageWidth != width\n            || frame.imageHeight != height || frame.imageChannels != 3) {\n        if (frame != null) {\n            frame.close();\n        }\n        frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n\n    // ported from https://android.googlesource.com/platform/development/+/master/tools/yuv420sp2rgb/yuv420sp2rgb.c\n    int offset = height * width;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n\n            if (Y < 0)\n                Y = 0;\n\n            // R = (int)(1.164 * Y + 2.018 * U);\n            // G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n            // B = (int)(1.164 * Y + 1.596 * V);\n\n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n\n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n\n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n\n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    return frame;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "AndroidFrameConverter",
        "method_name": "convert",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic static String[] listPS3Cameras() {\n    int no = getCameraCount();\n    String[] uuids;\n    if (no > 0) {\n        uuids = new String[no];\n        for (--no; no >=0; no--) { uuids[no] = CLCamera.cameraUUID(no); }\n        return uuids;\n    }\n    return null;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "PS3EyeFrameGrabber",
        "method_name": "listPS3Cameras",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\nprivate static int toIntExact(long value) {\n    if ((int) value != value) {\n        throw new ArithmeticException(\"integer overflow\");\n    }\n    return (int) value;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "IPCameraFrameGrabber",
        "method_name": "toIntExact",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic Frame grab() throws Exception {\n    device.wait_for_frames();\n\n      frameNumber++; \n    // For Framegrabber\n    if (colorEnabled && behaveAsColorFrameGrabber) {\n        IplImage image = grabVideo();\n\n        if (returnImage == null) {\n            int deviceWidth = device.get_stream_width(RealSense.color);\n            int deviceHeight = device.get_stream_height(RealSense.color);\n              returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 3);\n            returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 1);\n        }\n        cvCvtColor(image, returnImage, CV_BGR2GRAY);\n        return converter.convert(returnImage);\n    } else {\n        if (IREnabled) {\n            return converter.convert(grabIR());\n        } else {\n            if (depthEnabled) {\n                \n                // Fake colors\n                IplImage image = grabDepth();\n                if (returnImage == null) {\n                    int deviceWidth = device.get_stream_width(RealSense.depth);\n                    int deviceHeight = device.get_stream_height(RealSense.depth);\n              returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 3);\n                    returnImage = IplImage.create(deviceWidth, deviceHeight, IPL_DEPTH_8U, 1);\n                } \n                return converter.convert(returnImage);\n            }\n        }\n    }\n\n    return null;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "RealSenseFrameGrabber",
        "method_name": "grab",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic static double homogToRt(CvMat H,\n        CvMat R1, CvMat t1, CvMat n1,\n        CvMat R2, CvMat t2, CvMat n2) {\n    CvMat S = S3x3.get(), U = U3x3.get(), V = V3x3.get();\n    cvSVD(H, S, U, V, 0);\n    double zeta = homogToRt(S, U, V, R1, t1, n1, R2, t2, n2);\n    return zeta;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "JavaCV",
        "method_name": "homogToRt",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "// Determine the next (higher number) region that meets the desired conditions\npublic static int NextRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n{\n    double DParent = (double) Parent; \n    double DColor = (double) Color; if(DColor > 0) DColor = 1;\n    \n    int i;\n    for(i = Label; i <= MaxLabel; i++)\n    {\n        double [] Region = RegionData[i];\n        double ThisParent = Region[BLOBPARENT];\n        double ThisColor = Region[BLOBCOLOR];\n        if(DParent >= 0 && DParent != ThisParent) continue;\n        if(DColor >= 0 && DColor != ThisColor) continue;\n        if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n        break;      // We have a match!\n    }\n    if(i > MaxLabel) i = -1;    // Use -1 to flag that there was no match\n    return i;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Blobs",
        "method_name": "NextRegion",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\n@Override\npublic Frame clone() {\n    Frame newFrame = new Frame();\n\n    // Video part\n    newFrame.imageWidth = imageWidth;\n    newFrame.imageHeight = imageHeight;\n    newFrame.imageDepth = imageDepth;\n    newFrame.imageChannels = imageChannels;\n    newFrame.imageStride = imageStride;\n    newFrame.keyFrame = keyFrame;\n    newFrame.pictType = pictType;\n    newFrame.streamIndex = streamIndex;\n    newFrame.type = type;\n    newFrame.opaque = new Pointer[3];\n    if (image != null) {\n        newFrame.image = new Buffer[image.length];\n        ((Pointer[])newFrame.opaque)[0] = cloneBufferArray(image, newFrame.image);\n    }\n\n    // Audio part\n    newFrame.audioChannels = audioChannels;\n    newFrame.sampleRate = sampleRate;\n    if (samples != null) {\n        newFrame.samples = new Buffer[samples.length];\n        ((Pointer[])newFrame.opaque)[1] = cloneBufferArray(samples, newFrame.samples);\n    }\n\n    // Other data streams\n    if (data != null) {\n        ByteBuffer[] dst = new ByteBuffer[1];\n        ((Pointer[])newFrame.opaque)[2] = cloneBufferArray(new ByteBuffer[]{data}, dst);\n        newFrame.data = dst[0];\n    }\n\n    // Add timestamp\n    newFrame.timestamp = timestamp;\n\n    return newFrame;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Frame",
        "method_name": "clone",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic double getAudioFrameRate() {\n    if (audio_st == null) {\n        return 0.0;\n    } else {\n        if (samples_frame == null || samples_frame.nb_samples() == 0) {\n            try {\n                grabFrame(true, false, false, false, false);\n                frameGrabbed = true;\n            } catch (Exception e) {\n                return 0.0;\n            }\n        }\n        if (samples_frame != null && samples_frame.nb_samples() != 0)\n            return ((double) getSampleRate()) / samples_frame.nb_samples();\n        else return 0.0;\n\n    }\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "FFmpegFrameGrabber",
        "method_name": "getAudioFrameRate",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "\npublic int[] grab_raw() {\n    if (camera.getCameraFrame(ps3_frame, timeout)) {\n        return ps3_frame;\n    }\n    else return null;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "PS3EyeFrameGrabber",
        "method_name": "grab_raw",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "javacv",
        "code": "//---------------------------------------------------------------------------------------\n// Main blob analysis routine\n//---------------------------------------------------------------------------------------\n// RegionData[0] is the border. It has Property[BLOBPARENT] = 0. \n\npublic int BlobAnalysis(IplImage Src,           // input image\n            int Col0, int Row0,                 // start of ROI\n            int Cols, int Rows,                 // size of ROI\n            int Border,                         // border color (0 = black; 1 = white)\n            int MinArea)                        // minimum region area\n{\n    CvMat SrcMat = Src.asCvMat();\n    int SrcCols = SrcMat.cols();\n    int SrcRows = SrcMat.rows();\n    \n    if(Col0 < 0) Col0 = 0;\n    if(Row0 < 0) Row0 = 0;\n    if(Cols < 0) Cols = SrcCols;\n    if(Rows < 0) Rows = SrcRows;\n    if(Col0 + Cols > SrcCols) Cols = SrcCols - Col0;\n    if(Row0 + Rows > SrcRows) Rows = SrcRows - Row0;\n\n    if(Cols > BLOBCOLCOUNT || Rows > BLOBROWCOUNT )\n    {\n        System.out.println(\"Error in Class Blobs: Image too large: Edit Blobs.java\");\n        System.exit(666);\n        return 0;\n    }\n    \n    // Initialization\n    int FillLabel = 0;\n    int FillColor = 0; if(Border > 0) { FillColor = 1; }\n    LabelA = LabelB = LabelC = LabelD = 0;\n    ColorA = ColorB = ColorC = ColorD = FillColor;\n    for(int k = 0; k < BLOBTOTALCOUNT; k++) SubsumedLabel[k] = -1;\n    \n    // Initialize border region\n    MaxLabel = 0;\n    double [] BorderRegion = RegionData[0];\n    BorderRegion[BLOBLABEL] = 0.0;\n    BorderRegion[BLOBPARENT] = -1.0;\n    BorderRegion[BLOBAREA] = Rows + Cols + 4;   // Top, left, and 4 corners\n    BorderRegion[BLOBCOLOR] = FillColor;\n    BorderRegion[BLOBSUMX] = 0.5 * ( (2.0 + Cols) * (Cols - 1.0) ) - Rows - 1 ;\n    BorderRegion[BLOBSUMY] = 0.5 * ( (2.0 + Rows) * (Rows - 1.0) ) - Cols - 1 ;\n    BorderRegion[BLOBMINX] = -1;\n    BorderRegion[BLOBMINY] = -1;\n    BorderRegion[BLOBMAXX] = Cols + 1.0;\n    BorderRegion[BLOBMAXY] = Rows + 1.0;\n    System.arraycopy(BorderRegion,0,RegionData[0],0,BLOBDATACOUNT); // RegionData[0] <- BorderRegion;\n    \n    //  The cells are identified this way\n    //          Last |AB|\n    //          This |CD|\n    //\n    // With 4 connectivity, there are 8 possibilities for the cells:\n    //                      No color transition     Color transition\n    //          Case              1  2  3  4          5  6  7  8 \n    //          Last Row        |pp|pp|pq|pq|       |pp|pp|pq|pq|   \n    //          This Row        |pP|qQ|pP|qQ|       |pQ|qP|pQ|qP|\n    //\n    // Region numbers are p, q, r, x; where p<>q\n    // Upper case letter is the current element at column=x row=y\n    // Color is 0 or 1      (1 stands for 255 in the actual image)\n    // Note that Case 4 is complicated because it joins two regions\n    //--------------------------\n    // Case 1: Colors A=B; C=D; A=C     \n    // Case 2: Colors A=B; C=D; A<>C    \n    // Case 3: Colors A<>B;C=D; A=C     \n    // Case 4: Colors A<>B;C=D; A<>C    \n    // Case 5: Colors A=B; C<>D; A=C    \n    // Case 6: Colors A=B; C<>D; A<>C   \n    // Case 7: Colors A<>B;C<>D; A=C    \n    // Case 8: Colors A<>B;C<>D; A<>C   \n    //--------------------------\n                \n    // Loop over rows of ROI. irow = Row0 is 1st row of image; irow = Row0+Row is last row of image.\n    for(int irow = Row0; irow < Row0+Rows; irow++)  // index within Src\n    {\n        jrow = irow - Row0; // index within ROI. 0 is first row. Rows is last row.\n        \n        // Loop over columns of ROI.\n        for(int icol = Col0; icol < Col0+Cols; icol++)  // index within Src\n        {\n            jcol = icol - Col0; // index within ROI\n\n            // initialize\n            ColorA = ColorB = ColorC = FillColor;\n            LabelA = LabelB = LabelC = LabelD = 0;\n            ColorD = (int) SrcMat.get(jrow,jcol);       // fetch color of cell\n        \n            if(jrow == 0 || jcol == 0)  // first column or row\n            {\n                if(jcol > 0)\n                {\n                    ColorC = (int) SrcMat.get(jrow,jcol-1);\n                    LabelC = LabelMat[jrow][jcol-1];\n                }\n                if(jrow > 0)\n                {\n                    ColorB = (int) SrcMat.get(jrow-1,jcol);\n                    LabelB = LabelMat[jrow-1][jcol];\n                }\n            }\n            else\n            {\n                ColorA = (int) SrcMat.get(jrow-1,jcol-1); if(ColorA > 0) ColorA = 1;\n                ColorB = (int) SrcMat.get(jrow-1,jcol); if(ColorB > 0) ColorB = 1;\n                ColorC = (int) SrcMat.get(jrow,jcol-1); if(ColorC > 0) ColorC = 1;\n                LabelA = LabelMat[jrow-1][jcol-1];\n                LabelB = LabelMat[jrow-1][jcol];\n                LabelC = LabelMat[jrow][jcol-1];\n            }   \n            if(ColorA > 0) ColorA = 1;\n            if(ColorB > 0) ColorB = 1;\n            if(ColorC > 0) ColorC = 1;\n            if(ColorD > 0) ColorD = 1;\n                \n            // Determine Case\n            int Case = 0;\n            if(ColorA == ColorB)\n            {\n                if(ColorC == ColorD) { if(ColorA == ColorC) Case = 1; else Case = 2; }\n                else { if(ColorA == ColorC) Case = 5; else Case = 6; }\n            }\n            else\n            {\n                if(ColorC == ColorD) { if(ColorA == ColorC) Case = 3; else Case = 4; }\n                else { if(ColorA == ColorC) Case = 7; else Case = 8; }\n            }\n\n            // Take appropriate action\n            if(Case == 1) { OldRegion(LabelC, -1, -1); }\n            else if(Case == 2 || Case == 3) { OldRegion(LabelC, LabelB, LabelC); }\n            else if(Case == 5 || Case == 8) // Isolated\n            {\n                if((jrow == Rows || jcol == Cols) && ColorD == FillColor) { OldRegion(0, -1, -1); } // attached to border region 0\n                else NewRegion(LabelB);\n            }\n            else if(Case == 6 || Case == 7) { OldRegion(LabelB, LabelB, LabelC); }\n            else            // Case 4 - The complicated situation\n            {\n                int LabelBRoot = SubsumptionChain(LabelB); \n                int LabelCRoot = SubsumptionChain(LabelC);\n                int LabelRoot = Math.min(LabelBRoot, LabelCRoot);\n                int LabelX;\n                if(LabelBRoot < LabelCRoot) { OldRegion(LabelB, -1, -1); LabelX = LabelC; }\n                else { OldRegion(LabelC, -1, -1); LabelX = LabelB; }\n                int NextLabelX = LabelX;\n                while(LabelRoot < LabelX)\n                {\n                    NextLabelX = SubsumedLabel[LabelX];\n                    SubsumedLabel[LabelX] = LabelRoot;\n                    LabelX = NextLabelX;\n                }\n            }\n                \n            // Last column or row. Final corner was handled earlier in Cases 5 and 8.\n            if((jrow == Rows || jcol == Cols) && ColorD == FillColor)\n            {\n                if(jcol < Cols)         // bottom row   \n                {\n                    if(ColorC != FillColor)     // Subsume B chain to border region 0\n                    {\n                        int LabelRoot = SubsumptionChain(LabelB);\n                        SubsumedLabel[LabelRoot] = 0;\n                    }\n                }\n                else if(jrow < Rows)    // right column\n                {\n                    if(ColorB != FillColor)     // Subsume C chain to border region 0\n                    {\n                        int LabelRoot = SubsumptionChain(LabelC);\n                        SubsumedLabel[LabelRoot] = 0;\n                    }\n                }\n                OldRegion(0, -1, -1);   // attached to border region 0\n            }\n\n            LabelMat[jrow][jcol] = LabelD;\n                \n        }\n    }\n\n    // Compute Condensation map\n    int Offset = 0;\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        if(SubsumedLabel[Label] > -1) Offset++;\n        CondensationMap[Label] = Label - Offset;\n    }\n\n    // Subsume regions that were flagged as connected; Perimeters add\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        int BetterLabel = SubsumptionChain(Label);\n        if(BetterLabel != Label) Subsume(BetterLabel, Label, 1);\n    }   \n\n    // Condense subsumed regions\n    int NewMaxLabel = 0;\n    for(int OldLabel = 1; OldLabel <= MaxLabel; OldLabel++)\n    {\n        if(SubsumedLabel[OldLabel] < 0) // Renumber valid regions only\n        {\n            double [] OldRegion = RegionData[OldLabel];\n            int OldParent = (int) OldRegion[BLOBPARENT];\n            int NewLabel = CondensationMap[OldLabel];\n            int NewParent = SubsumptionChain(OldParent);\n            NewParent = CondensationMap[NewParent];\n            OldRegion[BLOBLABEL] = (double) NewLabel;\n            OldRegion[BLOBPARENT] = (double) NewParent;\n            System.arraycopy(OldRegion,0,RegionData[NewLabel],0,BLOBDATACOUNT); //RegionData[NewLabel] <- ThisRegion;\n            NewMaxLabel = NewLabel;\n        }\n    }\n\n    // Zero out unneeded high labels\n    for(int Label = NewMaxLabel+1; Label <= MaxLabel; Label++) ResetRegion(Label);\n    MaxLabel = NewMaxLabel;\n    \n    // Flag for subsumption regions that have too small area\n    for(int Label = MaxLabel; Label > 0; Label--)\n    {\n        double [] ThisRegion = RegionData[Label];\n        int ThisArea = (int) ThisRegion[BLOBAREA];\n        if(ThisArea < MinArea)\n        {\n            int ThisParent = (int) ThisRegion[BLOBPARENT];\n            SubsumedLabel[Label] =  ThisParent;             // Flag this label as having been subsumed\n        }\n        else SubsumedLabel[Label] =  -1;\n    }\n    \n    // Compute Condensation map\n    Offset = 0;\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        if(SubsumedLabel[Label] > -1) Offset++;\n        CondensationMap[Label] = Label - Offset;      \n    }\n\n    // Subsume regions that were flagged as enclosed; Perimeters subtract\n    for(int Label = 1; Label <= MaxLabel; Label++)\n    {\n        int BetterLabel = SubsumptionChain(Label);\n        if(BetterLabel != Label) Subsume(BetterLabel, Label, -1);\n    }   \n\n    // Condense subsumed regions\n    for(int OldLabel = 1; OldLabel <= MaxLabel; OldLabel++)\n    {\n        if(SubsumedLabel[OldLabel] < 0) // Renumber valid regions only\n        {\n            double [] OldRegion = RegionData[OldLabel];\n            int OldParent = (int) OldRegion[BLOBPARENT];\n            int NewLabel = CondensationMap[OldLabel];\n            int NewParent = SubsumptionChain(OldParent);\n            NewParent = CondensationMap[NewParent];\n            OldRegion[BLOBLABEL] = (double) NewLabel;\n            OldRegion[BLOBPARENT] = (double) NewParent;\n            System.arraycopy(OldRegion,0,RegionData[NewLabel],0,BLOBDATACOUNT); //RegionData[NewLabel] <- ThisRegion;\n            NewMaxLabel = NewLabel;\n        }\n    }\n    \n    // Zero out unneeded high labels\n    for(int Label = NewMaxLabel+1; Label <= MaxLabel; Label++) ResetRegion(Label);\n    MaxLabel = NewMaxLabel;\n\n    // Normalize summation fields into moments \n    for(int Label = 0; Label <= MaxLabel; Label++)\n    {\n        double [] ThisRegion = RegionData[Label];\n        \n        // Extract fields\n        double Area = ThisRegion[BLOBAREA];\n        double SumX = ThisRegion[BLOBSUMX];\n        double SumY = ThisRegion[BLOBSUMY];\n        double SumXX = ThisRegion[BLOBSUMXX];\n        double SumYY = ThisRegion[BLOBSUMYY];\n        double SumXY = ThisRegion[BLOBSUMXY];\n        \n        // Get averages\n        SumX /= Area;\n        SumY /= Area;\n        SumXX /= Area;\n        SumYY /= Area;\n        SumXY /= Area;\n        \n        // Create moments\n        SumXX -= SumX * SumX;\n        SumYY -= SumY * SumY;\n        SumXY -= SumX * SumY;\n        if(SumXY > -1.0E-14 && SumXY < 1.0E-14) SumXY = (float) 0.0; // Eliminate roundoff error\n\n        ThisRegion[BLOBSUMX] = SumX;\n        ThisRegion[BLOBSUMY] = SumY;\n        ThisRegion[BLOBSUMXX] = SumXX;\n        ThisRegion[BLOBSUMYY] = SumYY;\n        ThisRegion[BLOBSUMXY] = SumXY;\n\n        System.arraycopy(ThisRegion,0,RegionData[Label],0,BLOBDATACOUNT);   // RegionData[Label] <- ThisRegion;\n    }\n\n    // Adjust border region\n    BorderRegion = RegionData[0];\n    BorderRegion[BLOBSUMXX] = BorderRegion[BLOBSUMYY] = BorderRegion[BLOBSUMXY] = 0;    // Mark invalid fields\n    System.arraycopy(BorderRegion,0,RegionData[0],0,BLOBDATACOUNT); // RegionData[0] <- BorderRegion;\n    \n    return MaxLabel;\n}\n",
        "package": "org.bytedeco.javacv",
        "class_name": "Blobs",
        "method_name": "BlobAnalysis",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "\n@Transactional\n@PreAuthorize(value = \"@consumerPermissionValidator.hasCreateApplicationPermission(#request)\")\n@PostMapping(value = \"/apps\")\npublic void createApp(\n    @RequestBody OpenCreateAppDTO req,\n    HttpServletRequest request\n) {\n  if (null == req.getApp()) {\n    throw new BadRequestException(\"App is null\");\n  }\n  final OpenAppDTO app = req.getApp();\n  if (null == app.getAppId()) {\n    throw new BadRequestException(\"AppId is null\");\n  }\n  // create app\n  this.appOpenApiService.createApp(req);\n  if (req.isAssignAppRoleToSelf()) {\n    long consumerId = this.consumerAuthUtil.retrieveConsumerId(request);\n    consumerService.assignAppRoleToConsumer(consumerId, app.getAppId());\n  }\n}\n",
        "package": "com.ctrip.framework.apollo.openapi.v1.controller",
        "class_name": "AppController",
        "method_name": "createApp",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "\n@Override\npublic List<String> getEurekaServerServiceUrls(String myZone) {\n  List<String> urls = bizConfig.eurekaServiceUrls();\n  return CollectionUtils.isEmpty(urls) ? super.getEurekaServerServiceUrls(myZone) : urls;\n}\n",
        "package": "com.ctrip.framework.apollo.biz.eureka",
        "class_name": "ApolloEurekaClientConfig",
        "method_name": "getEurekaServerServiceUrls",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "//\u6253\u5370\u65e5\u5fd7, \u5176\u4e2dlogLevel\u4e3a\u65e5\u5fd7\u7ea7\u522b: ERROR/WARN/DEBUG/INFO/TRACE\nprivate void printLog(String message, Throwable ex, Level logLevel) {\n  switch (logLevel) {\n    case ERROR:\n      logger.error(message, ex);\n      break;\n    case WARN:\n      logger.warn(message, ex);\n      break;\n    case DEBUG:\n      logger.debug(message, ex);\n      break;\n    case INFO:\n      logger.info(message, ex);\n      break;\n    case TRACE:\n      logger.trace(message, ex);\n      break;\n  }\n\n  Tracer.logError(ex);\n}\n",
        "package": "com.ctrip.framework.apollo.common.controller",
        "class_name": "GlobalDefaultExceptionHandler",
        "method_name": "printLog",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "private boolean checkAccessToken(String token) {\n  String accessTokens = bizConfig.getAdminServiceAccessTokens();\n\n  // if user forget to configure access tokens, then default to pass\n  if (Strings.isNullOrEmpty(accessTokens)) {\n    return true;\n  }\n\n  // no need to check\n  if (Strings.isNullOrEmpty(token)) {\n    return false;\n  }\n\n  // update cache\n  if (!accessTokens.equals(lastAccessTokens)) {\n    synchronized (this) {\n      accessTokenList = ACCESS_TOKEN_SPLITTER.splitToList(accessTokens);\n      lastAccessTokens = accessTokens;\n    }\n  }\n\n  return accessTokenList.contains(token);\n}\n",
        "package": "com.ctrip.framework.apollo.adminservice.filter",
        "class_name": "AdminServiceAuthenticationFilter",
        "method_name": "checkAccessToken",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> mapByKey(String key, List<?> list) {\n  Map<K, V> map = new HashMap<>();\n  if (CollectionUtils.isEmpty(list)) {\n    return map;\n  }\n  try {\n    Class<?> clazz = list.get(0).getClass();\n    Field field = deepFindField(clazz, key);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Could not find the key\");\n    }\n    field.setAccessible(true);\n    for (Object o : list) {\n      map.put((K) field.get(o), (V) o);\n    }\n  } catch (Exception e) {\n    throw new BeanUtilsException(e);\n  }\n  return map;\n}\n",
        "package": "com.ctrip.framework.apollo.common.utils",
        "class_name": "BeanUtils",
        "method_name": "mapByKey",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "\nprivate static String getWellFormName(String envName) {\n  if (StringUtils.isBlank(envName)) {\n    return \"\";\n  }\n\n  String envWellFormName = envName.trim().toUpperCase();\n\n  // special case for production in case of typo\n  if (\"PROD\".equals(envWellFormName)) {\n    return Env.PRO.name;\n  }\n\n  // special case that FAT & FWS should map to FAT\n  if (\"FWS\".equals(envWellFormName)) {\n    return Env.FAT.name;\n  }\n\n  return envWellFormName;\n}\n",
        "package": "com.ctrip.framework.apollo.portal.environment",
        "class_name": "Env",
        "method_name": "getWellFormName",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "@Transactional\npublic GrayReleaseRule updateRulesReleaseId(String appId, String clusterName,\n                                 String namespaceName, String branchName,\n                                 long latestReleaseId, String operator) {\n  GrayReleaseRule oldRules = grayReleaseRuleRepository.\n      findTopByAppIdAndClusterNameAndNamespaceNameAndBranchNameOrderByIdDesc(appId, clusterName, namespaceName, branchName);\n\n  if (oldRules == null) {\n    return null;\n  }\n\n  GrayReleaseRule newRules = new GrayReleaseRule();\n  newRules.setBranchStatus(NamespaceBranchStatus.ACTIVE);\n  newRules.setReleaseId(latestReleaseId);\n  newRules.setRules(oldRules.getRules());\n  newRules.setAppId(oldRules.getAppId());\n  newRules.setClusterName(oldRules.getClusterName());\n  newRules.setNamespaceName(oldRules.getNamespaceName());\n  newRules.setBranchName(oldRules.getBranchName());\n  newRules.setDataChangeCreatedBy(operator);\n  newRules.setDataChangeLastModifiedBy(operator);\n\n  grayReleaseRuleRepository.save(newRules);\n\n  grayReleaseRuleRepository.delete(oldRules);\n\n  return newRules;\n}\n",
        "package": "com.ctrip.framework.apollo.biz.service",
        "class_name": "NamespaceBranchService",
        "method_name": "updateRulesReleaseId",
        "SourceCode&Full": [
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "apollo",
        "code": "\n@Override\npublic List<ServiceInstance> getInstances(String serviceName) {\n  if (Objects.equals(serviceName, this.selfInstance.getServiceName())) {\n    List<ServiceInstance> serviceInstances = this.delegate.getInstances(serviceName);\n    if (containSelf(serviceInstances, this.selfInstance)) {\n      // contains self instance already\n      return serviceInstances;\n    }\n\n    // add self instance to result\n    List<ServiceInstance> result = new ArrayList<>(serviceInstances.size() + 1);\n    result.add(this.selfInstance);\n    result.addAll(serviceInstances);\n    return result;\n  } else {\n    return this.delegate.getInstances(serviceName);\n  }\n}\n",
        "package": "com.ctrip.framework.apollo.biz.registry",
        "class_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl",
        "method_name": "getInstances",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int average(int[] numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    long sum = 0;\n    for (int number : numbers) {\n        sum += number;\n    }\n    return (int) (sum / numbers.length);\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "Average",
        "method_name": "average",
        "SourceCode&Full": [
            "Accept",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept"
        ]
    },
    {
        "project_name": "Java",
        "code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    int n = unsorted.length;\n    heapify(unsorted, n);\n    while (n > 1) {\n        swap(unsorted, 1, n--);\n        siftDown(unsorted, 1, n);\n    }\n    return unsorted;\n}\n",
        "package": "com.thealgorithms.sorts",
        "class_name": "HeapSort",
        "method_name": "sort",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "Node",
        "method_name": "possiblePaint",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic int indexOf(T element) {\n    Objects.requireNonNull(element);\n    Node<T> iterator = cursorSpace[head];\n    for (int i = 0; i < count; i++) {\n        if (iterator.element.equals(element)) {\n            return i;\n        }\n        iterator = cursorSpace[iterator.next];\n    }\n\n    return -1;\n}\n",
        "package": "com.thealgorithms.datastructures.lists",
        "class_name": "CursorLinkedList",
        "method_name": "indexOf",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\nNode mergeKList(Node[] a, int N) {\n    // Min Heap\n    PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n    // adding head of all linkedList in min heap\n    min.addAll(Arrays.asList(a).subList(0, N));\n\n    // Make new head among smallest heads in K linkedList\n    Node head = min.poll();\n    min.add(head.next);\n    Node curr = head;\n\n    // merging LinkedList\n    while (!min.isEmpty()) {\n        Node temp = min.poll();\n        curr.next = temp;\n        curr = temp;\n\n        // Add Node in min Heap only if temp.next is not null\n        if (temp.next != null) {\n            min.add(temp.next);\n        }\n    }\n\n    return head;\n}\n",
        "package": "com.thealgorithms.datastructures.lists",
        "class_name": "Merge_K_SortedLinkedlist",
        "method_name": "mergeKList",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static List<TreeSet<Integer>> combination(int n, int k) {\n    if (n <= 0) {\n        return null;\n    }\n    length = k;\n    Integer[] arr = new Integer[n];\n    for (int i = 1; i <= n; i++) {\n        arr[i - 1] = i;\n    }\n    return Combination.combination(arr, length);\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "ArrayCombination",
        "method_name": "combination",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String decimalToHex(int d) {\n    String digits = \"0123456789ABCDEF\";\n    if (d <= 0) {\n        return \"0\";\n    }\n    String hex = \"\";\n    while (d > 0) {\n        int digit = d % 16;\n        hex = digits.charAt(digit) + hex;\n        d = d / 16;\n    }\n    return hex;\n}\n",
        "package": "com.thealgorithms.conversions",
        "class_name": "OctalToHexadecimal",
        "method_name": "decimalToHex",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String convertToAnyBase(int inp, int base) {\n    ArrayList<Character> charArr = new ArrayList<>();\n\n    while (inp > 0) {\n        charArr.add(reVal(inp % base));\n        inp /= base;\n    }\n\n    StringBuilder str = new StringBuilder(charArr.size());\n\n    for (Character ch : charArr) {\n        str.append(ch);\n    }\n\n    return str.reverse().toString();\n}\n",
        "package": "com.thealgorithms.conversions",
        "class_name": "DecimalToAnyBase",
        "method_name": "convertToAnyBase",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Accept",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int getAliquotSum(int n) {\n    if (n <= 0) return -1;\n    int sum = 1;\n    double root = Math.sqrt(n);\n    /*\n     * We can get the factors after the root by dividing number by its factors\n     * before the root.\n     * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n     * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n     * Now by dividing 100 by each factor before 10 we get:\n     * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n     * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n     */\n    for (int i = 2; i <= root; i++) {\n        if (n % i == 0) {\n            sum += i + n / i;\n        }\n    }\n    // if n is a perfect square then its root was added twice in above loop, so subtracting root\n    // from sum\n    if (root == (int) root) sum -= root;\n    return sum;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "AliquotSum",
        "method_name": "getAliquotSum",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "MazeRecursion",
        "method_name": "setWay",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic Node find(int key) {\n    Node current = root;\n    while (current != null) {\n        if (key < current.data) {\n            if (current.left == null) {\n                return current; // The key isn't exist, returns the parent\n            }\n            current = current.left;\n        } else if (key > current.data) {\n            if (current.right == null) {\n                return current;\n            }\n            current = current.right;\n        } else { // If you find the value return it\n            return current;\n        }\n    }\n    return null;\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "BinaryTree",
        "method_name": "find",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\nArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n\n    ArrayList<E> answer = new ArrayList<>();\n\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n\n    return answer;\n}\n",
        "package": "com.thealgorithms.datastructures.graphs",
        "class_name": "AdjacencyList",
        "method_name": "topSortOrder",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic String decode(String encryptedMessage, int shift) {\n    StringBuilder decoded = new StringBuilder();\n\n    shift %= 26;\n\n    final int length = encryptedMessage.length();\n    for (int i = 0; i < length; i++) {\n        char current = encryptedMessage.charAt(i);\n        if (isCapitalLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n        } else if (isSmallLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n        } else {\n            decoded.append(current);\n        }\n    }\n    return decoded.toString();\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "Caesar",
        "method_name": "decode",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\nstatic int getTwinPrime(int inputNumber) {\n\n    // if inputNumber and (inputNumber + 2) are both prime\n    // then return (inputNumber + 2) as a result\n    if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n        return inputNumber + 2;\n    }\n    // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n    // then return -1 as a result\n    return -1;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "TwinPrime",
        "method_name": "getTwinPrime",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "// Determinant calculator\npublic static int determinant(int[][] a, int n) {\n    int det = 0, sign = 1, p = 0, q = 0;\n\n    if (n == 1) {\n        det = a[0][0];\n    } else {\n        int[][] b = new int[n - 1][n - 1];\n        for (int x = 0; x < n; x++) {\n            p = 0;\n            q = 0;\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (j != x) {\n                        b[p][q++] = a[i][j];\n                        if (q % (n - 1) == 0) {\n                            p++;\n                            q = 0;\n                        }\n                    }\n                }\n            }\n            det = det + a[0][x] * determinant(b, n - 1) * sign;\n            sign = -sign;\n        }\n    }\n    return det;\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "HillCipher",
        "method_name": "determinant",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n\n            temp.right.parent = temp.parent;\n\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n\n            temp.left.parent = temp.parent;\n\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "BinaryTree",
        "method_name": "remove",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int findMax(final int[] array) {\n    int n = array.length;\n    if (n == 0) {\n        throw new IllegalArgumentException(\"Array must be non-empty.\");\n    }\n    int max = array[0];\n    for (int i = 1; i < n; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "FindMax",
        "method_name": "findMax",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic Node middle() {\n    if (head == null) {\n        return null;\n    }\n    Node firstCounter = head;\n    Node secondCounter = firstCounter.next;\n    while (secondCounter != null && secondCounter.next != null) {\n        firstCounter = firstCounter.next;\n        secondCounter = secondCounter.next.next;\n    }\n    return firstCounter;\n}\n",
        "package": "com.thealgorithms.datastructures.lists",
        "class_name": "SinglyLinkedList",
        "method_name": "middle",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic boolean isArmstrong(int number) {\n    long sum = 0;\n    String temp = Integer.toString(number); // Convert the given number to a string\n    int power = temp.length(); // Extract the length of the number (number of digits)\n    long originalNumber = number;\n\n    while (originalNumber > 0) {\n        long digit = originalNumber % 10;\n        sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n        originalNumber /= 10;\n    }\n\n    return sum == number;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "Armstrong",
        "method_name": "isArmstrong",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic int peek() {\n    if (isEmpty()) {\n        throw new EmptyStackException();\n    }\n    return stack.get(stack.size() - 1);\n}\n",
        "package": "com.thealgorithms.datastructures.stacks",
        "class_name": "StackArrayList",
        "method_name": "peek",
        "SourceCode&Full": [
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "/* A function to get the sum of the elements from index l to index r. This will be called\n * internally*/\nprivate int getSumTree(int start, int end, int q_start, int q_end, int seg_index) {\n    if (q_start <= start && q_end >= end) {\n        return this.seg_t[seg_index];\n    }\n\n    if (q_start > end || q_end < start) {\n        return 0;\n    }\n\n    int mid = start + (end - start) / 2;\n    return (getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2));\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "SegmentTree",
        "method_name": "getSumTree",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "/*\n * @brief Swaps the bits at the position posA and posB from data\n */\npublic static int bitSwap(int data, final int posA, final int posB) {\n    if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n        data ^= (1 << posA) ^ (1 << posB);\n    }\n    return data;\n}\n",
        "package": "com.thealgorithms.bitmanipulation",
        "class_name": "BitSwap",
        "method_name": "bitSwap",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Accept",
            "Accept",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int calculateHammingDistance(String s1, String s2) throws Exception {\n    if (s1.length() != s2.length()) {\n        throw new Exception(\"String lengths must be equal\");\n    }\n\n    int stringLength = s1.length();\n    int counter = 0;\n\n    for (int i = 0; i < stringLength; i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            counter++;\n        }\n    }\n    return counter;\n}\n",
        "package": "com.thealgorithms.strings",
        "class_name": "HammingDistance",
        "method_name": "calculateHammingDistance",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String encode(String message, String cipherSmall) {\n    StringBuilder encoded = new StringBuilder();\n\n    // This map is used to encode\n    Map<Character, Character> cipherMap = new HashMap<>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    // To handle Small and Capital letters\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n        cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n    }\n\n    for (int i = 0; i < message.length(); i++) {\n        if (Character.isAlphabetic(message.charAt(i))) {\n            encoded.append(cipherMap.get(message.charAt(i)));\n        } else {\n            encoded.append(message.charAt(i));\n        }\n    }\n\n    return encoded.toString();\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "SimpleSubstitutionCipher",
        "method_name": "encode",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic void push(Item item) {\n    NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n    if (this.isEmpty()) {\n        NodeStack.setHead(new NodeStack<>(item));\n        newNs.setNext(null);\n        newNs.setPrevious(null);\n    } else {\n        newNs.setPrevious(NodeStack.head);\n        NodeStack.head.setNext(newNs);\n        NodeStack.setHead(newNs);\n    }\n\n    NodeStack.setSize(NodeStack.getSize() + 1);\n}\n",
        "package": "com.thealgorithms.datastructures.stacks",
        "class_name": "NodeStack",
        "method_name": "push",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int getMaxValue(int... numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    int absMax = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n            absMax = numbers[i];\n        }\n    }\n    return absMax;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "AbsoluteMax",
        "method_name": "getMaxValue",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String decode(String encryptedMessage, String cipherSmall) {\n    StringBuilder decoded = new StringBuilder();\n\n    Map<Character, Character> cipherMap = new HashMap<>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n        cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n    }\n\n    for (int i = 0; i < encryptedMessage.length(); i++) {\n        if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n            decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n        } else {\n            decoded.append(encryptedMessage.charAt(i));\n        }\n    }\n\n    return decoded.toString();\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "SimpleSubstitutionCipher",
        "method_name": "decode",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}\n",
        "package": "com.thealgorithms.datastructures.heaps",
        "class_name": "FibonacciHeap",
        "method_name": "insert",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "private Node rotateLeft(Node a) {\n    Node b = a.right;\n    b.parent = a.parent;\n\n    a.right = b.left;\n\n    if (a.right != null) {\n        a.right.parent = a;\n    }\n\n    b.left = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.left = b;\n        }\n    }\n\n    setBalance(a, b);\n\n    return b;\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "AVLTree",
        "method_name": "rotateLeft",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String toLowerCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n        if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n            values[i] = Character.toLowerCase(values[i]);\n        }\n    }\n    return new String(values);\n}\n",
        "package": "com.thealgorithms.strings",
        "class_name": "Lower",
        "method_name": "toLowerCase",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic boolean addEdge(int from, int to) {\n    if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) {\n        if (!this.adjacencyOfEdgeDoesExist(from, to)) {\n            this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_EXIST;\n            this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_EXIST;\n            this.setNumberOfEdges(this.numberOfEdges() + 1);\n            return true;\n        }\n    }\n\n    return false;\n}\n",
        "package": "com.thealgorithms.datastructures.graphs",
        "class_name": "MatrixGraphs",
        "method_name": "addEdge",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic int countGraphs() {\n    int count = 0;\n    Set<Node> markedNodes = new HashSet<Node>();\n\n    for (Node n : nodeList) {\n        if (!markedNodes.contains(n)) {\n            markedNodes.add(n);\n            markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n            count++;\n        }\n    }\n\n    return count;\n}\n",
        "package": "com.thealgorithms.datastructures.graphs",
        "class_name": "Graph",
        "method_name": "countGraphs",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "FloodFill",
        "method_name": "floodFill",
        "SourceCode&Full": [
            "Test Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic double process(double sample) {\n    double result = 0.0;\n\n    // Process\n    for (int i = 1; i <= order; i++) {\n        result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);\n    }\n    result = (result + coeffsB[0] * sample) / coeffsA[0];\n\n    // Feedback\n    for (int i = order - 1; i > 0; i--) {\n        historyX[i] = historyX[i - 1];\n        historyY[i] = historyY[i - 1];\n    }\n\n    historyX[0] = sample;\n    historyY[0] = result;\n\n    return result;\n}\n",
        "package": "com.thealgorithms.audiofilters",
        "class_name": "IIRFilter",
        "method_name": "process",
        "SourceCode&Full": [
            "Accept",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] array) {\n    doSort(array, 0, array.length - 1);\n    return array;\n}\n",
        "package": "com.thealgorithms.sorts",
        "class_name": "QuickSort",
        "method_name": "sort",
        "SourceCode&Full": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "FFT",
        "method_name": "fft",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic Map<String, SelectSqlInfo> parse() throws JSQLParserException {\n    // 1. \u521b\u5efa\u89e3\u6790\u5668\n    CCJSqlParserManager mgr = new CCJSqlParserManager();\n    // 2. \u4f7f\u7528\u89e3\u6790\u5668\u89e3\u6790sql\u751f\u6210\u5177\u6709\u5c42\u6b21\u7ed3\u6784\u7684java\u7c7b\n    Statement stmt = mgr.parse(new StringReader(this.sql));\n    if (stmt instanceof Select) {\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        this.parsedSql = selectBody.toString();\n        // 3. \u89e3\u6790select\u67e5\u8be2sql\u7684\u4fe1\u606f\n        if (selectBody instanceof PlainSelect) {\n            PlainSelect plainSelect = (PlainSelect) selectBody;\n            // 4. \u5408\u5e76 fromItems\n            List<FromItem> fromItems = new ArrayList<>();\n            fromItems.add(plainSelect.getFromItem());\n            // 4.1 \u5904\u7406join\u7684\u8868\n            List<Join> joins = plainSelect.getJoins();\n            if (joins != null) {\n                joins.forEach(join -> fromItems.add(join.getRightItem()));\n            }\n            // 5. \u5904\u7406 fromItems\n            for (FromItem fromItem : fromItems) {\n                // 5.1 \u901a\u8fc7\u8868\u540d\u7684\u65b9\u5f0ffrom\n                if (fromItem instanceof Table) {\n                    this.addSqlInfoByTable((Table) fromItem);\n                }\n                // 5.2 \u901a\u8fc7\u5b50\u67e5\u8be2\u7684\u65b9\u5f0ffrom\n                else if (fromItem instanceof SubSelect) {\n                    this.handleSubSelect((SubSelect) fromItem);\n                }\n            }\n            // 6. \u89e3\u6790 selectFields\n            List<SelectItem> selectItems = plainSelect.getSelectItems();\n            for (SelectItem selectItem : selectItems) {\n                // 6.1 \u67e5\u8be2\u7684\u662f\u5168\u90e8\u5b57\u6bb5\n                if (selectItem instanceof AllColumns) {\n                    // \u5f53 selectItem \u4e3a AllColumns \u65f6\uff0cfromItem \u5fc5\u5b9a\u4e3a Table\n                    String tableName = plainSelect.getFromItem(Table.class).getName();\n                    // \u6b64\u5904\u5fc5\u5b9a\u4e0d\u4e3a\u7a7a\uff0c\u56e0\u4e3a\u5728\u89e3\u6790 fromItem \u65f6\uff0c\u5df2\u7ecf\u5c06\u8868\u540d\u6dfb\u52a0\u5230 allTableMap \u4e2d\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    assert sqlInfo != null;\n                    // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                    sqlInfo.setSelectAll(true);\n                    sqlInfo.setSelectFields(null);\n                    sqlInfo.setRealSelectFields(null);\n                }\n                // 6.2 \u67e5\u8be2\u7684\u662f\u5e26\u8868\u522b\u540d\uff08 u.* )\u7684\u5168\u90e8\u5b57\u6bb5\n                else if (selectItem instanceof AllTableColumns) {\n                    AllTableColumns allTableColumns = (AllTableColumns) selectItem;\n                    String aliasName = allTableColumns.getTable().getName();\n                    // \u901a\u8fc7\u522b\u540d\u83b7\u53d6\u8868\u540d\n                    String tableName = this.tableAliasMap.get(aliasName);\n                    if (tableName == null) {\n                        tableName = aliasName;\n                    }\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    // \u5982\u679c\u6b64\u5904\u4e3a\u7a7a\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u6bb5\u662f\u901a\u8fc7\u5b50\u67e5\u8be2\u83b7\u53d6\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0d\u5904\u7406\uff0c\u53ea\u6709\u5b9e\u9645\u8868\u624d\u9700\u8981\u5904\u7406\n                    if (sqlInfo != null) {\n                        // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                        sqlInfo.setSelectAll(true);\n                        sqlInfo.setSelectFields(null);\n                        sqlInfo.setRealSelectFields(null);\n                    }\n                }\n                // 6.3 \u5404\u79cd\u5b57\u6bb5\u8868\u8fbe\u5f0f\u5904\u7406\n                else if (selectItem instanceof SelectExpressionItem) {\n                    SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n                    Expression expression = selectExpressionItem.getExpression();\n                    Alias alias = selectExpressionItem.getAlias();\n                    this.handleExpression(expression, alias, plainSelect.getFromItem());\n                }\n            }\n        } else {\n            log.warn(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody: {}\", selectBody.getClass().getName());\n            throw new JeecgBootException(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody\");\n        }\n    } else {\n        // \u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\n        throw new JeecgBootException(\"\u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\");\n    }\n    return this.allTableMap;\n}\n",
        "package": "org.jeecg.common.util.sqlparse",
        "class_name": "JSqlParserAllTableManager",
        "method_name": "parse",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nprotected ModelAndView exportXlsSheet(HttpServletRequest request, T object, Class<T> clazz, String title,String exportFields,Integer pageNum) {\n    // Step.1 \u7ec4\u88c5\u67e5\u8be2\u6761\u4ef6\n    QueryWrapper<T> queryWrapper = QueryGenerator.initQueryWrapper(object, request.getParameterMap());\n    LoginUser sysUser = (LoginUser) SecurityUtils.getSubject().getPrincipal();\n    // Step.2 \u8ba1\u7b97\u5206\u9875sheet\u6570\u636e\n    double total = service.count();\n    int count = (int)Math.ceil(total/pageNum);\n    //update-begin-author:liusq---date:20220629--for: \u591asheet\u5bfc\u51fa\u6839\u636e\u9009\u62e9\u5bfc\u51fa\u5199\u6cd5\u8c03\u6574 ---\n    // Step.3  \u8fc7\u6ee4\u9009\u4e2d\u6570\u636e\n    String selections = request.getParameter(\"selections\");\n    if (oConvertUtils.isNotEmpty(selections)) {\n        List<String> selectionList = Arrays.asList(selections.split(\",\"));\n        queryWrapper.in(\"id\",selectionList);\n    }\n    //update-end-author:liusq---date:20220629--for: \u591asheet\u5bfc\u51fa\u6839\u636e\u9009\u62e9\u5bfc\u51fa\u5199\u6cd5\u8c03\u6574 ---\n    // Step.4 \u591asheet\u5904\u7406\n    List<Map<String, Object>> listMap = new ArrayList<Map<String, Object>>();\n    for (int i = 1; i <=count ; i++) {\n        Page<T> page = new Page<T>(i, pageNum);\n        IPage<T> pageList = service.page(page, queryWrapper);\n        List<T> exportList = pageList.getRecords();\n        Map<String, Object> map = new HashMap<>(5);\n        ExportParams exportParams=new ExportParams(title + \"\u62a5\u8868\", \"\u5bfc\u51fa\u4eba:\" + sysUser.getRealname(), title+i,jeecgBaseConfig.getPath().getUpload());\n        exportParams.setType(ExcelType.XSSF);\n        //map.put(\"title\",exportParams);\n        //\u8868\u683cTitle\n        map.put(NormalExcelConstants.PARAMS,exportParams);\n        //\u8868\u683c\u5bf9\u5e94\u5b9e\u4f53\n        map.put(NormalExcelConstants.CLASS,clazz);\n        //\u6570\u636e\u96c6\u5408\n        map.put(NormalExcelConstants.DATA_LIST, exportList);\n        listMap.add(map);\n    }\n    // Step.4 AutoPoi \u5bfc\u51faExcel\n    ModelAndView mv = new ModelAndView(new JeecgEntityExcelView());\n    //\u6b64\u5904\u8bbe\u7f6e\u7684filename\u65e0\u6548 ,\u524d\u7aef\u4f1a\u91cd\u66f4\u65b0\u8bbe\u7f6e\u4e00\u4e0b\n    mv.addObject(NormalExcelConstants.FILE_NAME, title);\n    mv.addObject(NormalExcelConstants.MAP_LIST, listMap);\n    return mv;\n}\n",
        "package": "org.jeecg.common.system.base.controller",
        "class_name": "JeecgController",
        "method_name": "exportXlsSheet",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic static String desEncrypt(String data, String key, String iv) throws Exception {\n    //update-begin-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n    byte[] encrypted1 = Base64.decode(data);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n    IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n    byte[] original = cipher.doFinal(encrypted1);\n    String originalString = new String(original);\n    //\u52a0\u5bc6\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32\u4f1a\u51fa\u73b0\\u0000\n    return originalString.replaceAll(\"\\\\u0000\", \"\");\n    //update-end-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n}\n",
        "package": "org.jeecg.common.util.encryption",
        "class_name": "AesEncryptUtil",
        "method_name": "desEncrypt",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nprivate static void installMplus(QueryWrapper<?> queryWrapper,Object searchObj,Map<String, String[]> parameterMap) {\n\t\n\t/*\n\t * \u6ce8\u610f:\u6743\u9650\u67e5\u8be2\u7531\u524d\u7aef\u914d\u7f6e\u6570\u636e\u89c4\u5219 \u5f53\u4e00\u4e2a\u4eba\u6709\u591a\u4e2a\u6240\u5c5e\u90e8\u95e8\u65f6\u5019 \u53ef\u4ee5\u5728\u89c4\u5219\u914d\u7f6e\u5305\u542b\u6761\u4ef6 orgCode \u5305\u542b #{sys_org_code}\n\t\u4f46\u662f\u4e0d\u652f\u6301\u5728\u81ea\u5b9a\u4e49SQL\u4e2d\u5199orgCode in #{sys_org_code} \n\t\u5f53\u4e00\u4e2a\u4eba\u53ea\u6709\u4e00\u4e2a\u90e8\u95e8 \u5c31\u76f4\u63a5\u914d\u7f6e\u7b49\u4e8e\u6761\u4ef6: orgCode \u7b49\u4e8e #{sys_org_code} \u6216\u8005\u914d\u7f6e\u81ea\u5b9a\u4e49SQL: orgCode = '#{sys_org_code}'\n\t*/\n\t\n\t//\u533a\u95f4\u6761\u4ef6\u7ec4\u88c5 \u6a21\u7cca\u67e5\u8be2 \u9ad8\u7ea7\u67e5\u8be2\u7ec4\u88c5 \u7b80\u5355\u6392\u5e8f \u6743\u9650\u67e5\u8be2\n\tPropertyDescriptor[] origDescriptors = PropertyUtils.getPropertyDescriptors(searchObj);\n\tMap<String,SysPermissionDataRuleModel> ruleMap = getRuleMap();\n\t\n\t//\u6743\u9650\u89c4\u5219\u81ea\u5b9a\u4e49SQL\u8868\u8fbe\u5f0f\n\tfor (String c : ruleMap.keySet()) {\n\t\tif(oConvertUtils.isNotEmpty(c) && c.startsWith(SQL_RULES_COLUMN)){\n\t\t\tqueryWrapper.and(i ->i.apply(getSqlRuleValue(ruleMap.get(c).getRuleValue())));\n\t\t}\n\t}\n\t\n\tString name, type, column;\n\t// update-begin--Author:taoyan  Date:20200923 for\uff1aissues/1671 \u5982\u679c\u5b57\u6bb5\u52a0\u6ce8\u89e3\u4e86@TableField(exist = false),\u4e0d\u8d70DB\u67e5\u8be2-------\n\t//\u5b9a\u4e49\u5b9e\u4f53\u5b57\u6bb5\u548c\u6570\u636e\u5e93\u5b57\u6bb5\u540d\u79f0\u7684\u6620\u5c04 \u9ad8\u7ea7\u67e5\u8be2\u4e2d \u53ea\u80fd\u83b7\u53d6\u5b9e\u4f53\u5b57\u6bb5 \u5982\u679c\u8bbe\u7f6eTableField\u6ce8\u89e3 \u90a3\u4e48\u67e5\u8be2\u6761\u4ef6\u4f1a\u51fa\u95ee\u9898\n\tMap<String,String> fieldColumnMap = new HashMap<>(5);\n\tfor (int i = 0; i < origDescriptors.length; i++) {\n\t\t//aliasName = origDescriptors[i].getName();  mybatis  \u4e0d\u5b58\u5728\u5b9e\u4f53\u5c5e\u6027 \u4e0d\u7528\u5904\u7406\u522b\u540d\u7684\u60c5\u51b5\n\t\tname = origDescriptors[i].getName();\n\t\ttype = origDescriptors[i].getPropertyType().toString();\n\t\ttry {\n\t\t\tif (judgedIsUselessField(name)|| !PropertyUtils.isReadable(searchObj, name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObject value = PropertyUtils.getSimpleProperty(searchObj, name);\n\t\t\tcolumn = ReflectHelper.getTableFieldName(searchObj.getClass(), name);\n\t\t\tif(column==null){\n\t\t\t\t//column\u4e3anull\u53ea\u6709\u4e00\u79cd\u60c5\u51b5 \u90a3\u5c31\u662f \u6dfb\u52a0\u4e86\u6ce8\u89e3@TableField(exist = false) \u540e\u7eed\u90fd\u4e0d\u7528\u5904\u7406\u4e86\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfieldColumnMap.put(name,column);\n\t\t\t//\u6570\u636e\u6743\u9650\u67e5\u8be2\n\t\t\tif(ruleMap.containsKey(name)) {\n\t\t\t\taddRuleToQueryWrapper(ruleMap.get(name), column, origDescriptors[i].getPropertyType(), queryWrapper);\n\t\t\t}\n\t\t\t//\u533a\u95f4\u67e5\u8be2\n\t\t\tdoIntervalQuery(queryWrapper, parameterMap, type, name, column);\n\t\t\t//\u5224\u65ad\u5355\u503c  \u53c2\u6570\u5e26\u4e0d\u540c\u6807\u8bc6\u5b57\u7b26\u4e32 \u8d70\u4e0d\u540c\u7684\u67e5\u8be2\n\t\t\t//TODO \u8fd9\u79cd\u524d\u540e\u5e26\u9017\u53f7\u7684\u652f\u6301\u5206\u5272\u540e\u6a21\u7cca\u67e5\u8be2(\u591a\u9009\u5b57\u6bb5\u67e5\u8be2\u751f\u6548) \u793a\u4f8b\uff1a,1,3,\n\t\t\tif (null != value && value.toString().startsWith(COMMA) && value.toString().endsWith(COMMA)) {\n\t\t\t\tString multiLikeval = value.toString().replace(\",,\", COMMA);\n\t\t\t\tString[] vals = multiLikeval.substring(1, multiLikeval.length()).split(COMMA);\n\t\t\t\tfinal String field = oConvertUtils.camelToUnderline(column);\n\t\t\t\tif(vals.length>1) {\n\t\t\t\t\tqueryWrapper.and(j -> {\n                           log.info(\"---\u67e5\u8be2\u8fc7\u6ee4\u5668\uff0cQuery\u89c4\u5219---field:{}, rule:{}, value:{}\", field, \"like\", vals[0]);\n\t\t\t\t\t\tj = j.like(field,vals[0]);\n\t\t\t\t\t\tfor (int k=1;k<vals.length;k++) {\n\t\t\t\t\t\t\tj = j.or().like(field,vals[k]);\n\t\t\t\t\t\t\tlog.info(\"---\u67e5\u8be2\u8fc7\u6ee4\u5668\uff0cQuery\u89c4\u5219 .or()---field:{}, rule:{}, value:{}\", field, \"like\", vals[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//return j;\n\t\t\t\t\t});\n\t\t\t\t}else {\n\t\t\t\t\tlog.info(\"---\u67e5\u8be2\u8fc7\u6ee4\u5668\uff0cQuery\u89c4\u5219---field:{}, rule:{}, value:{}\", field, \"like\", vals[0]);\n\t\t\t\t\tqueryWrapper.and(j -> j.like(field,vals[0]));\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\t//\u6839\u636e\u53c2\u6570\u503c\u5e26\u4ec0\u4e48\u5173\u952e\u5b57\u7b26\u4e32\u5224\u65ad\u8d70\u4ec0\u4e48\u7c7b\u578b\u7684\u67e5\u8be2\n\t\t\t\tQueryRuleEnum rule = convert2Rule(value);\n\t\t\t\tvalue = replaceValue(rule,value);\n\t\t\t\t// add -begin \u6dfb\u52a0\u5224\u65ad\u4e3a\u5b57\u7b26\u4e32\u65f6\u8bbe\u4e3a\u5168\u6a21\u7cca\u67e5\u8be2\n\t\t\t\t//if( (rule==null || QueryRuleEnum.EQ.equals(rule)) && \"class java.lang.String\".equals(type)) {\n\t\t\t\t\t// \u53ef\u4ee5\u8bbe\u7f6e\u5de6\u53f3\u6a21\u7cca\u6216\u5168\u6a21\u7cca\uff0c\u56e0\u4eba\u800c\u5f02\n\t\t\t\t\t//rule = QueryRuleEnum.LIKE;\n\t\t\t\t//}\n\t\t\t\t// add -end \u6dfb\u52a0\u5224\u65ad\u4e3a\u5b57\u7b26\u4e32\u65f6\u8bbe\u4e3a\u5168\u6a21\u7cca\u67e5\u8be2\n\t\t\t\taddEasyQuery(queryWrapper, column, rule, value);\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t}\n\t}\n\t// \u6392\u5e8f\u903b\u8f91 \u5904\u7406\n\tdoMultiFieldsOrder(queryWrapper, parameterMap, fieldColumnMap);\n\t\t\t\n\t//\u9ad8\u7ea7\u67e5\u8be2\n\tdoSuperQuery(queryWrapper, parameterMap, fieldColumnMap);\n\t// update-end--Author:taoyan  Date:20200923 for\uff1aissues/1671 \u5982\u679c\u5b57\u6bb5\u52a0\u6ce8\u89e3\u4e86@TableField(exist = false),\u4e0d\u8d70DB\u67e5\u8be2-------\n\t\n}\n",
        "package": "org.jeecg.common.system.query",
        "class_name": "QueryGenerator",
        "method_name": "installMplus",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nprivate String getReqestParams(HttpServletRequest request, JoinPoint joinPoint) {\n    String httpMethod = request.getMethod();\n    String params = \"\";\n    if (CommonConstant.HTTP_POST.equals(httpMethod) || CommonConstant.HTTP_PUT.equals(httpMethod) || CommonConstant.HTTP_PATCH.equals(httpMethod)) {\n        Object[] paramsArray = joinPoint.getArgs();\n        // java.lang.IllegalStateException: It is illegal to call this method if the current request is not in asynchronous mode (i.e. isAsyncStarted() returns false)\n        //  https://my.oschina.net/mengzhang6/blog/2395893\n        Object[] arguments  = new Object[paramsArray.length];\n        for (int i = 0; i < paramsArray.length; i++) {\n            if (paramsArray[i] instanceof BindingResult || paramsArray[i] instanceof ServletRequest || paramsArray[i] instanceof ServletResponse || paramsArray[i] instanceof MultipartFile) {\n                //ServletRequest\u4e0d\u80fd\u5e8f\u5217\u5316\uff0c\u4ece\u5165\u53c2\u91cc\u6392\u9664\uff0c\u5426\u5219\u62a5\u5f02\u5e38\uff1ajava.lang.IllegalStateException: It is illegal to call this method if the current request is not in asynchronous mode (i.e. isAsyncStarted() returns false)\n                //ServletResponse\u4e0d\u80fd\u5e8f\u5217\u5316 \u4ece\u5165\u53c2\u91cc\u6392\u9664\uff0c\u5426\u5219\u62a5\u5f02\u5e38\uff1ajava.lang.IllegalStateException: getOutputStream() has already been called for this response\n                continue;\n            }\n            arguments[i] = paramsArray[i];\n        }\n        //update-begin-author:taoyan date:20200724 for:\u65e5\u5fd7\u6570\u636e\u592a\u957f\u7684\u76f4\u63a5\u8fc7\u6ee4\u6389\n        PropertyFilter profilter = new PropertyFilter() {\n            @Override\n            public boolean apply(Object o, String name, Object value) {\n                int length = 500;\n                if(value!=null && value.toString().length()>length){\n                    return false;\n                }\n                return true;\n            }\n        };\n        params = JSONObject.toJSONString(arguments, profilter);\n        //update-end-author:taoyan date:20200724 for:\u65e5\u5fd7\u6570\u636e\u592a\u957f\u7684\u76f4\u63a5\u8fc7\u6ee4\u6389\n    } else {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        // \u8bf7\u6c42\u7684\u65b9\u6cd5\u53c2\u6570\u503c\n        Object[] args = joinPoint.getArgs();\n        // \u8bf7\u6c42\u7684\u65b9\u6cd5\u53c2\u6570\u540d\u79f0\n        LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer();\n        String[] paramNames = u.getParameterNames(method);\n        if (args != null && paramNames != null) {\n            for (int i = 0; i < args.length; i++) {\n                params += \"  \" + paramNames[i] + \": \" + args[i];\n            }\n        }\n    }\n    return params;\n}\n",
        "package": "org.jeecg.common.aspect",
        "class_name": "AutoLogAspect",
        "method_name": "getReqestParams",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nprivate Boolean checkRoute(String routeId) {\n    Boolean hasRoute = false;\n    try {\n        //\u4fee\u590d\u4f7f\u7528\u5e26\u547d\u540d\u7a7a\u95f4\u542f\u52a8\u7f51\u5173swagger\u770b\u4e0d\u5230\u63a5\u53e3\u6587\u6863\u7684\u95ee\u9898\n        Properties properties=new Properties();\n        properties.setProperty(\"serverAddr\",serverAddr);\n        if(namespace!=null && !\"\".equals(namespace)){\n            log.info(\"nacos.discovery.namespace = {}\", namespace);\n            properties.setProperty(\"namespace\",namespace);\n        }\n        if(username!=null && !\"\".equals(username)){\n            properties.setProperty(\"username\",username);\n        }\n        if(password!=null && !\"\".equals(password)){\n            properties.setProperty(\"password\",password);\n        }\n        //\u3010issues/5115\u3011\u56e0swagger\u6587\u6863\u5bfc\u81f4gateway\u5185\u5b58\u6ea2\u51fa\n        if (this.naming == null) {\n            this.naming = NamingFactory.createNamingService(properties);\n        }\n        log.info(\" config.group : {}\", group);\n        List<Instance> list = this.naming.selectInstances(routeId, group , true);\n        if (ObjectUtil.isNotEmpty(list)) {\n            hasRoute = true;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return hasRoute;\n}\n",
        "package": "org.jeecg.handler.swagger",
        "class_name": "MySwaggerResourceProvider",
        "method_name": "checkRoute",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic static void validate(String jdbcUrl){\n    if(oConvertUtils.isEmpty(jdbcUrl)){\n        return;\n    }\n    String urlConcatChar = \"?\";\n    if(jdbcUrl.indexOf(urlConcatChar)<0){\n        return;\n    }\n    String argString = jdbcUrl.substring(jdbcUrl.indexOf(urlConcatChar)+1);\n    String[] keyAndValues = argString.split(\"&\");\n    for(String temp: keyAndValues){\n        String key = temp.split(\"=\")[0];\n        for(String prop: notAllowedProps){\n            if(prop.equalsIgnoreCase(key)){\n                throw new JeecgBootException(\"\u8fde\u63a5\u5730\u5740\u6709\u5b89\u5168\u98ce\u9669\uff0c\u3010\"+key+\"\u3011\");\n            }\n        }\n    }\n}\n",
        "package": "org.jeecg.common.util.security",
        "class_name": "JdbcSecurityUtil",
        "method_name": "validate",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic static String upload(FileItemStream file, String fileDir) {\n    String filePath = null;\n    initOss(endPoint, accessKeyId, accessKeySecret);\n    StringBuilder fileUrl = new StringBuilder();\n    try {\n        String suffix = file.getName().substring(file.getName().lastIndexOf('.'));\n        String fileName = UUID.randomUUID().toString().replace(\"-\", \"\") + suffix;\n        if (!fileDir.endsWith(SymbolConstant.SINGLE_SLASH)) {\n            fileDir = fileDir.concat(SymbolConstant.SINGLE_SLASH);\n        }\n        fileDir = StrAttackFilter.filter(fileDir);\n        fileUrl = fileUrl.append(fileDir + fileName);\n        if (oConvertUtils.isNotEmpty(staticDomain) && staticDomain.toLowerCase().startsWith(CommonConstant.STR_HTTP)) {\n            filePath = staticDomain + SymbolConstant.SINGLE_SLASH + fileUrl;\n        } else {\n            filePath = \"https://\" + bucketName + \".\" + endPoint + SymbolConstant.SINGLE_SLASH + fileUrl;\n        }\n        PutObjectResult result = ossClient.putObject(bucketName, fileUrl.toString(), file.openStream());\n        // \u8bbe\u7f6e\u6743\u9650(\u516c\u5f00\u8bfb)\n        ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);\n        if (result != null) {\n            log.info(\"------OSS\u6587\u4ef6\u4e0a\u4f20\u6210\u529f------\" + fileUrl);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        return null;\n    }\n    return filePath;\n}\n",
        "package": "org.jeecg.common.util.oss",
        "class_name": "OssBootUtil",
        "method_name": "upload",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nprivate static String bytesToHexString(byte[] src) {\n    StringBuilder stringBuilder = new StringBuilder();\n    if (src == null || src.length <= 0) {\n        return null;\n    }\n    for (int i = 0; i < src.length; i++) {\n        int v = src[i] & 0xFF;\n        String hv = Integer.toHexString(v);\n        if (hv.length() < 2) {\n            stringBuilder.append(0);\n        }\n        stringBuilder.append(hv);\n    }\n    return stringBuilder.toString();\n}\n",
        "package": "org.jeecg.common.util.filter",
        "class_name": "SsrfFileTypeFilter",
        "method_name": "bytesToHexString",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic static String getEncodeData(String data, SensitiveEnum sensitiveEnum){\n    String result;\n    switch (sensitiveEnum){\n        case ENCODE:\n            try {\n                result = AesEncryptUtil.encrypt(data);\n            } catch (Exception exception) {\n                log.error(\"\u6570\u636e\u52a0\u5bc6\u9519\u8bef\", exception.getMessage());\n                result = data;\n            }\n            break;\n        case CHINESE_NAME:\n            result = chineseName(data);\n            break;\n        case ID_CARD:\n            result = idCardNum(data);\n            break;\n        case FIXED_PHONE:\n            result = fixedPhone(data);\n            break;\n        case MOBILE_PHONE:\n            result = mobilePhone(data);\n            break;\n        case ADDRESS:\n            result = address(data, 3);\n            break;\n        case EMAIL:\n            result = email(data);\n            break;\n        case BANK_CARD:\n            result = bankCard(data);\n            break;\n        case CNAPS_CODE:\n            result = cnapsCode(data);\n            break;\n        default:\n            result = data;\n    }\n    return result;\n}\n",
        "package": "org.jeecg.common.desensitization.util",
        "class_name": "SensitiveInfoUtil",
        "method_name": "getEncodeData",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic static String getUserNameByToken(HttpServletRequest request) throws JeecgBootException {\n\tString accessToken = request.getHeader(\"X-Access-Token\");\n\tString username = getUsername(accessToken);\n\tif (oConvertUtils.isEmpty(username)) {\n\t\tthrow new JeecgBootException(\"\u672a\u83b7\u53d6\u5230\u7528\u6237\");\n\t}\n\treturn username;\n}\n",
        "package": "org.jeecg.common.system.util",
        "class_name": "JwtUtil",
        "method_name": "getUserNameByToken",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nprivate Object parseDictText(Object result) {\n    if (result instanceof Result) {\n        if (((Result) result).getResult() instanceof IPage) {\n            List<JSONObject> items = new ArrayList<>();\n\n            //step.1 \u7b5b\u9009\u51fa\u52a0\u4e86 Dict \u6ce8\u89e3\u7684\u5b57\u6bb5\u5217\u8868\n            List<Field> dictFieldList = new ArrayList<>();\n            // \u5b57\u5178\u6570\u636e\u5217\u8868\uff0c key = \u5b57\u5178code\uff0cvalue=\u6570\u636e\u5217\u8868\n            Map<String, List<String>> dataListMap = new HashMap<>(5);\n            //\u53d6\u51fa\u7ed3\u679c\u96c6\n            List<Object> records=((IPage) ((Result) result).getResult()).getRecords();\n            //update-begin--Author:zyf -- Date:20220606 ----for\uff1a\u3010VUEN-1230\u3011 \u5224\u65ad\u662f\u5426\u542b\u6709\u5b57\u5178\u6ce8\u89e3,\u6ca1\u6709\u6ce8\u89e3\u8fd4\u56de-----\n            Boolean hasDict= checkHasDict(records);\n            if(!hasDict){\n                return result;\n            }\n\n            log.debug(\" __ \u8fdb\u5165\u5b57\u5178\u7ffb\u8bd1\u5207\u9762 DictAspect \u2014\u2014 \" );\n            //update-end--Author:zyf -- Date:20220606 ----for\uff1a\u3010VUEN-1230\u3011 \u5224\u65ad\u662f\u5426\u542b\u6709\u5b57\u5178\u6ce8\u89e3,\u6ca1\u6709\u6ce8\u89e3\u8fd4\u56de-----\n            for (Object record : records) {\n                String json=\"{}\";\n                try {\n                    //update-begin--Author:zyf -- Date:20220531 ----for\uff1a\u3010issues/#3629\u3011 DictAspect Jackson\u5e8f\u5217\u5316\u62a5\u9519-----\n                    //\u89e3\u51b3@JsonFormat\u6ce8\u89e3\u89e3\u6790\u4e0d\u4e86\u7684\u95ee\u9898\u8be6\u89c1SysAnnouncement\u7c7b\u7684@JsonFormat\n                     json = objectMapper.writeValueAsString(record);\n                    //update-end--Author:zyf -- Date:20220531 ----for\uff1a\u3010issues/#3629\u3011 DictAspect Jackson\u5e8f\u5217\u5316\u62a5\u9519-----\n                } catch (JsonProcessingException e) {\n                    log.error(\"json\u89e3\u6790\u5931\u8d25\"+e.getMessage(),e);\n                }\n                //update-begin--Author:scott -- Date:20211223 ----for\uff1a\u3010issues/3303\u3011restcontroller\u8fd4\u56dejson\u6570\u636e\u540ekey\u987a\u5e8f\u9519\u4e71 -----\n                JSONObject item = JSONObject.parseObject(json, Feature.OrderedField);\n                //update-end--Author:scott -- Date:20211223 ----for\uff1a\u3010issues/3303\u3011restcontroller\u8fd4\u56dejson\u6570\u636e\u540ekey\u987a\u5e8f\u9519\u4e71 -----\n\n                //update-begin--Author:scott -- Date:20190603 ----for\uff1a\u89e3\u51b3\u7ee7\u627f\u5b9e\u4f53\u5b57\u6bb5\u65e0\u6cd5\u7ffb\u8bd1\u95ee\u9898------\n                //for (Field field : record.getClass().getDeclaredFields()) {\n                // \u904d\u5386\u6240\u6709\u5b57\u6bb5\uff0c\u628a\u5b57\u5178Code\u53d6\u51fa\u6765\uff0c\u653e\u5230 map \u91cc\n                for (Field field : oConvertUtils.getAllFields(record)) {\n                    String value = item.getString(field.getName());\n                    if (oConvertUtils.isEmpty(value)) {\n                        continue;\n                    }\n                //update-end--Author:scott  -- Date:20190603 ----for\uff1a\u89e3\u51b3\u7ee7\u627f\u5b9e\u4f53\u5b57\u6bb5\u65e0\u6cd5\u7ffb\u8bd1\u95ee\u9898------\n                    if (field.getAnnotation(Dict.class) != null) {\n                        if (!dictFieldList.contains(field)) {\n                            dictFieldList.add(field);\n                        }\n                        String code = field.getAnnotation(Dict.class).dicCode();\n                        String text = field.getAnnotation(Dict.class).dicText();\n                        String table = field.getAnnotation(Dict.class).dictTable();\n\n                        List<String> dataList;\n                        String dictCode = code;\n                        if (!StringUtils.isEmpty(table)) {\n                            dictCode = String.format(\"%s,%s,%s\", table, text, code);\n                        }\n                        dataList = dataListMap.computeIfAbsent(dictCode, k -> new ArrayList<>());\n                        this.listAddAllDeduplicate(dataList, Arrays.asList(value.split(\",\")));\n                    }\n                    //date\u7c7b\u578b\u9ed8\u8ba4\u8f6c\u6362string\u683c\u5f0f\u5316\u65e5\u671f\n                    //update-begin--Author:zyf -- Date:20220531 ----for\uff1a\u3010issues/#3629\u3011 DictAspect Jackson\u5e8f\u5217\u5316\u62a5\u9519-----\n                    //if (JAVA_UTIL_DATE.equals(field.getType().getName())&&field.getAnnotation(JsonFormat.class)==null&&item.get(field.getName())!=null){\n                        //SimpleDateFormat aDate=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                        // item.put(field.getName(), aDate.format(new Date((Long) item.get(field.getName()))));\n                    //}\n                    //update-end--Author:zyf -- Date:20220531 ----for\uff1a\u3010issues/#3629\u3011 DictAspect Jackson\u5e8f\u5217\u5316\u62a5\u9519-----\n                }\n                items.add(item);\n            }\n\n            //step.2 \u8c03\u7528\u7ffb\u8bd1\u65b9\u6cd5\uff0c\u4e00\u6b21\u6027\u7ffb\u8bd1\n            Map<String, List<DictModel>> translText = this.translateAllDict(dataListMap);\n\n            //step.3 \u5c06\u7ffb\u8bd1\u7ed3\u679c\u586b\u5145\u5230\u8fd4\u56de\u7ed3\u679c\u91cc\n            for (JSONObject record : items) {\n                for (Field field : dictFieldList) {\n                    String code = field.getAnnotation(Dict.class).dicCode();\n                    String text = field.getAnnotation(Dict.class).dicText();\n                    String table = field.getAnnotation(Dict.class).dictTable();\n\n                    String fieldDictCode = code;\n                    if (!StringUtils.isEmpty(table)) {\n                        fieldDictCode = String.format(\"%s,%s,%s\", table, text, code);\n                    }\n\n                    String value = record.getString(field.getName());\n                    if (oConvertUtils.isNotEmpty(value)) {\n                        List<DictModel> dictModels = translText.get(fieldDictCode);\n                        if(dictModels==null || dictModels.size()==0){\n                            continue;\n                        }\n\n                        String textValue = this.translDictText(dictModels, value);\n                        log.debug(\" \u5b57\u5178Val : \" + textValue);\n                        log.debug(\" __\u7ffb\u8bd1\u5b57\u5178\u5b57\u6bb5__ \" + field.getName() + CommonConstant.DICT_TEXT_SUFFIX + \"\uff1a \" + textValue);\n\n                        // TODO-sun \u6d4b\u8bd5\u8f93\u51fa\uff0c\u5f85\u5220\n                        log.debug(\" ---- dictCode: \" + fieldDictCode);\n                        log.debug(\" ---- value: \" + value);\n                        log.debug(\" ----- text: \" + textValue);\n                        log.debug(\" ---- dictModels: \" + JSON.toJSONString(dictModels));\n\n                        record.put(field.getName() + CommonConstant.DICT_TEXT_SUFFIX, textValue);\n                    }\n                }\n            }\n\n            ((IPage) ((Result) result).getResult()).setRecords(items);\n        }\n\n    }\n    return result;\n}\n",
        "package": "org.jeecg.common.aspect",
        "class_name": "DictAspect",
        "method_name": "parseDictText",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic static void handleNestedObject(Object obj, Class entity, boolean isEncode) throws IllegalAccessException {\n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            handlerObject(nestedObject, isEncode);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        handleList(nestedObject, entity, isEncode);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
        "package": "org.jeecg.common.desensitization.util",
        "class_name": "SensitiveInfoUtil",
        "method_name": "handleNestedObject",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\npublic synchronized String update(RouteDefinition definition) {\n    try {\n        log.info(\"gateway update route {}\", definition);\n    } catch (Exception e) {\n        return \"update fail,not find route  routeId: \" + definition.getId();\n    }\n    try {\n        repository.save(Mono.just(definition)).subscribe();\n        this.publisher.publishEvent(new RefreshRoutesEvent(this));\n        return \"success\";\n    } catch (Exception e) {\n        return \"update route fail\";\n    }\n}\n",
        "package": "org.jeecg.loader.repository",
        "class_name": "DynamicRouteService",
        "method_name": "update",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept"
        ]
    },
    {
        "project_name": "jeecg-boot",
        "code": "\nlic static String getPackPath(Object object) {\n \u68c0\u67e5\u7528\u6237\u4f20\u5165\u7684\u53c2\u6570\u662f\u5426\u4e3a\u7a7a\n (object == null) {\nhrow new java.lang.IllegalArgumentException(\"\u53c2\u6570\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\n\n \u83b7\u5f97\u7c7b\u7684\u5168\u540d\uff0c\u5305\u62ec\u5305\u540d\nring clsName = object.getClass().getName();\nturn clsName;\n\n",
        "package": "org.jeecg.common.util",
        "class_name": "MyClassLoader",
        "method_name": "getPackPath",
        "SourceCode&Full": [
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic static int getCodeword(int symbol) {\n  int i = Arrays.binarySearch(SYMBOL_TABLE, symbol & 0x3FFFF);\n  if (i < 0) {\n    return -1;\n  }\n  return (CODEWORD_TABLE[i] - 1) % NUMBER_OF_CODEWORDS;\n}\n",
        "package": "com.google.zxing.pdf417",
        "class_name": "PDF417Common",
        "method_name": "getCodeword",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic AztecDetectorResult detect(boolean isMirror) throws NotFoundException {\n\n  // 1. Get the center of the aztec matrix\n  Point pCenter = getMatrixCenter();\n\n  // 2. Get the center points of the four diagonal points just outside the bull's eye\n  //  [topRight, bottomRight, bottomLeft, topLeft]\n  ResultPoint[] bullsEyeCorners = getBullsEyeCorners(pCenter);\n\n  if (isMirror) {\n    ResultPoint temp = bullsEyeCorners[0];\n    bullsEyeCorners[0] = bullsEyeCorners[2];\n    bullsEyeCorners[2] = temp;\n  }\n\n  // 3. Get the size of the matrix and other parameters from the bull's eye\n  int errorsCorrected = extractParameters(bullsEyeCorners);\n\n  // 4. Sample the grid\n  BitMatrix bits = sampleGrid(image,\n                              bullsEyeCorners[shift % 4],\n                              bullsEyeCorners[(shift + 1) % 4],\n                              bullsEyeCorners[(shift + 2) % 4],\n                              bullsEyeCorners[(shift + 3) % 4]);\n\n  // 5. Get the corners of the matrix.\n  ResultPoint[] corners = getMatrixCornerPoints(bullsEyeCorners);\n\n  return new AztecDetectorResult(bits, corners, compact, nbDataBlocks, nbLayers, errorsCorrected);\n}\n",
        "package": "com.google.zxing.aztec.detector",
        "class_name": "Detector",
        "method_name": "detect",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate Point getMatrixCenter() {\n\n  ResultPoint pointA;\n  ResultPoint pointB;\n  ResultPoint pointC;\n  ResultPoint pointD;\n\n  //Get a white rectangle that can be the border of the matrix in center bull's eye or\n  try {\n\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n\n  } catch (NotFoundException e) {\n\n    // This exception can be in case the initial rectangle is white\n    // In that case, surely in the bull's eye, we try to expand the rectangle.\n    int cx = image.getWidth() / 2;\n    int cy = image.getHeight() / 2;\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n\n  }\n\n  //Compute the center of the rectangle\n  int cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  int cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n\n  // Redetermine the white rectangle starting from previously computed center.\n  // This will ensure that we end up with a white rectangle in center bull's eye\n  // in order to compute a more accurate center.\n  try {\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image, 15, cx, cy).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n  } catch (NotFoundException e) {\n    // This exception can be in case the initial rectangle is white\n    // In that case we try to expand the rectangle.\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n  }\n\n  // Recompute the center of the rectangle\n  cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n\n  return new Point(cx, cy);\n}\n",
        "package": "com.google.zxing.aztec.detector",
        "class_name": "Detector",
        "method_name": "getMatrixCenter",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic int getNextSet(int from) {\n  if (from >= size) {\n    return size;\n  }\n  int bitsOffset = from / 32;\n  int currentBits = bits[bitsOffset];\n  // mask off lesser bits first\n  currentBits &= -(1 << (from & 0x1F));\n  while (currentBits == 0) {\n    if (++bitsOffset == bits.length) {\n      return size;\n    }\n    currentBits = bits[bitsOffset];\n  }\n  int result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n  return Math.min(result, size);\n}\n",
        "package": "com.google.zxing.common",
        "class_name": "BitArray",
        "method_name": "getNextSet",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "@Override\npublic boolean equals(Object o) {\n  if (!(o instanceof FinderPattern)) {\n    return false;\n  }\n  FinderPattern that = (FinderPattern) o;\n  return value == that.value;\n}\n",
        "package": "com.google.zxing.oned.rss",
        "class_name": "FinderPattern",
        "method_name": "equals",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "// Create a new state representing this state, but an additional character\n// output in Binary Shift mode.\nState addBinaryShiftChar(int index) {\n  Token token = this.token;\n  int mode = this.mode;\n  int bitCount = this.bitCount;\n  if (this.mode == HighLevelEncoder.MODE_PUNCT || this.mode == HighLevelEncoder.MODE_DIGIT) {\n    int latch = HighLevelEncoder.LATCH_TABLE[mode][HighLevelEncoder.MODE_UPPER];\n    token = token.add(latch & 0xFFFF, latch >> 16);\n    bitCount += latch >> 16;\n    mode = HighLevelEncoder.MODE_UPPER;\n  }\n  int deltaBitCount =\n      (binaryShiftByteCount == 0 || binaryShiftByteCount == 31) ? 18 :\n      (binaryShiftByteCount == 62) ? 9 : 8;\n  State result = new State(token, mode, binaryShiftByteCount + 1, bitCount + deltaBitCount);\n  if (result.binaryShiftByteCount == 2047 + 31) {\n    // The string is as long as it's allowed to be.  We should end it.\n    result = result.endBinaryShift(index + 1);\n  }\n  return result;\n}\n",
        "package": "com.google.zxing.aztec.encoder",
        "class_name": "State",
        "method_name": "addBinaryShiftChar",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic static float distance(int aX, int aY, int bX, int bY) {\n  double xDiff = aX - bX;\n  double yDiff = aY - bY;\n  return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n}\n",
        "package": "com.google.zxing.common.detector",
        "class_name": "MathUtils",
        "method_name": "distance",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate static void calculateThresholdForBlock(byte[] luminances,\n                                               int subWidth,\n                                               int subHeight,\n                                               int width,\n                                               int height,\n                                               int[][] blackPoints,\n                                               BitMatrix matrix) {\n  int maxYOffset = height - BLOCK_SIZE;\n  int maxXOffset = width - BLOCK_SIZE;\n  for (int y = 0; y < subHeight; y++) {\n    int yoffset = y << BLOCK_SIZE_POWER;\n    if (yoffset > maxYOffset) {\n      yoffset = maxYOffset;\n    }\n    int top = cap(y, subHeight - 3);\n    for (int x = 0; x < subWidth; x++) {\n      int xoffset = x << BLOCK_SIZE_POWER;\n      if (xoffset > maxXOffset) {\n        xoffset = maxXOffset;\n      }\n      int left = cap(x, subWidth - 3);\n      int sum = 0;\n      for (int z = -2; z <= 2; z++) {\n        int[] blackRow = blackPoints[top + z];\n        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n      }\n      int average = sum / 25;\n      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n    }\n  }\n}\n",
        "package": "com.google.zxing.common",
        "class_name": "HybridBinarizer",
        "method_name": "calculateThresholdForBlock",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic int decodeWithECCount(int[] received, int twoS) throws ReedSolomonException {\n  GenericGFPoly poly = new GenericGFPoly(field, received);\n  int[] syndromeCoefficients = new int[twoS];\n  boolean noError = true;\n  for (int i = 0; i < twoS; i++) {\n    int eval = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n    syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;\n    if (eval != 0) {\n      noError = false;\n    }\n  }\n  if (noError) {\n    return 0;\n  }\n  GenericGFPoly syndrome = new GenericGFPoly(field, syndromeCoefficients);\n  GenericGFPoly[] sigmaOmega =\n      runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n  GenericGFPoly sigma = sigmaOmega[0];\n  GenericGFPoly omega = sigmaOmega[1];\n  int[] errorLocations = findErrorLocations(sigma);\n  int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);\n  for (int i = 0; i < errorLocations.length; i++) {\n    int position = received.length - 1 - field.log(errorLocations[i]);\n    if (position < 0) {\n      throw new ReedSolomonException(\"Bad error location\");\n    }\n    received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n  }\n  return errorLocations.length;\n}\n",
        "package": "com.google.zxing.common.reedsolomon",
        "class_name": "ReedSolomonDecoder",
        "method_name": "decodeWithECCount",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic ResultPoint[] detect() throws NotFoundException {\n\n  int left = leftInit;\n  int right = rightInit;\n  int up = upInit;\n  int down = downInit;\n  boolean sizeExceeded = false;\n  boolean aBlackPointFoundOnBorder = true;\n\n  boolean atLeastOneBlackPointFoundOnRight = false;\n  boolean atLeastOneBlackPointFoundOnBottom = false;\n  boolean atLeastOneBlackPointFoundOnLeft = false;\n  boolean atLeastOneBlackPointFoundOnTop = false;\n\n  while (aBlackPointFoundOnBorder) {\n\n    aBlackPointFoundOnBorder = false;\n\n    // .....\n    // .   |\n    // .....\n    boolean rightBorderNotWhite = true;\n    while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n      rightBorderNotWhite = containsBlackPoint(up, down, right, false);\n      if (rightBorderNotWhite) {\n        right++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnRight = true;\n      } else if (!atLeastOneBlackPointFoundOnRight) {\n        right++;\n      }\n    }\n\n    if (right >= width) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .....\n    // .   .\n    // .___.\n    boolean bottomBorderNotWhite = true;\n    while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n      bottomBorderNotWhite = containsBlackPoint(left, right, down, true);\n      if (bottomBorderNotWhite) {\n        down++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnBottom = true;\n      } else if (!atLeastOneBlackPointFoundOnBottom) {\n        down++;\n      }\n    }\n\n    if (down >= height) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .....\n    // |   .\n    // .....\n    boolean leftBorderNotWhite = true;\n    while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n      leftBorderNotWhite = containsBlackPoint(up, down, left, false);\n      if (leftBorderNotWhite) {\n        left--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnLeft = true;\n      } else if (!atLeastOneBlackPointFoundOnLeft) {\n        left--;\n      }\n    }\n\n    if (left < 0) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .___.\n    // .   .\n    // .....\n    boolean topBorderNotWhite = true;\n    while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n      topBorderNotWhite = containsBlackPoint(left, right, up, true);\n      if (topBorderNotWhite) {\n        up--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnTop = true;\n      } else if (!atLeastOneBlackPointFoundOnTop) {\n        up--;\n      }\n    }\n\n    if (up < 0) {\n      sizeExceeded = true;\n      break;\n    }\n\n  }\n\n  if (!sizeExceeded) {\n\n    int maxSize = right - left;\n\n    ResultPoint z = null;\n    for (int i = 1; z == null && i < maxSize; i++) {\n      z = getBlackPointOnSegment(left, down - i, left + i, down);\n    }\n\n    if (z == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint t = null;\n    //go down right\n    for (int i = 1; t == null && i < maxSize; i++) {\n      t = getBlackPointOnSegment(left, up + i, left + i, up);\n    }\n\n    if (t == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint x = null;\n    //go down left\n    for (int i = 1; x == null && i < maxSize; i++) {\n      x = getBlackPointOnSegment(right, up + i, right - i, up);\n    }\n\n    if (x == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint y = null;\n    //go up left\n    for (int i = 1; y == null && i < maxSize; i++) {\n      y = getBlackPointOnSegment(right, down - i, right - i, down);\n    }\n\n    if (y == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    return centerEdges(y, z, x, t);\n\n  } else {\n    throw NotFoundException.getNotFoundInstance();\n  }\n}\n",
        "package": "com.google.zxing.common.detector",
        "class_name": "WhiteRectangleDetector",
        "method_name": "detect",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate static String getCharacter(Table table, int code) {\n  switch (table) {\n    case UPPER:\n      return UPPER_TABLE[code];\n    case LOWER:\n      return LOWER_TABLE[code];\n    case MIXED:\n      return MIXED_TABLE[code];\n    case PUNCT:\n      return PUNCT_TABLE[code];\n    case DIGIT:\n      return DIGIT_TABLE[code];\n    default:\n      // Should not reach here.\n      throw new IllegalStateException(\"Bad table\");\n  }\n}\n",
        "package": "com.google.zxing.aztec.decoder",
        "class_name": "Decoder",
        "method_name": "getCharacter",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
        "package": "com.google.zxing.aztec.decoder",
        "class_name": "Decoder",
        "method_name": "getEncodedData",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic final AlertDialog initiateScan(Collection<String> desiredBarcodeFormats, int cameraId) {\n  Intent intentScan = new Intent(BS_PACKAGE + \".SCAN\");\n  intentScan.addCategory(Intent.CATEGORY_DEFAULT);\n\n  // check which types of codes to scan for\n  if (desiredBarcodeFormats != null) {\n    // set the desired barcode types\n    StringBuilder joinedByComma = new StringBuilder();\n    for (String format : desiredBarcodeFormats) {\n      if (joinedByComma.length() > 0) {\n        joinedByComma.append(',');\n      }\n      joinedByComma.append(format);\n    }\n    intentScan.putExtra(\"SCAN_FORMATS\", joinedByComma.toString());\n  }\n\n  // check requested camera ID\n  if (cameraId >= 0) {\n    intentScan.putExtra(\"SCAN_CAMERA_ID\", cameraId);\n  }\n\n  String targetAppPackage = findTargetAppPackage(intentScan);\n  if (targetAppPackage == null) {\n    return showDownloadDialog();\n  }\n  intentScan.setPackage(targetAppPackage);\n  intentScan.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n  intentScan.addFlags(FLAG_NEW_DOC);\n  attachMoreExtras(intentScan);\n  startActivityForResult(intentScan, REQUEST_CODE);\n  return null;\n}\n",
        "package": "com.google.zxing.integration.android",
        "class_name": "IntentIntegrator",
        "method_name": "initiateScan",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic static AztecCode encode(String data, int minECCPercent, int userSpecifiedLayers, Charset charset) {\n  byte[] bytes = data.getBytes(null != charset ? charset : StandardCharsets.ISO_8859_1);\n  return encode(bytes, minECCPercent, userSpecifiedLayers, charset);\n}\n",
        "package": "com.google.zxing.aztec.encoder",
        "class_name": "Encoder",
        "method_name": "encode",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    }
]